好的，这是关于“习题2”部分的笔记，我将根据提供的内容进行整理。由于没有实际的参考答案，我将主要列出习题的题干，并对一些题目类型稍作说明。

## 习题 2

**1. 给出以下概念的解释说明。**

*   (1) 真值
*   (2) 机器数
*   (3) 数值数据
*   (4) 非数值数据
*   (5) 无符号整数
*   (6) 带符号整数
*   (7) 定点数
*   (8) 原码
*   (9) 反码
*   (10) 补码
*   (11) 变形补码
*   (12) 浮点数
*   (13) 尾数
*   (14) 阶码
*   (15) 移码
*   (16) 溢出
*   (17) 下溢
*   (18) 上溢
*   (19) 规格化数
*   (20) 左规
*   (21) 右规
*   (22) 非规格化数
*   (23) 机器零
*   (24) 非数 (NaN)
*   (25) BCD 码
*   (26) 逻辑数
*   (27) ASCII 码
*   (28) 汉字输入码
*   (29) 汉字内码
*   (30) 机器字长
*   (31) 大端方式
*   (32) 小端方式
*   (33) 字地址
*   (34) 边界对齐
*   (35) 检错
*   (36) 纠错
*   (37) 码距
*   (38) 奇偶校验
*   (39) 海明码
*   (40) 循环冗余校验 (CRC)
*   (41) 最高有效位 (MSB)
*   (42) 最高有效字节 (MSB)
*   (43) 最低有效位 (LSB)
*   (44) 最低有效字节 (LSB)

**2. 简单回答下列问题。**

*   (1) 为什么计算机内部采用二进制表示信息？既然计算机内部所有信息都用二进制表示，为什么还要用到十六进制或八进制数？
*   (2) 常用的定点数编码方式有哪几种？通常它们各自用来表示什么？
*   (3) 为什么现代计算机中大多用补码表示带符号整数？
*   (4) 在浮点数的基数和总位数一定的情况下，浮点数的表示范围和精度分别由什么决定？两者如何相互制约？
*   (5) 为什么要对浮点数进行规格化？有哪两种规格化操作？
*   (6) 为什么有些计算机中除了用二进制外还用 BCD 码来表示数值数据？
*   (7) 为什么计算机处理汉字时会涉及到不同的编码（如输入码、内码、字模码）？说明这些编码中哪些用二进制编码，哪些不用二进制编码，为什么？

**3. 实现下列各数的转换。**

*   (1) (25.8125)<sub>10</sub> = (?)<sub>2</sub> = (?)<sub>8</sub> = (?)<sub>16</sub>
*   (2) (101101.011)<sub>2</sub> = (?)<sub>10</sub> = (?)<sub>8</sub> = (?)<sub>16</sub> = (?)<sub>8421</sub>
*   (3) (0101 1001 0110.0011)<sub>8421</sub> = (?)<sub>10</sub> = (?)<sub>2</sub> = (?)<sub>16</sub>
*   (4) (4E.C)<sub>16</sub> = (?)<sub>10</sub> = (?)<sub>2</sub>

**4. 假定机器数为 8 位 (1 位符号，7 位数值)，写出下列各二进制数的原码和补码表示。**

+0.1001, -0.1001, +1.0, -1.0, +0.010100, -0.010100, +0, -0

**5. 假定机器数为 8 位 (1 位符号，7 位数值)，写出下列各二进制数的补码和移码表示。**

+1001, -1001, +1, -1, +10100, -10100, +0, -0

**6. 已知 [x]<sub>补</sub>，求 x。**

*   (1) [x]<sub>补</sub> = 1.1100111
*   (2) [x]<sub>补</sub> = 10000000
*   (3) [x]<sub>补</sub> = 0.1010010
*   (4) [x]<sub>补</sub> = 11010011

**7. 假定一台 32 位字长的机器中带符号整数用补码表示，浮点数用 IEEE 754 标准表示。寄存器 R1 和 R2 的内容分别为 R1: 0000108BH, R2: 8080108BH。不同指令对寄存器进行不同的操作，因而，不同指令执行时寄存器内容对应的真值不同。假定执行下列运算指令时，操作数为寄存器 R1 和 R2 的内容，则 R1 和 R2 中操作数的真值分别为多少？**

*   (1) 无符号数加法指令。
*   (2) 带符号整数乘法指令。
*   (3) 单精度浮点数减法指令。

**8. 假定机器 M 的字长为 32 位，用补码表示带符号整数。表 2.14 第一列给出了在机器 M 上执行的 C 语言程序中的关系表达式，请参照已有的表栏内容完成表中后三栏内容的填写。**

| 关系表达式                      | 运算类型     | 结果 | 说明                                     |
| :------------------------------ | :----------- | :--- | :--------------------------------------- |
| 0 == 0U                         |              |      |                                          |
| -1 < 0                          |              |      |                                          |
| -1 < 0U                         | 无符号整数   | 0    | 11...1B (2<sup>32</sup>-1) > 00...0B(0)      |
| 2147483647 > -2147483647-1      | 有符号整数   | 1    | 01...1B (2<sup>31</sup>-1) > 10...0B(-2<sup>31</sup>) |
| 2147483647U > -2147483647-1     |              |      |                                          |
| 2147483647 > (int)2147483648U |              |      |                                          |
| -1 > -2                         |              |      |                                          |
| (unsigned)-1 > -2             |              |      |                                          |
*注：表中第 4 和第 5 行的 -2147483647-1 没有写成 -2147483648，因为有些编译器处理一个形如 -x 的表达式时，可能会先读取表达式 x，然后对 x 取负。当 x=2147483648 时，因为用 32 位补码无法表示 x，所以，写成 -2147483648 时可能会发生编译错误。*

**9. 以下是一个 C 语言程序，用来计算一个数组 a 中每个元素的和。当参数 len 为 0 时，返回值应该是 0，但是在机器上执行时，却发生了存储器访问异常。请问这是什么原因造成的？并说明程序应该如何修改。**
```c
1 float sum_elements (float a[], unsigned len)
2 {
3   int i;
4   float result=0;
5
6   for (i=0; i<=len-1; i++)
7     result+=a[i];
8
9   return result;
10 }
```

**10. 设某浮点数格式如下：**

| 数符 | 阶码     | 尾数     |
| :--- | :------- | :------- |
| 1 位 | 5 位移码 | 6 位补码 |

其中，移码的偏置常数为 16，补码采用一位符号位，基数为 4。
*   (1) 用这种格式表示下列十进制数：+1.75, +19, -1/8。
*   (2) 写出该格式浮点数的表示范围，并与 12 位定点补码整数和定点补码小数表示范围比较。

**11. 下列几种情况所能表示的数的范围是什么？**
*   (1) 16 位无符号整数
*   (2) 16 位原码定点小数
*   (3) 16 位补码定点小数
*   (4) 16 位补码定点整数
*   (5) 下述格式的浮点数 (基数为 2，移码的偏置常数为 128)：

| 数符 | 阶码     | 尾数     |
| :--- | :------- | :------- |
| 1 位 | 8 位移码 | 7 位补码 |

**12. 以 IEEE 754 单精度浮点数格式表示下列十进制数。**
+1.75, +19, -1/8, 258

**13. 设一个变量的值为 4098，要求分别用 32 位补码整数和 IEEE 754 单精度浮点格式表示该变量 (结果用十六进制表示)，并说明哪段二进制序列在两种表示中完全相同，为什么会相同？**

**14. 设一个变量的值为 -2147483647，要求分别用 32 位补码整数和 IEEE 754 单精度浮点格式表示该变量 (结果用十六进制表示)，并说明哪种表示其值完全精确，哪种表示的是近似值。**

**15. 表 2.15 给出了有关 IEEE 754 浮点格式表示中一些重要的非负数的取值，表中已经有最大规格化数的相应内容，要求填入其他浮点数格式的相应内容。**

| 项目             | 阶码       | 尾数   | 单精度 (以 2 的幂次表示的值) | 单精度 (以 10 的幂次表示的值) | 双精度 (以 2 的幂次表示的值) | 双精度 (以 10 的幂次表示的值) |
| :--------------- | :--------- | :----- | :------------------------- | :-------------------------- | :------------------------- | :-------------------------- |
| 0                |            |        |                            |                             |                            |                             |
| 1                |            |        |                            |                             |                            |                             |
| 最大规格化数     | 11111110   | 1...11 | (2-2<sup>-23</sup>)×2<sup>127</sup>  | 3.4×10<sup>38</sup>            | (2-2<sup>-52</sup>)×2<sup>1023</sup> | 1.8×10<sup>308</sup>           |
| 最小规格化数     |            |        |                            |                             |                            |                             |
| 最大非规格化数   |            |        |                            |                             |                            |                             |
| 最小非规格化数   |            |        |                            |                             |                            |                             |
| +∞               |            |        |                            |                             |                            |                             |
| NaN              |            |        |                            |                             |                            |                             |

**16. 已知下列字符编码：A=1000001, a=1100001, 0=0110000，求 E、e、f、7、G、Z、5 的 7 位 ASCII 码和第一位前加入奇校验位后的 8 位编码。**

**17. 假定在一个程序中定义了变量 x、y 和 i，其中，x 和 y 是 float 型变量 (用 IEEE 754 单精度浮点数表示)，i 是 16 位 short 型变量 (用补码表示)。程序执行到某一时刻，x=-0.125、y=7.5、i=100，它们都被写到了主存 (按字节编址)，其地址分别是 100、108 和 112。请分别画出在大端机器和小端机器上变量 x、y 和 i 在内存中的存放位置。**

**18. 假定某计算机的总线采用奇校验，每 8 位数据有一位校验位。若在 32 位数据线上传输的信息是 8F3CAB96H，则对应的 4 个校验位应为什么？若接收方收到的数据信息和校验位分别为 873CAB96H 和 0101B，则说明发生了什么情况？请给出验证过程。**

**19. 假定一个 16 位数据 M16 M15 M14 M13 M12 M11 M10 M9 M8 M7 M6 M5 M4 M3 M2 M1 为 0101000101000110B，要求写出 16 位数据的 SEC 码，并说明 SEC 码如何正确检测数据位 M5 的错误。**

**20. 假设要传送的数据信息为 100011，若约定的生成多项式为 G(x)=x<sup>3</sup>+1，则校验码为多少？假定在接收端接收到的数据信息为 100010，说明如何正确检测其错误，写出检测过程。**

---
好的，我将尽力提供本章习题的参考答案。请注意，对于概念解释和简答题，答案可能因教材和侧重点略有不同，这里的答案是基于通常的理解。对于计算题，我会给出具体结果，但强烈建议您自己先演算一遍以掌握方法。

---

**1. 给出以下概念的解释说明。**
*(这部分答案较长，请参考您教材中对这些概念的详细定义和解释。这里仅作非常简要的提示。)*

*   (1) **真值 (True Value)**：带有“+”或“-”符号的实际数值。
*   (2) **机器数 (Machine Number)**：数值在计算机中的二进制表示形式，符号也被数字化。
*   (3) **数值数据 (Numerical Data)**：用来表示数量大小的数据。
*   (4) **非数值数据 (Non-numerical Data)**：不表示数量大小的数据，如字符、逻辑值。
*   (5) **无符号整数 (Unsigned Integer)**：所有位都用来表示数值大小，没有符号位，默认为正。
*   (6) **带符号整数 (Signed Integer)**：包含符号位，可以表示正数、负数和零。
*   (7) **定点数 (Fixed-point Number)**：小数点位置固定的数，可以是整数或纯小数。
*   (8) **原码 (Sign-Magnitude)**：最高位为符号位 (0正1负)，其余位表示数值的绝对值。
*   (9) **反码 (One's Complement)**：正数反码同原码；负数反码是其原码符号位不变，数值位按位取反。
*   (10) **补码 (Two's Complement)**：正数补码同原码；负数补码是其反码末位加1（或其原码符号位不变，数值位按位取反末位加1）。
*   (11) **变形补码 (Modified Two's Complement)**：使用双符号位表示的补码，用于溢出检测。
*   (12) **浮点数 (Floating-point Number)**：小数点位置不固定，用阶码和尾数表示的数。
*   (13) **尾数 (Mantissa/Significand)**：浮点数中表示有效数字的部分。
*   (14) **阶码 (Exponent)**：浮点数中表示小数点实际位置的部分。
*   (15) **移码 (Excess/Biased Code)**：将真值加上一个固定的偏置常数得到的编码，常用于表示浮点数的阶码。
*   (16) **溢出 (Overflow)**：运算结果超出机器所能表示的数值范围。
*   (17) **下溢 (Underflow)**：浮点运算结果的绝对值小于机器所能表示的最小绝对值（非零）。
*   (18) **上溢 (Overflow for Floating Point)**：浮点运算结果的绝对值大于机器所能表示的最大绝对值。
*   (19) **规格化数 (Normalized Number)**：尾数的最高有效位为特定值的浮点数，以保证精度和唯一性。
*   (20) **左规 (Left Shift Normalization)**：尾数左移，阶码减小，以达到规格化。
*   (21) **右规 (Right Shift Normalization)**：尾数右移，阶码增大，以达到规格化。
*   (22) **非规格化数 (Denormalized/Subnormal Number)**：IEEE 754中用于表示非常接近零的数，以实现逐渐下溢。
*   (23) **机器零 (Machine Zero)**：浮点数中表示0的值，可能有+0和-0。
*   (24) **非数 (NaN - Not a Number)**：表示无效或未定义的运算结果。
*   (25) **BCD 码 (Binary Coded Decimal)**：用4位二进制数表示一位十进制数。
*   (26) **逻辑数 (Logical Number)**：每一位独立表示逻辑状态 (0或1) 的数据。
*   (27) **ASCII 码 (American Standard Code for Information Interchange)**：美国标准信息交换代码，用7位二进制表示字符。
*   (28) **汉字输入码 (Chinese Character Input Code)**：为将汉字输入计算机而设计的编码，如拼音、五笔。
*   (29) **汉字内码 (Chinese Character Internal Code)**：汉字在计算机内部存储和处理时使用的编码。
*   (30) **机器字长 (Machine Word Length)**：CPU一次能处理的二进制数据的位数。
*   (31) **大端方式 (Big-Endian)**：多字节数据的最高有效字节存储在低地址。
*   (32) **小端方式 (Little-Endian)**：多字节数据的最低有效字节存储在低地址。
*   (33) **字地址 (Word Address)**：存放一个字的内存单元的地址。
*   (34) **边界对齐 (Boundary Alignment)**：数据存放在其长度整数倍的地址处。
*   (35) **检错 (Error Detection)**：检测数据在传输或存储过程中是否发生错误。
*   (36) **纠错 (Error Correction)**：检测并纠正数据在传输或存储过程中发生的错误。
*   (37) **码距 (Hamming Distance)**：两个等长码字对应位上不同符号的个数。
*   (38) **奇偶校验 (Parity Check)**：通过增加一位校验位，使码字中1的个数为奇数或偶数。
*   (39) **海明码 (Hamming Code)**：一种能纠正一位错误的线性分组码。
*   (40) **循环冗余校验 (CRC - Cyclic Redundancy Check)**：利用生成多项式进行编码和校验，检错能力强。
*   (41) **最高有效位 (MSB - Most Significant Bit)**：二进制数中最左边的、权值最高的位。
*   (42) **最高有效字节 (MSB - Most Significant Byte)**：多字节数据中表示数值最高部分的字节。
*   (43) **最低有效位 (LSB - Least Significant Bit)**：二进制数中最右边的、权值最低的位。
*   (44) **最低有效字节 (LSB - Least Significant Byte)**：多字节数据中表示数值最低部分的字节。

**2. 简单回答下列问题。**
*(答案要点)*
*   (1) **二进制原因**：物理上易于实现和区分两种状态；运算规则简单。**十六/八进制用途**：二进制书写冗长、易错，十六/八进制是二进制的简便表示形式，便于阅读和书写。
*   (2) **常用定点数编码**：原码、反码、补码。**原码**：易于理解和转换。**反码**：作为求补码的中间步骤。**补码**：用于带符号整数的存储和运算，因其加减运算统一，0表示唯一等优点。
*   (3) **补码优点**：加减运算统一（减法可转换为加法）；符号位参与运算；0的表示唯一；比原码、反码多表示一个最小负数。
*   (4) **浮点数范围和精度**：**范围**主要由阶码的位数决定；**精度**主要由尾数的位数决定。在总位数一定时，增加阶码位数会减少尾数位数，即扩大范围会降低精度，反之亦然。
*   (5) **规格化目的**：保证浮点数表示的唯一性；提高数据表示的精度（充分利用尾数位）。**操作**：左规（尾数左移，阶码减小）；右规（尾数右移，阶码增大）。
*   (6) **BCD码原因**：在输入输出十进制数频繁且精度要求与十进制完全一致的场合（如商业计算），可以避免二进制与十进制转换的误差和开销，直接用硬件支持BCD运算。
*   (7) **汉字不同编码原因**：**输入码**为了方便用户通过键盘输入汉字；**内码**是汉字在计算机内部的统一表示，用于存储和处理，需要与ASCII码区分；**字模码**是汉字输出（显示、打印）时的点阵或轮廓信息。**二进制编码**：内码、字模码、以及输入码最终在计算机内部都转换为二进制。**不用二进制编码**：严格来说，输入码本身是用户按键的序列或规则，它“映射”到二进制内码，其规则本身不是二进制。

**3. 实现下列各数的转换。**
*   (1) (25.8125)<sub>10</sub> = (11001.1101)<sub>2</sub> = (31.64)<sub>8</sub> = (19.D)<sub>16</sub>
*   (2) (101101.011)<sub>2</sub> = (45.375)<sub>10</sub> = (55.3)<sub>8</sub> = (2D.6)<sub>16</sub> = (0100 0101 . 0011 0111 0101)<sub>BCD</sub>
*   (3) (0101 1001 0110.0011)<sub>BCD</sub> = (596.3)<sub>10</sub> = (1001010100.010011001100...)<sub>2</sub> (BCD转二进制，小数部分可能无限) = (254.4C...)<sub>16</sub>
*   (44) (4E.C)<sub>16</sub> = (78.75)<sub>10</sub> = (1001110.11)<sub>2</sub>

**4. 假定机器数为 8 位 (1 位符号，7 位数值)，写出下列各二进制数的原码和补码表示。**
*(定点小数处理，小数点在符号位之后)*
*   **+0.1001:** 原码: 0.1001000; 补码: 0.1001000
*   **-0.1001:** 原码: 1.1001000; 补码: 1.0111000
*   **+1.0:** (溢出，无法表示为7位数值的纯小数)。如果指整数+1 (0000001): 原码: 00000001; 补码: 00000001
*   **-1.0:** (溢出)。如果指整数-1 (-0000001): 原码: 10000001; 补码: 11111111
*   **+0.010100:** 原码: 0.0101000; 补码: 0.0101000
*   **-0.010100:** 原码: 1.0101000; 补码: 1.1011000
*   **+0:** 原码: 0.0000000; 补码: 0.0000000
*   **-0:** 原码: 1.0000000; 补码: 0.0000000

**5. 假定机器数为 8 位 (1 位符号，7 位数值)，写出下列各二进制数的补码和移码表示。**
*(这里按整数处理，小数点在最右边)*
*   **+1001 (+9):** 补码: 00001001; 移码(偏置128): 10001001
*   **-1001 (-9):** 补码: 11110111; 移码(偏置128): 01110111
*   **+1:** 补码: 00000001; 移码: 10000001
*   **-1:** 补码: 11111111; 移码: 01111111
*   **+10100 (+20):** 补码: 00010100; 移码: 10010100
*   **-10100 (-20):** 补码: 11101100; 移码: 01101100
*   **+0:** 补码: 00000000; 移码: 10000000
*   **-0 (对于补码和移码，0的表示是唯一的，通常按+0处理):** 补码: 00000000; 移码: 10000000

**6. 已知 [x]<sub>补</sub>，求 x。**
*   (1) [x]<sub>补</sub> = 1.1100111  => x = -0.0011001<sub>2</sub>
*   (2) [x]<sub>补</sub> = 10000000 (8位整数) => x = -128<sub>10</sub>
*   (3) [x]<sub>补</sub> = 0.1010010  => x = +0.1010010<sub>2</sub>
*   (4) [x]<sub>补</sub> = 11010011 (8位整数) => x = -00101101<sub>2</sub> = -45<sub>10</sub>

**7. ...R1: 0000108BH, R2: 8080108BH...**
*   R1 = 0000108BH = (6731)<sub>10</sub>
*   R2 = 8080108BH (32位补码) = (-2139090795)<sub>10</sub> (这是一个负数，最高位为1)
*   **(1) 无符号数加法指令：**
    *   R1: (6731)<sub>10</sub>
    *   R2: (2156875915)<sub>10</sub> (8080108BH作为无符号数)
*   **(2) 带符号整数乘法指令：**
    *   R1: (6731)<sub>10</sub>
    *   R2: (-2139090795)<sub>10</sub>
*   **(3) 单精度浮点数减法指令 (IEEE 754)：**
    *   R1 = 0000108BH: S=0, E=00000001(1), f=00001000101100000000000 (表示一个很小的正数或非规格化数)
        *   E=1, bias=127 => 阶码真值 = 1-127 = -126.
        *   尾数 1.000010001011 * 2<sup>-126</sup>
    *   R2 = 8080108BH: S=1, E=00000001(1), f=00000001010001011000000 (表示一个很小的负数或非规格化数)
        *   尾数 -1.00000001010001011 * 2<sup>-126</sup>

**8. ...完成表中后三栏内容的填写。**

| 关系表达式                      | 运算类型     | 结果 | 说明                                           |
| :------------------------------ | :----------- | :--- | :--------------------------------------------- |
| 0 == 0U                         | 无符号/带符号 | 1    | 00...0B == 00...0B                             |
| -1 < 0                          | 带符号整数   | 1    | 11...1B (-1) < 00...0B (0)                     |
| -1 < 0U                         | 无符号整数   | 0    | 11...1B (2<sup>32</sup>-1) > 00...0B(0)        |
| 2147483647 > -2147483647-1      | 带符号整数   | 1    | 01...1B (2<sup>31</sup>-1) > 10...0B(-2<sup>31</sup>)   |
| 2147483647U > -2147483647-1     | 无符号整数   | 1    | 01...1B (2<sup>31</sup>-1) < 10...0B(2<sup>31</sup>) - **应为0** |
| 2147483647 > (int)2147483648U | 带符号整数   | 1    | 01...1B (2<sup>31</sup>-1) > 10...0B (-2<sup>31</sup>) |
| -1 > -2                         | 带符号整数   | 1    | 11...1B (-1) > 11...0B (-2)                    |
| (unsigned)-1 > -2             | 无符号整数   | 1    | 11...1B (2<sup>32</sup>-1) > 11...0B (2<sup>32</sup>-2)   |
*修正第5行：* 2147483647U 是 011...1。 -2147483647-1 的机器码是 100...0，作为无符号数是 2<sup>31</sup>。所以是 (2<sup>31</sup>-1) < 2<sup>31</sup>，结果为 0。

**9. ...当参数 len 为 0 时... 发生存储器访问异常。**
*   **原因：** 当 `len` 为 0 时，`len-1` 因为 `len` 是 `unsigned` 类型，会发生无符号数下溢，变成一个很大的正数 (通常是 `UINT_MAX`)。循环 `i <= len-1` 会执行很多次，导致数组 `a` 访问越界。
*   **修改：** 将循环条件改为 `for (i=0; i < len; i++)`。

**10. 设某浮点数格式如下...**
*   **(1) 表示十进制数：**
    *   **+1.75:** 1.75 = (1.11)<sub>2</sub> * 4<sup>0</sup> (因为基数是4，尾数需要规格化到 [1/4, 1) 或 [-1, -1/4))  -> 1.75 = (0.111)<sub>4</sub> * 4<sup>1</sup>. (基数为4，尾数小数点前可以是0或1或2或3个0)。更规范地，1.75 = (0.0111)<sub>2</sub> * 2<sup>3</sup>。如果尾数是补码，S=0。阶码真值是1 (因为4<sup>1</sup>)，偏置16，阶码移码 = 16+1=17 (10001)。尾数(0.111)<sub>4</sub>。 **或者** +1.75 = + (0.175)<sub>10</sub> * 4<sup>1</sup>。尾数 +0.175 的补码。
        *   **以基数为4，尾数是6位补码 (1位符号，5位数值) 为例：**
            *   +1.75 = (0.13)<sub>4</sub> = + (0.11100)<sub>2</sub> * 4<sup>0</sup> (不规范)
            *   应该规格化尾数，例如对于基数4，尾数绝对值范围 [1/4, 1)。
            *   1.75 = (1.11)<sub>2</sub>。 转换为基数4，尾数M，阶码E，使得 X = M * 4<sup>E</sup>，且 1/4 <= |M| < 1。
            *   1.75 = 0.175 * 10<sup>1</sup> =>  (0.0111)<sub>2</sub> * 2<sup>3</sup>。  **这不是基数为4的表示**
            *   **正确转换思路：** 1.75 = (1.3)<sub>4</sub>  = 0.13 * 4<sup>1</sup>。
                *   S=0。 E<sub>真</sub>=1, E<sub>移</sub> = 16+1=17 (10001)。 尾数 (0.13)<sub>4</sub>。 0.13<sub>4</sub> = 1/4 + 3/16 = 7/16。
                *   6位补码尾数 (1符5数): (0.11100)<sub>2</sub> 即 0.11100
                *   所以：`0 10001 011100`
    *   **(其他数类似转换，重点是基数为4的规格化)**
*   **(2) 表示范围：**
    *   **阶码范围：** 5位移码，偏置16。最小00000 (真值-16)，最大11111 (真值+15)。
    *   **尾数范围 (6位补码，1符5数):** 最小 1.00000 (-1)，最大 0.11111 (31/32)。
    *   **浮点数范围：** 最小负数: -1 * 4<sup>15</sup>。 最大正数: (31/32) * 4<sup>15</sup>。 最小正数 (规格化): (1/4) * 4<sup>-16</sup>。
    *   **12位定点补码整数：** [-2<sup>11</sup>, 2<sup>11</sup>-1] = [-2048, 2047]
    *   **12位定点补码小数 (1符11数):** [-1, 1-2<sup>-11</sup>]

**11. 下列几种情况所能表示的数的范围是什么？**
*   (1) 16 位无符号整数: [0, 2<sup>16</sup>-1] = [0, 65535]
*   (2) 16 位原码定点小数 (1符15数): [-(1-2<sup>-15</sup>), 1-2<sup>-15</sup>]
*   (3) 16 位补码定点小数 (1符15数): [-1, 1-2<sup>-15</sup>]
*   (4) 16 位补码定点整数: [-2<sup>15</sup>, 2<sup>15</sup>-1] = [-32768, 32767]
*   (5) 浮点数格式 (基数2, 阶码8位移码偏置128, 尾数7位补码1符6数):
    *   阶码真值范围: [-128, 127] (00000000 -> -128, 11111111 -> 127)
    *   尾数补码范围: [-1, 1-2<sup>-6</sup>]
    *   规格化尾数绝对值范围: [1/2, 1-2<sup>-6</sup>] (因为最高数值位不能为0)
    *   最大正数: (1-2<sup>-6</sup>) * 2<sup>127</sup>
    *   最小正数 (规格化): (1/2) * 2<sup>-128</sup> = 2<sup>-129</sup>
    *   最小负数: -1 * 2<sup>127</sup>

**12. 以 IEEE 754 单精度浮点数格式表示下列十进制数。**
*   **+1.75:** (1.11)<sub>2</sub> * 2<sup>0</sup>. S=0, E-127=0 => E=127 (01111111). f=110...0.  `0 01111111 11000000000000000000000` (3FE00000H)
*   **+19:** (10011)<sub>2</sub> = (1.0011)<sub>2</sub> * 2<sup>4</sup>. S=0, E-127=4 => E=131 (10000011). f=00110...0. `0 10000011 00110000000000000000000` (41980000H)
*   **-1/8 (-0.125):** -(0.001)<sub>2</sub> = -(1.0)<sub>2</sub> * 2<sup>-3</sup>. S=1, E-127=-3 => E=124 (01111100). f=000...0. `1 01111100 00000000000000000000000` (BE000000H)
*   **258:** (100000010)<sub>2</sub> = (1.0000001)<sub>2</sub> * 2<sup>8</sup>. S=0, E-127=8 => E=135 (10000111). f=00000010...0. `0 10000111 00000010000000000000000` (43810000H)

**13. ...4098...32位补码整数和IEEE 754单精度...**
*   **32位补码整数 4098:** 00000000 00000000 00010000 00000010B (00001002H)
*   **IEEE 754 单精度 4098:** 4098 = (1000000000010)<sub>2</sub> = (1.00000000001)<sub>2</sub> * 2<sup>11</sup>.
    *   S=0. E-127=11 => E=138 (10001010B). f=000000000010...0.
    *   `0 10001010 00000000001000000000000` (45801000H)
*   **相同序列：** 低位的 `000000000010` (即 `002H`) 在整数表示的低12位，在浮点数尾数的低12位（不计隐藏位）。
*   **原因：** 对于正数，整数的低位数值部分和浮点数尾数（去掉隐藏的1之后）的有效数字部分是相同的。

**14. ...-2147483647...32位补码整数和IEEE 754单精度...**
*   **32位补码整数 -2147483647:**  这是 -(2<sup>31</sup>-1)，即 10000000 00000000 00000000 00000001B (80000001H)。 **完全精确**。
*   **IEEE 754 单精度 -2147483647:** -(2<sup>31</sup>-1) = -(1.11...1 (30个1))<sub>2</sub> * 2<sup>30</sup>.
    *   S=1. E-127=30 => E=157 (10011101B). f=11...1 (23个1，因为尾数只有23位，会舍入).
    *   表示为：`1 10011101 11111111111111111111111` (CF FFFFFFH)。 **近似值**，因为尾数部分无法精确表示30个1。

**15. 表 2.15 ...填入其他浮点数格式的相应内容。**
*(需要根据IEEE 754规则计算，涉及阶码全0，全1的特殊情况)*
*   **0:** 阶码全0, 尾数全0. (0 or ±0)
*   **1:** S=0, E-bias=0 => E=bias. f=0. (e.g., 单精度: 0 01111111 000...0)
*   **最小规格化数:** 阶码=0...01 (真值 1-bias). 尾数=1.0...0. (e.g., 单精度: 1 * 2<sup>-126</sup>)
*   **最大非规格化数:** 阶码=0...00. 尾数=0.1...1. (e.g., 单精度: (1-2<sup>-23</sup>) * 2<sup>-126</sup>)
*   **最小非规格化数:** 阶码=0...00. 尾数=0.0...01. (e.g., 单精度: 2<sup>-23</sup> * 2<sup>-126</sup> = 2<sup>-149</sup>)
*   **+∞:** 阶码全1, 尾数全0, S=0.
*   **NaN:** 阶码全1, 尾数非0.

**16. ...求E、e、f、7、G、Z、5 的 7 位ASCII 码和奇校验后的8位编码。**
*(查ASCII表，奇校验使得8位中1的个数为奇数)*
*   E: 1000101; 奇校验后: **1**1000101
*   e: 1100101; 奇校验后: **0**1100101
*   f: 1100110; 奇校验后: **1**1100110
*   7: 0110111; 奇校验后: **0**0110111
*   G: 1000111; 奇校验后: **0**1000111
*   Z: 1011010; 奇校验后: **1**1011010
*   5: 0110101; 奇校验后: **1**0110101

**17. ...画出在大端机器和小端机器上变量 x、y 和 i 在内存中的存放位置。**
*   **x = -0.125:** BE000000H
*   **y = 7.5:** (111.1)<sub>2</sub> = (1.111)<sub>2</sub> * 2<sup>2</sup>. S=0, E-127=2 => E=129 (10000001B). f=1110...0. `0 10000001 11100000000000000000000` (40F00000H)
*   **i = 100:** 0064H
    *   **大端 (地址从低到高)：**
        *   x (100H): BE, 00, 00, 00
        *   y (108H): 40, F0, 00, 00
        *   i (112H): 00, 64
    *   **小端 (地址从低到高)：**
        *   x (100H): 00, 00, 00, BE
        *   y (108H): 00, 00, F0, 40
        *   i (112H): 64, 00

**18. ...32位数据线上传输的信息是 8F3CAB96H，则对应的 4 个校验位应为什么？...**
*(按字节计算奇校验位，使得每个字节+校验位中1的个数为奇数)*
*   8F (10001111): 1的个数为5 (奇)，校验位为0。
*   3C (00111100): 1的个数为4 (偶)，校验位为1。
*   AB (10101011): 1的个数为5 (奇)，校验位为0。
*   96 (10010110): 1的个数为4 (偶)，校验位为1。
*   **对应的4个校验位为：0, 1, 0, 1 (或 0101B)**
*   **接收到数据 873CAB96H，校验位 0101B：**
    *   87 (10000111): 1的个数为4 (偶)。接收校验位0。计算应为1。**87出错或校验位0出错**。
    *   3C (00111100): 1的个数为4 (偶)。接收校验位1。计算应为1。正确。
    *   AB (10101011): 1的个数为5 (奇)。接收校验位0。计算应为0。正确。
    *   96 (10010110): 1的个数为4 (偶)。接收校验位1。计算应为1。正确。
*   **说明：** 第一个字节的数据 (原为8FH，收到87H) 发生了错误，或者其对应的校验位发生了错误。根据奇偶校验无法确定是数据错还是校验位错，也无法定位具体哪一位。

**19. ...16位数据 ...0101000101000110B，...写出SEC码，并说明如何检测M5的错误。**
*(海明码计算复杂，这里只给思路)*
*   **思路：**
    1.  确定校验位数k：2<sup>k</sup> >= n+k+1 (n=16)。 k=5 (2<sup>5</sup>=32 >= 16+5+1=22)。
    2.  排列码字，校验位P1,P2,P4,P8,P16在2的幂次位置。
    3.  根据海明码分组规则，计算出5个校验位的值（例如采用偶校验）。
    4.  假设M5出错（该位取反）。
    5.  接收端重新计算5个校验位，得到P'。
    6.  计算故障字S = P'' ⊕ P' (P''是原始校验位)。
    7.  S的值（非0）即为出错位在码字中的位置。如果该位置对应M5，则检测正确。

**20. ...数据信息为 100011，G(x)=x<sup>3</sup>+1，校验码？接收数据100010，如何检测？**
*   **校验码：** `011` (计算见上一轮回答)
*   **发送码字：** `100011011`
*   **接收数据部分为 100010，校验码部分假设仍为 011：**
    *   接收到的码字为 `100010011`。
    *   用 G(x) = `1001` 去模 2 除 `100010011`。
    *   余数为 `011` (不为0)。
    *   **结论：** 检测到数据传输发生错误。

---

希望这些答案能帮助您！请务必自己动手计算和理解概念。