
计算机内部进行数据存储、运算和传送的部件位数有限，用定点数表示数值数据时，其表示范围很小，运算结果很容易溢出。此外，定点数也无法表示大量带有小数点的实数。因此，计算机中专门用**浮点数 (Floating-point Number)** 来表示实数。
### 2.3.1 浮点数的表示格式
1.  **实数 X 的浮点表示形式**：
    X = (-1)<sup>S</sup> × M × R<sup>E</sup>
    *   **S (Sign)**：数符，取值为 0 或 1，用来决定数 X 的符号。一般用 0 表示正，1 表示负。
    *   **M (Mantissa)**：尾数，一个二进制定点小数，表示数 X 的有效数字。
    *   **E (Exponent)**：阶码或指数，一个二进制定点整数，表示小数点的位置。
    *   **R (Radix/Base)**：基数，可以约定为 2、4、16 等。
2.  **确定一个实数的值**：在默认基数 R 下，只要确定数符 S、尾数 M 和阶码 E 即可。因此，浮点数格式只需规定 S、M 和 E 各自所用的位数、编码方式和所在位置。基数 R 和定点数（尾数和阶码）的小数点位置是默认的，不需要显式表示。
3.  **常用编码方式**：
    *   尾数 M：通常用**定点原码小数**表示。
    *   阶码 E：通常用**移码**表示。
4.  **早期浮点数格式的多样性**：在 IEEE 754 浮点数标准被广泛使用之前，不同计算机所用的浮点数表示格式各不相同。
    *   **例：IBM 370 的 32 位短浮点数格式**：
	    * ![[image-109.png]]
        *   **数符 S**：第 0 位。
        *   **阶码 E**：第 1-7 位 (7 位)，用移码表示 (偏置常数 = 64)。
        *   **尾数 M**：第 8-31 位 (24 位)，用十六进制原码小数表示。
        *   **基数 R**：16 (因此阶码变化 1 等于尾数移动 4 位)。
        *   **例 2.22**：将十进制数 65798 转换为 IBM 370 的 32 位短浮点数。
	        * ![[image-110.png]]
            *   (65798)<sub>10</sub> = (10106)<sub>16</sub> = (0.101060)<sub>16</sub> × 16<sup>5</sup>
            *   S = 0
            *   E = (64 + 5)<sub>10</sub> = (69)<sub>10</sub> = (1000101)<sub>2</sub>
            *   M = 0001 0000 0001 0000 0110 0000
            *   浮点数表示：`0 1000101 000100000001000001100000`
            *   十六进制表示：`45101060H`
    *   **例：另一种 32 位浮点数格式 (基数为 2)**：
        *   **数符 S**：第 0 位。
        *   **阶码 E**：第 1-8 位 (8 位)，用移码表示 (偏置常数 = 128)。
        *   **尾数 M**：第 9-31 位 (23 位)，用二进制原码小数表示。
        *   **规格化尾数形式**：±0.1bb...b (小数点后第一位为 "1"，该 "1" 不显式存储，从而使 23 个数位能表示 24 位尾数)。
        *   **例 2.23**：将十进制数 65798 转换为该 32 位浮点数。
	        * ![[image-111.png]]
            *   (65798)<sub>10</sub> = (10000000100000110)<sub>2</sub> = (0.10000000100000110)<sub>2</sub> × 2<sup>17</sup>
            *   S = 0
            *   E = (128 + 17)<sub>10</sub> = (145)<sub>10</sub> = (10010001)<sub>2</sub>
            *   M (省略首位1后) = 00000001000001100000000
            *   浮点数表示：`0 10010001 00000001000001100000000`
            *   十六进制表示：`48808300H`
        *   **表示范围 (规格化)**：
            *   正数最大值：0.11...1 × 2<sup>11...1</sup> = (1 - 2<sup>-24</sup>) × 2<sup>127</sup>
            *   正数最小值：0.10...0 × 2<sup>-11...1(移码表示的最小阶)</sup> = (1/2) × 2<sup>-128</sup> = 2<sup>-129</sup>
        *   **图 2.2 浮点数的表示范围**：数轴上存在上溢区和下溢区。
	        * ![[image-112.png]]
5.  **浮点数表示需注意的问题**：
    *   **1. 0 的表示问题**：
        *   当尾数为 0 时，无论阶码取何值，浮点数的值都为 0，称为**机器零**。机器零不唯一。
        *   **解决方法**：
            *   规定一个特定的 0/1 序列表示机器零 (通常阶码和尾数同时为 0)。
            *   将下溢区 (阶码过小) 的数近似为机器零。
        *   机器零有 +0 和 -0 之分。
    *   **2. 浮点数的密度问题**：
        *   对于 n 位二进制编码，最多只能表示 2<sup>n</sup> 个不同的数据。
        *   浮点数虽然表示范围扩大了，但并没有表示更多的数。实际上是这些数在数轴上向正负两个方向在更大的范围内散开，导致数轴上的分布变得**稀疏**。
        *   定点数分布是等距且紧密的，而浮点数分布是**不等距且稀疏的，越远离原点越稀疏**。
    *   **3. 表示精度和表示范围的权衡问题**：
        *   在浮点数总位数不变的情况下，阶码位数越多，则尾数位数（有效位数）越少。
        *   表示范围扩大了，精度就会变差（数变稀疏）。
        *   **提高范围和精度的方法**：使用更多的位数 (如单精度和双精度)。
        *   基数的大小也影响范围和精度：基数越大，范围越大，但精度越低（数变得更稀疏）。
### 2.3.2 浮点数的规格化
1.  **目的**：
    *   在浮点数运算过程中，尽可能多地保留有效数字的位数，使有效数字尽量占满尾数数位。
    *   使浮点数的表示具有唯一性。
2.  **规格化数的标志 (理论上)**：真值的尾数部分中最高位具有非 0 数字。
    *   若基数为 R，则规格化数的标志是：尾数部分真值的绝对值 **≥ 1/R**。
3.  **不同基数和编码下的规格化形式**：
    *   **基数为 2，尾数用原码表示**：规格化浮点数的形式为 ±0.1bb...b × 2<sup>E</sup> (小数点后第一位为 1)。
        *   **标志**：尾数的数值部分最高位为 1。
    *   **基数为 2，尾数用补码表示**：
        *   正数：尾数补码为 0.1bb...b。
        *   负数 (即 -0.1bb...b)：
            *   除 -0.10...0 (即 -1/2) 外，其补码必为 1.0bb...b。
            *   -1/2 的补码形式为 1.10...0，其符号位和最高数值位相同，不满足下面的标志。
        *   **标志 (简化判断)**：尾数的符号位和最高数值位**相异**。
        *   **特殊情况 (-1/2)**：其补码为 1.10...0。按规定它不是规格化数。但由于补码可以表示最小负数 -1 (形式为 1.00...0)，当遇到 -1/2 时，可将其尾数乘以 2 (变为 -1)，阶码减 1 (左规一次)，使其满足规格化形式。
4.  **规格化操作**：
    *   **右规 (Right Shift)**：当有效数位进到小数点前面时 (通常是运算结果绝对值大于等于1)，尾数每右移一位，阶码加 1，直到尾数变成规格化形式。右规时阶码可能会溢出。
    *   **左规 (Left Shift)**：当运算结果出现形如 ±0.0...0bb...b × 2<sup>E</sup> (尾数绝对值过小) 时，尾数每左移一位，阶码减 1，直到尾数变成规格化形式。左规时阶码可能会下溢。
### 2.3.3 IEEE 754 浮点数标准
1.  **背景**：20 世纪 80 年代初之前，浮点数表示格式不统一，导致数据传送和程序移植困难，运算结果不一致。IEEE 于 1985 年制定了 IEEE 754 浮点数标准。
2.  **主要起草人**：William Kahan (加州大学伯克利分校)，他也因此获得了 1987 年的图灵奖。
3.  **基本浮点格式 (图 2.3)**：
	 * ![[image-113.png]]
    *   **32 位单精度 (Single Precision)**：
        *   符号位 s：1 位
        *   阶码 e：8 位
        *   尾数 f：23 位
    *   **64 位双精度 (Double Precision)**：
        *   符号位 s：1 位
        *   阶码 e：11 位
        *   尾数 f：52 位
4.  **共同特性**：
    *   **基数 R**：隐含为 2。
    *   **尾数表示**：用原码表示。
    *   **隐藏位 (Hidden Bit)**：尾数的第一位（小数点前）总为 1 (对于规格化数)，因此在尾数 f 中省略该位 "1"，称为隐藏位。
        *   单精度：23 位尾数 f 实际表示 24 位有效数字。
        *   双精度：52 位尾数 f 实际表示 53 位有效数字。
        *   IEEE 754 规定隐藏位 1 的位置在小数点之前 (即尾数形式为 1.f)。
    *   **阶码表示**：用移码表示，但偏置常数 (bias) 不是通常 n 位移码所用的 2<sup>n-1</sup>，而是 **(2<sup>n-1</sup> - 1)**。
        *   单精度 (8 位阶码)：偏置常数 = 2<sup>8-1</sup> - 1 = 128 - 1 = 127。
        *   双精度 (11 位阶码)：偏置常数 = 2<sup>11-1</sup> - 1 = 1024 - 1 = 1023。
    *   **与传统移码的关系**：由于尾数包含一个小数点前的隐藏位 "1"，如果将尾数转换为纯小数形式 (0.1f...)，则阶码需要加 1，这使得最终计算结果与采用传统偏置常数 (如单精度用 128) 的情况相同。
    *   **采用 (2<sup>n-1</sup> - 1) 作为偏置常数的优点**：
        *   尾数可表示的位数多一位，精度更高。
        *   阶码的可表示范围更大 (例如单精度用 127 时，最大阶码真值为 255-127=128；用 128 时，最大为 255-128=127)。
5.  **特殊值的解释 (表 2.3)**：IEEE 754 对一些特殊的位序列（如阶码全 0 或全 1）有特别的解释。
	* ![[image-114.png]]
    *   **1. 阶码 e 全 0，尾数 f 全 0：±0 (零)**
        *   有两种表示：+0 和 -0，符号取决于符号位 s。
        *   通常 +0 和 -0 是等效的。
        *   有些计算机会将下溢区（阶码过小）的运算结果近似为 0。
    *   **2. 阶码 e 全 0，尾数 f 非 0：非规格化数 (Denormalized Number)**
        *   **特点**：阶码部分的编码为全 0，尾数 f 高位有一个或几个连续的 0，但不全为 0。
        *   **隐藏位**：为 0 (而不是规格化数的 1)。
        *   **阶码真值**：
            *   单精度：-126
            *   双精度：-1022
        *   **数值**：(-1)<sup>s</sup> × 0.f × 2<sup>-126</sup> (单精度) 或 (-1)<sup>s</sup> × 0.f × 2<sup>-1022</sup> (双精度)。
        *   **作用**：处理阶码下溢，使得出现比最小规格化数还小的数时程序也能继续进行，实现“逐级下溢 (Gradual Underflow)”。
        *   **图 2.4 非规格化数对表示范围的影响**：
	        * ![[image-115.png]]
            *   在 0 和最小规格化数之间增加了一段由非规格化数填充的区域。
            *   这些非规格化数的间距与最小规格化数区间的间距相同。
            *   非规格化数的阶码与最小规格化数的阶码相同，但尾数隐含位为 0。
    *   **3. 阶码 e 全 1，尾数 f 全 0：±∞ (无穷大)**
        *   引入无穷大数使得在计算出现异常（如除以零）的情况下程序能继续进行，并为程序提供错误检测功能。
        *   +∞ 大于所有有限数，-∞ 小于所有有限数。
        *   **运算**：
            *   产生 NaN：+∞ + (-∞), +∞ / +∞ 等。
            *   产生明确结果：5 + (+∞) = +∞, (-∞) - (+∞) = -∞ 等。
    *   **4. 阶码 e 全 1，尾数 f 非 0：NaN (Not a Number, 非数)**
        *   表示一个没有定义的数。
        *   **种类**：
            *   **不发信号 NaN (Quiet NaN, QNaN)**：尾数 f 最高有效位为 1。当运算结果产生 QNaN 时，不发出异常信号。
            *   **发信号 NaN (Signaling NaN, SNaN)**：尾数 f 最高有效位为 0。当运算结果产生 SNaN 时，发出异常操作通知。
        *   **作用**：
            *   检测非初始化值的使用。
            *   使计算出现异常时程序能继续进行，并将测试或判断延迟。
            *   尾数 f 的其余位可用来指定具体的异常条件。
        *   **产生 NaN 的运算**：0 × ∞, 0/0, ∞/∞, x MOD 0, ∞ MOD y, √x (当 x < 0) 等。
    *   **5. 阶码 e 非全 0 且非全 1：规格化非 0 数**
        *   这是一个正常的规格化浮点数。
        *   **阶码真值范围**：
            *   单精度 (e: 1~254)：真值 -126 ~ +127。
            *   双精度 (e: 1~2046)：真值 -1022 ~ +1023。
        *   **数值计算公式**：(-1)<sup>s</sup> × 1.f × 2<sup>e - bias</sup>
        *   **例 2.24**：将十进制数 -0.75 转换为 IEEE 754 单精度浮点数。
            *   (-0.75)<sub>10</sub> = (-0.11)<sub>2</sub> = (-1.1)<sub>2</sub> × 2<sup>-1</sup>
            *   s = 1
            *   尾数的小数部分 f = (100...0)<sub>2</sub> (即 0.1 对应的部分，因为整数部分的1是隐藏位)
            *   阶码真值 = -1，所以 e - 127 = -1  => e = 126 = (01111110)<sub>2</sub>
            *   浮点数表示：`1 01111110 10000000000000000000000`
            *   十六进制表示：`BF400000H`
        *   **例 2.25**：求 IEEE 754 单精度浮点数 `C0A00000H` 的值。
            *   二进制展开：`1 10000001 01000000000000000000000`
            *   s = 1 (负数)
            *   e = (10000001)<sub>2</sub> = (129)<sub>10</sub>
            *   f = (0100...0)<sub>2</sub>
            *   值 = (-1)<sup>1</sup> × 1.01<sub>2</sub> × 2<sup>129-127</sup> = - (1 + 1/4) × 2<sup>2</sup> = -1.25 × 4 = -5.0
6.  **IEEE 754 浮点数格式的特征参数 (表 2.5)**：
      * ![[image-116.png]]
    *   **单精度**：
        *   阶码个数 (除去全0和全1)：254
        *   尾数个数 (由 f 决定)：2<sup>23</sup>
        *   值的个数 (规格化数)：254 × 2<sup>23</sup> ≈ 1.98 × 2<sup>31</sup>
        *   数的量级范围：约 10<sup>-38</sup> ~ 10<sup>+38</sup>
    *   **双精度**：
        *   阶码个数：2046
        *   尾数个数：2<sup>52</sup>
        *   值的个数：2046 × 2<sup>52</sup> ≈ 1.99 × 2<sup>63</sup>
        *   数的量级范围：约 10<sup>-308</sup> ~ 10<sup>+308</sup>
7.  **扩展精度格式**：IEEE 754 还规定了单精度扩展和双精度扩展两种格式的最小长度和最小精度，但未规定具体格式，由处理器厂商选择。
    *   **Intel x86 FPU**：采用 80 位双精度扩展格式 (1 位符号，15 位阶码，1 位显式首位有效位 j，63 位尾数 f)。**无隐藏位**，有效位数共 64 位。
    *   **Intel 安腾 FPU**：采用 82 位扩展精度。
    *   **SPARC 和 PowerPC**：采用 128 位扩展双精度浮点数格式 (1 位符号，15 位阶码，112 位尾数 f)。**采用隐藏位**，有效位数 113 位。
###  2.3.4 C 语言中的浮点数类型
1.  **C 语言浮点数类型**：
    *   `float`：对应 IEEE 754 单精度浮点数格式 (十进制有效数字约 7 位)。
    *   `double`：对应 IEEE 754 双精度浮点数格式 (十进制有效数字约 17 位)。
    *   `long double`：对应扩展双精度，其长度和格式随编译器和处理器类型不同而不同。
        *   Microsoft Visual C++ 6.0 及以下：`long double` 与 `double` 相同 (64 位)。
        *   IA-32 上使用 gcc：`long double` 采用 Intel x86 FPU 的 80 位扩展格式。
        *   SPARC 和 PowerPC 上使用 gcc：`long double` 采用 128 位扩展格式。
2.  **强制类型转换结果 (假定 int 为 32 位)**：
    *   **(1) int 转 float**：不会发生溢出，但可能有数据被舍入 (因为 float 尾数位数有限)。
    *   **(2) int 或 float 转 double**：能保留精确值 (因为 double 有效位数更多)。
    *   **(3) double 转 float**：
        *   可能发生溢出 (因为 float 表示范围更小)。
        *   由于有效位数变少，可能被舍入。
    *   **(4) float 或 double 转 int**：
        *   小数部分会被截断 (向 0 方向)。例如 1.9999 转为 1，-1.9999 转为 -1。
        *   可能发生溢出 (因为 int 表示范围更小)。
        *   **严重后果**：将大的浮点数转换为整数可能导致程序错误。
            *   **Ariana 5 火箭失事案例 (1996年)**：64 位浮点数转换为 16 位带符号整数时发生溢出，导致导航系统错误。
3.  **编程注意事项**：不同数据类型之间转换时，往往隐藏着一些不容易被察觉的错误，需要非常小心。
4.  **例 2.26 C 语言关系表达式判断 (32位机)**：
    *   A. `i == (int)(float)i`：**不一定**。int 精度可能比 float 高 (例如对于超出 float 尾数表示范围的大整数)，`i` 转 `float` 可能舍入，再转回 `int` 可能与原 `i` 不同。
    *   B. `f == (float)(int)f`：**不一定**。`float` 有小数部分，`f` 转 `int` 会截断小数，再转回 `float` 小数部分丢失。
    *   C. `i == (int)(double)i`：**是**。`double` 比 `int` 有更大的精度和范围，`i` 转 `double` 再转回 `int` 数值不变。
    *   D. `f == (float)(double)f`：**是**。`double` 比 `float` 有更大的精度和范围，`f` 转 `double` 再转回 `float` 数值不变 (假设 f 在 float 表示范围内)。
    *   E. `d == (float)d`：**不一定**。`double` 比 `float` 有更大的精度和范围，`d` 转 `float` 可能舍入或溢出。
    *   F. `f == -(-f)`：**是** (不考虑 NaN 和 ±∞ 的特殊情况)。浮点数取负只是数符取反。
    *   G. `(d+f)-d == f`：**不一定**。例如 d 是一个非常大的数，f 是一个较小的数。在计算 `d+f` 时，f 可能因为需要向 d 对阶而被舍入为 0，导致 `(d+f)` 仍然等于 `d`，于是 `d-d = 0`，而 `0 != f` (除非 f 本身就是 0)。
