
整数的小数点隐含在数的最右边，因此无须显式表示小数点，故整数也被称为**定点数**。计算机中处理的整数可以用**二进制**直接表示，也可以用**二进制编码的十进制数（BCD码）**表示。二进制整数分为**无符号整数 (unsigned integer)** 和**带符号整数 (signed integer)** 两种。
### 2.2.1 无符号整数的表示
1.  **定义**：当一个编码的所有二进制位都用来表示数值而没有符号位时，该编码表示的就是无符号整数。
2.  **特性**：
    *   默认数的符号为正，即无符号整数是正整数或非负整数。
    *   常用于全部是正数运算且不出现负值结果的场合，例如地址运算或表示指针。
    *   通常简称为无符号数。
3.  **表示范围**：由于省略了一位符号位，在字长相同的情况下，无符号整数能表示的最大数比带符号整数所能表示的大。
    *   对于 n 位无符号整数，其可表示的数的范围是 **0 ~ (2<sup>n</sup> - 1)**。
    *   **例如**：8 位无符号整数的形式为 00000000B ~ 11111111B，对应的数值范围是 0 ~ (2<sup>8</sup> - 1)，即 0 ~ 255。而 8 位带符号整数的最大数通常是 127。
### 2.2.2 带符号整数的表示
1.  **定义**：带符号整数，也称为有符号整数，必须用一个二进制位来表示符号。
2.  **编码方式**：前面介绍的各种二进制定点数编码表示（包括原码、补码、反码和移码）都可以用来表示带符号整数。
3.  **补码的优势**：现代计算机中带符号整数**都用补码表示**，因为补码具有以下突出优点：
    *   **数 0 的表示唯一**：与原码和反码不同，补码中 +0 和 -0 的表示是相同的。
    *   **减法可用加法实现**：补码运算系统是一种模运算系统，可以用加法实现减法运算，且符号位可以和数值位一起参与运算，简化了硬件设计。
    *   **多表示一个最小负数**：比原码和反码能多表示一个最小负数。
    *   **符号位与真值符号对应清晰**：符号位为 1 表示负数，符号位为 0 表示正数（与移码不同）。
    *   **无需循环移位调整**：与反码相比，运算结果不需要通过循环移位来调整。
4.  **表示范围**：对于 n 位带符号整数（通常指补码表示），其可表示的数值范围是 **-2<sup>n-1</sup> ~ (2<sup>n-1</sup> - 1)**。
    *   **例如**：8 位带符号整数的表示范围为 -128 ~ +127。
###  2.2.3 C 语言中的整数类型
1.  **C 语言支持的整数类型**：
    *   **无符号整数**：对应 `unsigned short`、`unsigned int` (或 `unsigned`)、`unsigned long` 等类型。
        *   常在数的后面加一个 "u" 或 "U" 来表示，例如 `12345U`，`0x2B3Cu`。
    *   **带符号整数**：对应 `short`、`int`、`long` 等类型。
2.  **类型转换**：C 语言中允许无符号整数和带符号整数之间的转换。
    *   **转换规则**：转换后数的真值是将原二进制机器数按转换后的数据类型重新解释得到。
    *   **示例代码分析**：
        ```c
        int x = -1;
        unsigned int u = 2147483648; // 2^31
        printf("x=%u=%d\n", x, x);
        printf("u=%u=%d\n", u, u);
        ```
        在 32 位机器上运行结果：
        ```
        x=4294967295=-1
        u=2147483648=-2147483648
        ```
        *   **x 的输出解释**：
            *   `-1` 的 32 位补码整数表示为全 1 ("11...1")。
            *   当作为无符号数解释 (格式符 `%u`) 时，其值为 2<sup>32</sup> - 1 = 4294967295。
        *   **u 的输出解释**：
            *   `2147483648` (即 2<sup>31</sup>) 的无符号数表示为 "100...0" (最高位为1，其余为0)。
            *   当作为带符号整数解释 (格式符 `%d`) 时，其值为最小负数 -2<sup>32-1</sup> = -2<sup>31</sup> = -2147483648 (参考前面补码表示范围和特殊值-2<sup>n-1</sup>的补码形式)。
3.  **混合运算时的隐式转换**：在 C 语言中，如果一个运算同时有无符号数和带符号整数参加，C 编译器会**隐含地将带符号整数强制类型转换为无符号数**，这可能会带来一些意想不到的结果。
4.  **关系表达式示例 (表 2.2)**：
	* ![[image-107.png]]
    *   **核心问题**：同样的 0/1 序列，用不同类型进行解释时的值不同。直觉上的取值与计算机中实际取值有差异，导致某些实际结果与直觉不符。
    *   **示例分析**：`-2147483648 == 2147483648U`
        *   左边是带符号整数，其补码表示为 `100...0B`。
        *   右边是无符号整数 `2147483648U` (即 2<sup>31</sup>)，其二进制表示也是 `100...0B`。
        *   在进行比较时，左边的带符号整数 `-2147483648` 会被转换为无符号数。其机器码 `100...0B` 作为无符号数解释，值为 2<sup>31</sup>。
        *   因此，比较变为 `2147483648U == 2147483648U`，结果为真 (1)。
    *   **结论**：当带符号整数被解释为无符号数时，可能会发生意想不到的结果，需要特别注意。
