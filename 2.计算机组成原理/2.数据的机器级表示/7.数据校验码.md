好的，这是关于“2.7 数据校验码”部分的学习笔记：

## 2.7 数据校验码

数据在计算机内部进行计算、存取和传送过程中，由于元器件故障或噪音干扰等原因会出现差错。为了减少和避免这些错误，需要采取相应的数据检错和校正措施。

**基本思想：“冗余校验”**
*   除原数据信息外，还增加若干位编码，这些新增的代码称为**校验位 (Check Bits)**。
*   **处理过程 (图 2.6)**：
	* ![[image-123.png]]
    1.  **发送/存储端**：对原始数据 M 进行某种运算 F，产生校验位 P = F(M)。数据 M 和校验位 P 一起被存储或传送。
    2.  **接收/读取端**：
        *   读取数据 M' 和原校验位 P'' (P'' 应该是原始的 P)。
        *   对读取的数据 M' 再次进行同样的运算 F，产生新的校验位 P' = F(M')。
        *   比较 P' 和 P''。
    3.  **结果判断**：
        *   若 P' = P'' (无差错)：数据 M' 直接传送/使用。
        *   若 P' ≠ P'' (检测到差错)：
            *   **可纠错**：数据 M' 和比较结果一起送入纠错器，产生正确的的数据。
            *   **不可纠错/仅检错**：报告出错情况。
**码距 (Hamming Distance)**
*   **定义**：两个码字逐位比较，具有不同代码的位的个数。
*   **码制中的码距**：一种码制中任意两个合法码字之间的最小码距。
*   **作用**：衡量码制的检错和纠错能力。
*   **与检错/纠错能力的关系**：
    *   **检错**：要能检测出 e 位错误，码距 d 必须 ≥ e + 1。
    *   **纠错**：要能纠正 e 位错误，码距 d 必须 ≥ 2e + 1。
*   **示例**：
    *   8421 BCD 码：码距 d = 1 (例如 0010 和 0011 码距为 1)。无检错/纠错能力。
    *   4 位二进制表示 8 个状态 (0000, 0011, ..., 1111)，其余为非法码。码距 d = 2。能检测 1 位错误。
*   **一般关系 (当码距 d ≤ 4 时)**：
    *   若 d 为奇数：能发现 d-1 位错，或能纠正 (d-1)/2 位错。
    *   若 d 为偶数：能发现 d/2 位错，并能纠正 (d/2 - 1) 位错。
### 2.7.1 奇偶校验码 (Parity Check Code)

1.  **基本思想**：在原数据信息中增加一位校验位，使得编码中 "1" 的个数为奇数（奇校验）或偶数（偶校验）。
2.  **实现原理**：
    *   **发送端**：根据数据位中 "1" 的个数和所选的校验方式（奇/偶）计算出校验位 P。
        *   **奇校验**：若数据位中 "1" 的个数为偶数，则 P=1；若为奇数，则 P=0。使得 (数据位 + 校验位) 中 "1" 的总数为奇数。
            *   公式：P = b<sub>n-1</sub> ⊕ b<sub>n-2</sub> ⊕ ... ⊕ b<sub>1</sub> ⊕ b<sub>0</sub> ⊕ 1 (⊕ 表示异或)
        *   **偶校验**：若数据位中 "1" 的个数为偶数，则 P=0；若为奇数，则 P=1。使得 (数据位 + 校验位) 中 "1" 的总数为偶数。
            *   公式：P = b<sub>n-1</sub> ⊕ b<sub>n-2</sub> ⊕ ... ⊕ b<sub>1</sub> ⊕ b<sub>0</sub>
    *   **接收端**：对接收到的 (数据位 + 校验位) 重新计算校验位 P'。
    *   **检错**：计算最终校验位 P* = P' ⊕ P'' (P'' 是接收到的原校验位)。
        *   若 P* = 1 (奇校验出错或偶校验出错)，则表示有奇数位错误。
        *   若 P* = 0，则表示正确或有偶数位错误。
3.  **码距**：d = 2。
4.  **能力**：
    *   只能检测出**奇数位**的错误。
    *   不能检测出**偶数位**的错误。
    *   不能确定错误的位置，**不具有纠错能力**。
5.  **应用**：开销小，常用于存储器读写检查或按字节传输过程中的数据校验。因为在一个字节长度的代码中，一位出错的概率相对较大，两位以上出错的概率则很小。

### 2.7.2 海明校验码 (Hamming Code)

1.  **背景**：奇偶校验码检错能力弱且无纠错能力。海明码是一种多重奇偶校验码。
2.  **基本思想**：将数据按某种规律分成若干组，对每组进行相应的奇偶检测，以提供多位校验信息，从而可以定位错误并纠正。
3.  **校验位的位数确定 (k)**：
    *   设数据位为 n 位，校验位为 k 位，则总码长为 n+k 位。
    *   k 位校验位产生的故障字 (syndrome word) S 有 2<sup>k</sup> 种状态。
    *   每种状态对应一种出错情况：无错、n 位数据中某一位出错、k 位校验码中某一位出错。
    *   因此，需要满足关系式：**2<sup>k</sup> ≥ n + k + 1**  或者 **2<sup>k</sup> - 1 ≥ n + k**。
    *   **表 2.11** 给出了不同数据位数对应的校验位数。
    * ![[image-124.png]]
4.  **分组方式的确定与故障字的解释**：
    *   **目标**：通过故障字的值能唯一确定出错位的位置。
    *   **规则**：
        *   **(1) 故障字全 0**：表示没有发生错误。
        *   **(2) 故障字中仅有一位为 1**：表示对应的校验位出错，数据位无需纠正。
        *   **(3) 故障字中有多位为 1**：表示某个数据位出错，出错位置由故障字的数值来确定。
    *   **校验位的位置**：为了满足规则 (2)，校验位 P<sub>i</sub> 应位于码字的第 2<sup>i-1</sup> 位 (例如 P<sub>1</sub> 在第 1 位，P<sub>2</sub> 在第 2 位，P<sub>3</sub> 在第 4 位，P<sub>4</sub> 在第 8 位...)。
    *   **数据位的分组**：根据规则 (3)，某个数据位出错会影响哪些故障字的位，就意味着该数据位被哪些校验位所校验。
        *   **示例 (8 位数据 M<sub>8</sub>...M<sub>1</sub>，4 位校验位 P<sub>4</sub>P<sub>3</sub>P<sub>2</sub>P<sub>1</sub>)**：
            *   码字排列 (从高到低，共 12 位)：M<sub>8</sub>M<sub>7</sub>M<sub>6</sub>M<sub>5</sub>**P<sub>4</sub> M<sub>4</sub>M<sub>3</sub>M<sub>2</sub>P<sub>3</sub>M<sub>1</sub>P<sub>2</sub>P<sub>1</sub>
            *   **表 2.12 故障字和出错情况的对应关系**：
	            * ![[image-125.png]]
                *   故障字 S = S<sub>4</sub>S<sub>3</sub>S<sub>2</sub>S<sub>1</sub>。
                *   S<sub>1</sub>=1 表示 P<sub>1</sub> 所在组奇偶性出错。
                *   数据位 M<sub>x</sub> 的出错会使其对应的故障字 S 的某些位为1。例如 M<sub>1</sub> 出错 (对应故障字 0011)，则 M<sub>1</sub> 应同时被 P<sub>1</sub> 和 P<sub>2</sub> 校验。
5.  **校验位的生成和检错、纠错**：
    *   **校验位生成 (偶校验为例)**：
        *   P<sub>1</sub> = M<sub>1</sub> ⊕ M<sub>2</sub> ⊕ M<sub>4</sub> ⊕ M<sub>5</sub> ⊕ M<sub>7</sub>
        *   P<sub>2</sub> = M<sub>1</sub> ⊕ M<sub>3</sub> ⊕ M<sub>4</sub> ⊕ M<sub>6</sub> ⊕ M<sub>7</sub>
        *   P<sub>3</sub> = M<sub>2</sub> ⊕ M<sub>3</sub> ⊕ M<sub>4</sub> ⊕ M<sub>8</sub>
        *   P<sub>4</sub> = M<sub>5</sub> ⊕ M<sub>6</sub> ⊕ M<sub>7</sub> ⊕ M<sub>8</sub>
    *   **检错与纠错**：
        *   接收端根据接收到的数据 M' 重新计算校验位 P'。
        *   计算故障字 S = P'' ⊕ P' (P'' 是接收到的原校验位)。
        *   根据 S 的值判断错误情况并纠错 (参考上述规则)。
        *   **例 2.28**：M=01101010 (M<sub>8</sub>...M<sub>1</sub>)
            *   计算得 P=0011 (P<sub>4</sub>P<sub>3</sub>P<sub>2</sub>P<sub>1</sub>)。
            *   **(1) M'=01101010, P''=0011 (无错)**：S = 0011 ⊕ 0011 = 0000。
            *   **(2) M'=01111010 (M<sub>5</sub> 错), P''=0011**：P'=1010。S = 0011 ⊕ 1010 = 1001 (二进制9)。对应码字第9位 (M<sub>5</sub>) 出错，纠正 M<sub>5</sub>。
            *   **(3) M'=01101010, P''=1011 (P<sub>4</sub> 错)**：P'=0011。S = 1011 ⊕ 0011 = 1000 (二进制8)。对应码字第8位 (P<sub>4</sub>) 出错，无需纠正数据。
6.  **单纠错码 (SEC - Single Error Correcting)**：
    *   上述海明码的码距 d = 3。
    *   能纠正一位错误。
7.  **单纠错双检错码 (SEC-DED - Single Error Correcting and Double Error Detecting)**：
    *   若要同时具有发现两位错和纠正一位错的能力，码距需扩大到 d = 4。
    *   **方法**：在 SEC 码的基础上增加一位总的奇偶校验位 P<sub>5</sub> (对整个 n+k 位码字进行奇偶校验)。
    *   **排列**：P<sub>5</sub> 通常放在码字的最前面。
    *   **分组**：数据中的每一位都必须参与至少 3 个校验位的生成。
    *   **故障字**：增加 S<sub>5</sub>。
    *   **检错/纠错规则**：
        *   (1) S<sub>5</sub>S<sub>4</sub>S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> = 00000：无错。
        *   (2) S<sub>5</sub>S<sub>4</sub>S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> 中仅一位为 1 (且 S<sub>5</sub>=1，其他 S<sub>i</sub>=0)：校验位 P<sub>i</sub> 错，或数据和校验位中有 3 位同时错 (可能性小)。
        *   (3) S<sub>5</sub>S<sub>4</sub>S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> 中有两位不为 0 (且 S<sub>5</sub>=0)：数据和校验位中有两位同时错，只能检错。
        *   (4) S<sub>5</sub>S<sub>4</sub>S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> 中有三位不为 0 (且 S<sub>5</sub>=1)：一个数据位错，或三个校验位同时错 (可能性小)。出错位置由 S<sub>4</sub>S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> 确定。
        *   (5) S<sub>5</sub>S<sub>4</sub>S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> 中有四位或五位不为 0：出错严重，系统硬件故障。
### 2.7.3 循环冗余校验码 (CRC - Cyclic Redundancy Check)

1.  **特点**：具有较强检错、纠错能力的校验码，常用于外存储器的数据校验和计算机通信。
2.  **与奇偶校验的区别**：奇偶校验通常按字符增加校验位，开销大。CRC 对较长数据块进行校验，效率高。
3.  **基本原理**：通过某种数学运算（多项式除法）来建立数据和校验位之间的约定关系。
4.  **检错方法 (图 2.7)**：
	  ![[image-126.png]]
    *   设要校验的数据信息为 M(x) (n 位二进制数，看作多项式)。
    *   将 M(x) 左移 k 位 (即 M(x) × x<sup>k</sup>)。
    *   用一个约定的**生成多项式 G(x)** (k+1 位二进制数) 去除 M(x) × x<sup>k</sup>。
    *   得到的 **k 位余数**就是校验位。
    *   这些校验位拼接到 M(x) 的 n 位数据后面，形成一个 (n+k) 位的 CRC 码。
    *   **特性**：一个合法的 CRC 码一定能被生成多项式 G(x) 整除。
    *   **接收端**：将接收到的 (数据 + 校验位) 用同样的 G(x) 相除。
        *   若余数为 0：表明没有发生错误。
        *   若余数不为 0：表明某些数据位发生了错误。
5.  **校验位的生成 (图 2.8a)**：
	   ![[image-127.png]]
    *   采用 **“模 2 运算”** 的多项式除法（异或运算，不考虑进位和借位）。
    *   上商原则：当部分余数首位是 1 时上商为 1，否则上商为 0。
    *   **示例**：数据 M(x) = 100011 (n=6)，生成多项式 G(x) = x<sup>3</sup>+1 = 1001 (k+1=4, k=3)。
        *   计算 x<sup>3</sup>M(x) ÷ G(x) = (100011000) ÷ (1001)。
        *   得到的余数为 111 (校验位)。
        *   CRC 码为 100011 111。
6.  **CRC 码的验证 (图 2.8b, 2.8c)**：
    *   若接收到的 CRC 码为 100011111 (无错)，除以 G(x)=1001，余数为 000。
    *   若接收到的 CRC 码为 101011111 (一位出错)，除以 G(x)=1001，余数不为 0 (例如 001)。
7.  **CRC 码的纠错**：
    *   **原理**：不同的出错位置对应不同的余数。
    *   **循环特性**：如果对不为 0 的余数补 0 后继续用 G(x) 进行模 2 除，各次余数会按特定顺序循环。
    *   **应用**：利用这种循环特性可以方便地对出错码字进行纠错，硬件开销小。在大批量数据传输校验中能有效降低硬件成本。
    *   **表 2.13** 展示了 (7,4) 循环码中出错位置与余数的关系。
	    * ![[image-128.png]]
8.  **生成多项式的选取**：
    *   不是任何一个多项式都能作为生成多项式。
    *   **条件** (保证检错和纠错能力)：
        *   (1) 任何一位发生错误时，都应使余数不为 0。
        *   (2) 不同位发生错误时，余数应该不同 (用于纠错)。
        *   (3) 对余数作模 2 除时，应使余数循环。
    *   **数学方法**：将 (x<sup>n+k</sup> - 1) 按模 2 运算分解为若干质因子，根据所要求的码距，选取其中的因式或若干因式的乘积作为生成多项式。
    *   **常用生成多项式**：
        *   CRC-CCITT: G(x) = x<sup>16</sup> + x<sup>12</sup> + x<sup>5</sup> + 1
        *   CRC-16: G(x) = x<sup>16</sup> + x<sup>15</sup> + x<sup>2</sup> + 1
        *   CRC-12: G(x) = x<sup>12</sup> + x<sup>11</sup> + x<sup>3</sup> + x<sup>2</sup> + x + 1
        *   CRC-32: G(x) = x<sup>32</sup> + x<sup>26</sup> + x<sup>23</sup> + x<sup>22</sup> + x<sup>16</sup> + x<sup>12</sup> + x<sup>11</sup> + x<sup>10</sup> + x<sup>8</sup> + x<sup>7</sup> + x<sup>5</sup> + x<sup>4</sup> + x<sup>2</sup> + x + 1
9.  **网络通信中的应用**：通常数据位数 n 相当大 (几千位构成一帧数据)。CRC 主要用于**检测错误**，发现错误则通知发送方要求重发，一般不用于 CRC 来纠错（因为纠错逻辑复杂，且重发成本相对较低）。

