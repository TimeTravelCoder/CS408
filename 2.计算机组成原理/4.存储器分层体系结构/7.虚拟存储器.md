目前计算机主存主要由DRAM芯片构成，由于技术和成本等原因，主存的存储容量受到限制，并且各种不同计算机所配置的物理内存容量多半也不相同。程序设计时人们显然不希望受到特定计算机的物理内存大小的制约。此外，现代操作系统都支持多道程序运行，如何让多个程序有效而安全地共享主存也是需要解决的问题。虚拟存储技术就是为了解决这些矛盾而提出的。
*   **核心思想**：程序员在一个不受物理内存空间限制并且比物理内存空间大得多的虚拟的逻辑地址空间中编写程序。程序执行过程中，把当前执行到的一部分程序和相应的数据调入主存，其他暂不用的部分暂时存放在磁盘上。这种借用外存为程序提供的很大的虚拟存储空间称为虚拟存储器。
*   **地址转换**：指令执行时，通过硬件将指令中的逻辑地址（也称虚拟地址或虚地址）转化为主存的物理地址（也称主存地址或实地址）。
*   **过程中的检查与处理**：
    *   **信息缺失（缺页/缺段）**：若所需信息不在主存，则由操作系统进行主存和磁盘之间的信息交换。
    *   **地址越界或访问越权**：由操作系统进行存储访问的异常处理。
*   **优点**：
    *   解决了编程空间受限的问题。
    *   解决了多道程序共享主存带来的安全等问题。
*   **实现**：虚拟存储器机制由硬件与操作系统共同协作实现。涉及概念包括进程、进程上下文切换、存储器管理、虚拟地址空间、缺页处理等。
**\*4.7.1 进程与进程的上下文切换**
    ![[image-186.png|168x213]]
*   **进程 (Process)**：操作系统对处理器中运行的程序的一种抽象。是操作系统进行资源分配和调度的基本单位。
*   **错觉**：用户程序通过操作系统中进程、虚拟存储器和文件等机制使用硬件资源，使得每个用户程序在运行时产生错觉，以为所有系统资源都被自己独占使用，且处理器始终执行本程序的一条条指令。
*   **上下文切换 (Context Switching)**：现代多任务操作系统中，通常可同时运行很多进程，但每个处理器在某一时刻只能执行一个进程的指令。操作系统通过处理器调度让处理器交替执行多个进程中的指令，实现不同进程中指令交替执行的机制称为“上下文切换”。
*   **进程的上下文 (Context)**：
    *   **用户级上下文**：由用户的程序块、数据块和堆栈等组成的用户区地址空间。
    *   **系统级上下文**：由进程标识信息、现场信息、控制信息和系统内核栈等组成的系统区地址空间。
    *   **寄存器上下文**：处理器中各个寄存器的内容。
*   **切换过程**：操作系统把换下进程的寄存器上下文保存到系统级上下文的现场信息位置。用户级上下文地址空间和系统级上下文地址空间一起构成了一个进程的整个存储器映像 (图4.37)。
*   **示例：hello.c程序的执行流程**：从高级语言源程序，经过预处理、编译成汇编、汇编成可重定位目标文件，再与库函数目标文件链接，生成最终的可执行目标文件hello。在UNIX系统上启动hello程序，shell进程会进行上下文切换，创建并执行hello进程，hello进程结束后再切换回shell进程 (图4.38)。
	* ![[image-187.png]]
*   **性能测量影响**：在一个进程的整个生命周期中，可能会有其他不同的进程在处理器中交替运行，所以对于每个进程的运行时间很难准确、重复测量。
**\*4.7.2 存储器管理**
*   **早期单道程序**：主存中仅包含操作系统和正在执行的一个用户程序，存储管理简单。
*   **现代多道程序**：主存中包含操作系统和若干个用户程序。需要对主存进行合理分配，尽可能让更多进程进入主存，以最大限度利用处理器资源。
*   **存储器管理 (Memory Management)**：在多道程序系统中，主存储器的“用户”区需进一步划分给多个进程。划分的任务由OS动态执行。
*   **交换 (Exchange) 技术**：早期使系统中尽量多地调入用户程序的技术。当主存中没有处于就绪状态的进程时，OS将一些进程调出写回到磁盘，然后再调入其他进程来执行。
*   **分区 (Partitioning) 和 分页 (Paging)** 是交换技术的两种实现方式。
1.  **分区方式**
    *   **区域划分**：主存分为系统区（固定地址，存放操作系统）和用户区（存放所有用户程序）。
    *   **用户区分配方式**：
        *   **简单固定分区 (Fixed-size Partition)**：用户区划分为若干长度不等的固定分区。进程调入时，分配一个能容纳它的最小分区。易产生分区大小与进程需求不匹配，浪费主存（**内碎片**）。 (图4.39a)
	        * ![[image-189.png]]
        *   **动态可变长分区 (Variable-length Partition)**：分配的分区大小与进程所需大小一样。初始时主存除OS外全为空闲。进程调入时，从空闲区划出所需大小。可能在存储器中产生许多不连续的小空闲块（**外碎片**），难以利用。 (图4.39b)
	        * ![[image-190.png]]
    *   **碎片问题**：固定分区产生内碎片，可变长分区产生外碎片。
    *   **碎片合并**：通过移动进程将“碎片”合并可提高主存利用率，但会带来处理器额外开销和重定位硬件开销。
    *   **现代应用**：分区方式不是解决多道程序运行的有效办法，现代多任务操作系统已较少使用。

2.  **分页方式**
    *   **基本思想**：
        *   主存分成固定长且比较小的存储块，称为**页框 (Page Frame)**。
        *   每个进程也被划分成固定长的程序块，称为**页 (Page)**。
        *   程序块被装到可用的存储块中，无须用连续页框来存放一个进程。
    *   **对程序员透明**：程序员不需要知道程序运行时具体会装到哪些页框。
    *   **地址转换**：通过**页表 (Page Table)** 建立页和页框之间的映射关系，实现虚拟地址到物理地址的转换。
    *   **早期分页方式**：将一个进程的所有页面都调入主存。对主存利用率比分区好，浪费空间最多是最后一页的一部分。但未利用程序访问的局部性。
    *   **请求分页 (Demand Paging)**：现代操作系统采用的分页式虚拟存储管理方式。只将当前需要的页面装入主存页框中，不需要的页面则存放在外存中。这是现代计算机采用的“虚拟存储器”存储管理的基本思想。

**4.7.3 虚拟地址空间 (Virtual Address Space)**
*   **核心思想**：虚拟存储器管理方式采用“请求分页”思想，每次访问仅将当前需要的页面调入主存，进程中其他不活跃的页面放在外存磁盘上。当访问某个信息所在页不在主存时发生**缺页 (Page Fault)**，此时从磁盘将缺失页面调入主存。
*   **抽象**：虚拟存储器机制为程序员提供了一个极大的虚拟（逻辑）地址空间，它是主存和磁盘I/O设备的抽象。
*   **好处**：
    1.  **简化存储管理**：每个进程具有一致的虚拟地址空间。
    2.  **高效利用主存**：主存看作磁盘存储器的一个缓存，仅保存活动的程序段和数据区，根据需要在磁盘和主存间交换信息。
    3.  **保护进程**：每个进程的虚拟地址空间是私有的，可以保护各自进程不被其他进程破坏。
*   **一致的虚拟地址空间**：每个源程序经编译、汇编、链接等处理生成可执行目标代码时，每个程序的目标代码都被映射到同样的虚拟地址空间。
*   **Linux虚拟地址空间映像示例 (图4.40)**：
	* ![[image-191.png]]
    *   **内核区 (Kernel Area)**：0xC0000000以上的高端地址。存放操作系统内核代码和数据，以及与每个进程相关的数据结构（如进程控制信息、页表等）。用户程序无权访问。
    *   **用户区 (User Area)**：存放用户进程的代码和数据。分为：
        *   **(1) 用户栈 (User Stack)**：存放过程调用的参数、返回值、返回地址、局部变量等。从高地址向低地址增长或反向。
        *   **(2) 共享库 (Shared Libraries)**：存放公共的共享函数库代码。
        *   **(3) 堆 (Heap)**：用于动态申请存储区（如`malloc()`）。从低地址向高地址增长。
        *   **(4) 读写数据区**：存放静态全局变量。
        *   **(5) 只读代码/数据区**：存放程序代码和只读数据。
    *   **区域布局特点**：堆区和栈区相向生长。代码区、数据区、共享库区等有各自的起始位置和增长方向。
    *   **空洞**：虚拟地址空间中可能存在未分配的“空洞”。
    *   **页面状态**：
        *   **未分配页**：没有和任何内容关联的页。
        *   **已分配页**：与代码、数据等内容关联的页。分为：
            *   **缓存页**：已调入主存而被缓存在DRAM中的页面。
            *   **未缓存页**：未调入主存而存在磁盘上的页面。
        *   任何时刻，一个进程中的所有页面都被划分成这三个不相交的页面集合。

**4.7.4 虚拟存储器的实现**
*   **类比cache**：可将DRAM构成的主存看作是磁盘存储器的缓存。实现虚拟存储器机制，也需考虑交换块（页面）大小、映射、写一致性等问题。
*   **与cache的不同**：
    *   **交换对象**：cache中缓存的是主存块，主存中缓存的是虚拟页面（磁盘中的程序块）。
    *   **速度差异**：DRAM比SRAM慢约10倍，磁盘比DRAM慢约100000多倍。
    *   **代价差异**：缺页处理代价远大于cache缺失代价。磁盘寻道时间远大于数据读写时间。
*   **设计考量**：
    *   **页面大小**：通常较大（如4KB、8KB）以分摊磁盘访问开销。
    *   **映射方式**：应采用全相联映射（虚拟页可存放到主存任意空闲页框），以提高命中率。
    *   **写策略**：应采用回写 (write back) 方式，而非全写 (write through)，因为磁盘访问速度慢。


虚拟存储器实现分为分页式、分段式和段页式。
1.  **分页式虚拟存储器**
    *   **基本单位**：主存和虚拟地址空间都划分为大小相等的页面。磁盘和主存之间按页面为单位交换信息。
    *   **页面称谓**：
        *   虚拟地址空间中的页面：虚拟页 (VP - Virtual Page)、逻辑页或虚页。
        *   主存空间中的页面：页框 (Page Frame, PF)、物理页 (PP - Physical Page) 或实页。
    *   **(1) 页表 (Page Table, PT)**
        *   **作用**：记录每个虚拟页的存放位置、存取权限、使用情况、修改情况等。操作系统在主存中为每个进程维护一个页表。
        *   **页表项 (Page Table Entry, PTE)**：页表中对应每个虚拟页有一个表项，内容包括：
            *   **存放位置字段**：建立虚拟页和物理页之间的映射。
            *   **装入位 (Valid Bit / Present Bit)**：表示对应页面是否在主存。
                *   “1”：已调入主存（缓存页），位置字段指向主存页框号。
                *   “0”：未调入主存。
                    *   若位置字段为null：未分配页。
                    *   否则：未缓存页，位置字段给出该虚拟页在磁盘上的起始地址。
            *   **修改位 (Dirty Bit)**：说明页面是否被修改过。用于回写策略。
            *   **替换控制位**：说明页面的使用情况（如FIFO位、LRU位），配合替换策略。
            *   **访问权限位**：说明页面是可读可写、只读还是只可执行等，用于存储保护。
            *   **禁止缓存位**：说明页面是否可以装入cache，用于保证磁盘、主存和cache数据一致性。
        *   **页表示例 (图4.41)**：展示了页表项内容及与主存、磁盘的对应关系。
	        * ![[image-192.png]]
        *   **缺页处理**：当CPU访问某数据，其所在虚拟页的装入位为0时，发生“缺页”异常。操作系统执行“缺页”异常处理程序，根据页表项中的磁盘地址从磁盘读入缺失页面到主存某空闲页框（若无空闲则执行替换）。更新页表项，然后返回到原指令重新执行。
        *   **页表大小问题**：虚拟地址空间很大时，页表本身可能非常大（如32位虚拟地址，4KB页面，页表可达4MB）。整个页表存放在主存不现实。
        *   **解决页表过大**：采用多级页表（如二级、三级页表）、倒置页表等方案。具体实现由操作系统考虑。
    *   **(2) 地址转换 (Address Translation)**
        *   **MMU (Memory Management Unit)**：CPU中负责地址转换的部件。
        *   **地址划分**：
            *   虚拟地址：高位字段为虚拟页号 (VPN - Virtual Page Number)，低位字段为页内偏移地址 (VPO - Virtual Page Offset)。
            *   物理地址：高位字段为物理页号 (PPN - Physical Page Number) 或页框号 (PFN - Page Frame Number)，低位字段为页内偏移地址 (PPO - Physical Page Offset)。
            *   由于页面大小固定且为2的幂次，页内偏移地址在虚拟地址和物理地址中是相同的。
        *   **转换过程 (图4.42)**：
	        * ![[image-193.png]]
            1.  CPU根据页表基址寄存器 (PTBR) 中的内容找到当前进程的页表在主存中的首地址。
            2.  以虚拟地址中的虚拟页号 (VPN) 为索引，在页表中找到对应的页表项 (PTE)。
            3.  若PTE中的装入位为1，则取出物理页号 (PPN)。
            4.  将PPN与虚拟地址中的页内偏移地址 (VPO) 拼接，形成实际主存物理地址。
            5.  若PTE中的装入位为0，则发生缺页异常，转操作系统处理。
    *   **(3) 快表 (TLB - Translation Lookaside Buffer)**
        *   **原因**：每次访存前都需先访问主存中的页表进行地址转换，这会使访存次数增加一倍。
        *   **定义**：一种在高速缓存中的页表项组成的页表，也称转换后援缓冲器。存放了页表中最活跃的几个页表项。
        *   **作用**：减少访存时间开销。
        *   **工作流程**：地址转换时，首先到快表中查页表项。
            *   **TLB命中 (Hit)**：若找到，则直接用快表中的PTE进行地址转换，无需访问主存中的慢表。
            *   **TLB缺失 (Miss)**：若未找到，则仍需访问主存中的慢表，并将该PTE调入TLB（若TLB已满则执行替换）。
        *   **TLB特性**：比页表小得多，为提高命中率，通常具有较高的关联度（全相联或组相联）。
        *   **TLB表项**：由页表表项内容加上一个TLB标记字段组成。标记字段在全相联方式下是VPN；组相联方式下是VPN的高位部分。
		*   **多级存储系统示意图 (图4.43)**：展示了TLB和cache都采用组相联映射方式的访问过程。
			* ![[image-194.png]]
            *   **CPU访存过程 (图4.44)**：
	            * ![[image-195.png]]
                1.  CPU给出虚拟地址VA。
                2.  MMU首先在TLB中查找对应的PTE。
                    *   **TLB命中**：直接得到物理地址PA。
                    *   **TLB缺失**：访问主存中的页表获取PTE，并将其存入TLB。
                        *   **缺页**：若页表中该页不在主存，则发生缺页异常，操作系统处理。
                3.  得到物理地址PA后，cache硬件根据PA在cache中查找数据。
                    *   **cache命中**：直接从cache获取数据。
                    *   **cache缺失**：从主存获取数据块到cache，再送CPU。
            *   **三种缺失情况 (表4.1)**：TLB缺失、cache缺失、缺页，以及它们的组合。
	            * ![[image-196.png]]
2.  **分段式虚拟存储器**
    *   **基本思想**：根据程序的模块化性质，按程序的逻辑结构划分成多个相对独立的部分，称为**段 (Segment)**。段是逻辑上独立的单位，可以被其他程序段调用。
    *   **段的属性**：段名（段号）、段起点、段长等。
    *   **主存分配**：段作为基本信息单位在主存和辅存之间传送和定位。主存空间按实际程序中的段来划分，段的长度可变。
    *   **段表 (Segment Table)**：每个进程有一个段表，每个段在段表中有一个段表项，记录对应段在主存中的位置、段长、访问权限、使用和装入情况等。段表本身也是一个可再定位段。
    *   **虚拟地址**：由段号和段内地址组成。
    *   **地址转换 (图4.45)**：
	    * ![[image-197.png]]
        1.  CPU根据段表基址寄存器找到段表。
        2.  以段号为索引找到对应段表项。
        3.  检查异常：缺段（装入位=0）、地址越界（段内地址 > 段长）、保护违例。
        4.  若无异常，将段表项中的段首址与段内地址相加，得到物理地址。
    *   **优点**：
        *   段的划分与程序的自然分界相对应，逻辑独立性好，易于编译、管理、修改和保护。
        *   便于多道程序共享，某些类型的段（如堆、栈）具有动态可变长度。
    *   **缺点**：
        *   段长各不相同，段的起点和终点不固定，给主存空间分配带来麻烦。
        *   容易在主存中留下许多空白的零碎空间（外碎片），造成浪费。
3.  **段页式虚拟存储器**
    *   **结合点**：程序按模块分段，段内再分页。用段表和页表（每段一个页表）进行两级定位管理。
    *   **段表项**：包含指向该段页表起始位置的指针以及该段的其他控制和存储保护信息。页表指明该段各页在主存中的位置以及是否装入、修改等状态。
    *   **信息调入调出**：按页进行。
    *   **共享与保护**：可以按段实现。
    *   **优点**：兼有页式和段式的优点。
    *   **缺点**：地址映像过程中需要多次查表。
    *   **虚拟地址**：在多道程序中，每个用户进程需要一个基号用于标识。虚拟地址由基号、段号、页号和页内地址组成。
	    * ![[image-199.png]]
    * (图4.46为变换过程示意)
	    * ![[image-198.png]]

**\*4.7.5 存储保护 (Memory Protection)**

为避免主存中多道程序相互干扰，或某程序出错破坏其他程序，或程序非法访问其他程序/数据区，应对每个程序进行存储保护。
硬件须支持以下基本功能：
1.  **支持至少两种运行模式**：管理模式 (Supervisor Mode) 和用户模式 (User Mode)。
    *   **系统进程（内核/管理进程）**：执行操作系统功能，运行在管理模式（管态/核心态）。
    *   **用户进程**：执行非操作系统功能，运行在用户模式（目态/用户态）。
2.  **使部分CPU状态只能由系统进程写**：如User/Supervisor模式位、页表首地址、TLB内容等。OS内核可用特殊指令（管态指令）写这些状态。
3.  **提供CPU在管理模式和用户模式间相互转换的机制**：
    *   通过“异常”处理和“陷阱”（系统调用）使CPU从用户模式转到管理模式。
    *   异常处理中的“返回”指令（如`return from exception`）使CPU从管理模式转到用户模式。

存储保护包括访问方式保护和存储区域保护。

1.  **访问方式保护 (“访问越权”)**
    *   通过在页表或段表中设置访问权限位（如读、写、执行）来实现。
    *   规定各道程序对本程序存储区可读可写；对共享区或已授权区可读不可写；对未授权区不可访问。
2.  **存储区域保护 (“地址越界”)**
    *   **加界重定位**：每个程序/段记录起始地址（下界）和终止地址（上界）。物理地址超出此范围则地址越界。可用专门的上下界寄存器，或在段表中记录段长。
    *   **键保护方式**：操作系统为主存的每个页框分配一个存储键，为每个用户进程设置一个程序键。进程运行时，将程序状态字中的键（程序键）和所访问页的键（存储键）进行核对，相符才可访问。键标志为0可表示特殊权限。
    *   **环保护方式**：主存中各进程按重要性分为多个保护级（环），内环进程保护级别最高，可访问外环和同环进程地址空间，外环不得访问内环。系统进程级别最高，用户进程在外环。
