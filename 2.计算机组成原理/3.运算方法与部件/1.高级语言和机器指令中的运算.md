好的，这是关于“3.1 高级语言和机器指令中的运算”的学习笔记：

---

**3.1 高级语言和机器指令中的运算**

计算机硬件的设计目标来源于软件需求。高级语言中的运算通过编译成底层的算术和逻辑运算指令来实现，这些底层指令能直接在硬件上执行。
**3.1.1 C程序中涉及的运算**
C语言除了提供基本的算术运算（加、减、乘、除，包括无符号数、带符号整数和浮点数运算），还包括以下几类基本运算：

1.  **按位运算 (Bitwise Operations)**
    *   `|`：按位或 (OR)
    *   `&`：按位与 (AND)
    *   `~`：按位非 (NOT)
    *   `^`：按位异或 (XOR)
    *   **重要应用：掩码 (Masking)**
        *   通过与一个给定的位模式（掩码）进行按位与操作，可以提取所需要的位。
        *   提取后可对这些位进行“置1”、“清0”、“1测试”或“0测试”等。
        *   **示例：** `0x0F & 0x8C`
            *   `0x0F` (掩码) = `00001111`
            *   `0x8C` = `10001100`
            *   结果 = `00001100` (即 `0x0C`)，提取了一个字节的低4位。

2.  **逻辑运算 (Logical Operations)**
    *   `||`：逻辑或 (OR)
    *   `&&`：逻辑与 (AND)
    *   `!`：逻辑非 (NOT)
    *   **与按位运算的区别：**
        *   逻辑运算是非数值计算，操作数只有两个逻辑值 True 和 False (通常非0数为True，全0数为False)。
        *   按位运算是数值运算，对两个操作数的对应二进制位逐位进行计算。
3.  **移位运算 (Shift Operations)**
    *   **类型：**
        *   **逻辑移位：** 不考虑符号位。高(低)位移出，低(高)位补0。
            *   无符号整数逻辑左移：若最高位移出1，则发生溢出。
        *   **算术移位：** 计算机内部带符号整数用补码表示，移位采用补码算术移位。
            *   左移：高位移出，低位补0。若移出的高位与移位后的符号位不同（即左移前、后符号位不同），则发生“溢出”。
            *   右移：低位移出，高位补符号位。
    *   **C语言规定：**
        *   C语言未明确规定采用逻辑移位还是算术移位。
        *   实际中，多数机器和编译器对无符号整数采用逻辑移位，对带符号整数采用算术移位。
    *   **操作符与效果：**
        *   `x << k`：x左移k位。逻辑左移和算术左移结果相同（丢弃k个最高位，低位补k个0）。
        *   `x >> k`：x右移k位。
        *   每左移一位，相当于数值扩大一倍（可能溢出）。
        *   每右移一位，相当于数值缩小一半。
    *   **示例 3.1：** 32位寄存器R1中存放变量x，机器码为 `80000004H`。
        *   **(1) x 是 unsigned int 类型：**
            *   x 的真值 = `1000 0000 0000 0000 0000 0000 0000 0100B` = 2³¹ + 2²
            *   **x/2 (逻辑右移一位)：**
                *   真值 = (2³¹ + 2²)/2 = 2³⁰ + 2¹
                *   R1中机器码 = `0100 0000 ... 0010B` = `40000002H`。结果一致。
            *   **2x (逻辑左移一位)：**
                *   真值 = (2³¹ + 2²) * 2 = 2³² + 2³
                *   R1中机器码 = `0000 0000 ... 1000B` = `00000008H` = 8。
                *   **结果溢出。** 2³² + 2³ ≠ 8。原因是2x的值超出了32位无符号数最大可表示数 (2³²-1)。左移时移出的高位为1，表明有效数据丢失。
        *   **(2) x 是 signed int 类型 (补码表示)：**
            *   x 的机器码 = `1000 0000 ... 0100B`
            *   x 的真值 = -(2³¹ - 2²) (补码求真值：符号位为1，数值部分各位取反末位加1)
            *   **x/2 (算术右移一位)：**
                *   真值 = -(2³¹ - 2²)/2 = -(2³⁰ - 2¹)
                *   R1中机器码 = `1100 0000 ... 0010B` = `C0000002H`。结果一致。
            *   **2x (算术左移一位)：**
                *   真值 = -(2³¹ - 2²) * 2 = -(2³² - 2³)
                *   R1中机器码 = `0000 0000 ... 1000B` = `00000008H` = 8。
                *   **结果溢出。** -(2³² - 2³) ≠ 8。原因是x左移时，移出的位1不等于左移后的最高位0，表明有效数据丢失。2x的真值比最小可表示数-2³¹还要小。

4.  **位扩展和位截断运算 (Bit Extension and Bit Truncation)**
    *   C语言中无明确的位扩展运算符，但在数据类型转换时（如短数向长数转换）会进行。
    *   **位扩展：** 扩展后数值应保持不变。
        *   **0扩展 (Zero Extension)：** 用于无符号数。在短的无符号数前面添加足够的0。
        *   **符号扩展 (Sign Extension)：** 用于补码表示的带符号整数。在短的带符号整数前添加足够多的符号位。
        *   **示例：**
            *   `short si = -12345;` (十六进制补码 `CFC7`)
            *   `unsigned short usi = si;` (usi 值为 `53191`，十六进制仍为 `CFC7`)
            *   `int i = si;` (i 值为 `-12345`，十六进制补码 `FFFFCFC7`，符号扩展)
            *   `unsigned int ui = usi;` (ui 值为 `53191`，十六进制 `0000CFC7`，0扩展)
    *   **位截断：** 发生在长数转换为短数时。
        *   可能会因溢出而改变数值。若长数的值超出了短数能表示的范围，则截断时会发生错误。
        *   **示例：**
            *   `int i = 53191;` (十六进制 `0000CFC7H`)
            *   `short si = (short)i;` (截断为16位，`si` 值为 `CFC7H`，即 `-12345`)
            *   `int j = si;` (将 `si` 扩展回32位，`j` 值为 `FFFFCFC7H`，即 `-12345`)
            *   原来的 `i` (53191) 经过截断再扩展后，值变为 `-12345`。原因是53191大于16位补码能表示的最大正数32767。
        *   截断溢出和截断错误只会导致意外的计算结果，不引发异常或错误报告。

**3.1.2 MIPS 指令中涉及的运算**

高级语言中的运算最终都通过指令系统中的运算指令实现。MIPS指令系统涉及的运算包括：
*   按位逻辑运算
*   逻辑移位
*   算术移位
*   带符号整数的加减乘除
*   无符号整数的加减乘除
*   带符号整数的符号扩展
*   无符号整数的0扩展
*   单精度浮点数加减乘除
*   双精度浮点数加减乘除
  ![[image-129.png]]
![[image-130.png|544x402]]
**注意：**
*   MIPS指令中没有专门的算术左移指令。因为对于左移，逻辑移位和算术移位结果相同（都是丢弃k个最高位，低位补k个0），所以带符号整数和无符号整数的左移都可用逻辑左移指令实现。
*   MIPS提供的运算指令完全能够实现C语言所需要的各种运算要求。
