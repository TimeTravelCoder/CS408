
浮点运算主要包括浮点数的加、减、乘、除运算。一般有单精度和双精度浮点数运算，有些机器还支持更高精度的扩展浮点数运算。

---

### 3.4.1 浮点数加减运算

**十进制示例：** `0.123 × 10^5 + 0.456 × 10^2`
1.  **对阶：** 将指数调整为相等。小阶向大阶看齐。
    `0.456 × 10^2 = 0.000456 × 10^5`
2.  **尾数相加：**
    `0.123 × 10^5 + 0.000456 × 10^5 = (0.123 + 0.000456) × 10^5 = 0.123456 × 10^5`

**二进制浮点数加减运算规则：**
设两个规格化浮点数 `X = M_x × 2^{E_x}` 和 `Y = M_y × 2^{E_y}`。不失一般性，设 `E_x ≤ E_y`。
则：
*   `X + Y = (M_x × 2^{E_x - E_y} + M_y) × 2^{E_y}`
*   `X - Y = (M_x × 2^{E_x - E_y} - M_y) × 2^{E_y}`

计算机中实现上述计算过程需要以下步骤：

**1. 对阶 (Align Exponents)**
*   **目的：** 使两个浮点数的阶码相等，以便尾数可以直接相加减。
*   **原则：小阶向大阶看齐。** 即将阶码小的那个数的尾数右移，每右移一位，其阶码加1，直到两个数的阶码相等。
*   **阶差计算：** `ΔE = E_x - E_y`。
    *   若 `ΔE ≤ 0` (即 `E_x ≤ E_y`)，则 `E_b ← E_y` (基阶)，`E_x ← E_y`，`M_x ← M_x × 2^{E_x - E_y}` (即 `M_x` 右移 `|ΔE|` 位)。
    *   若 `ΔE > 0` (即 `E_x > E_y`)，则 `E_b ← E_x` (基阶)，`E_y ← E_x`，`M_y ← M_y × 2^{E_y - E_x}` (即 `M_y` 右移 `ΔE` 位)。
*   **IEEE 754 标准下的对阶：**
    *   阶码用移码表示，阶差计算需用移码减法：`[ΔE]_补 = [E_x]_移 + [-[E_y]_移]_补`。然后根据 `[ΔE]_补` 的符号判断 `ΔE` 的正负。
    *   尾数右移时按原码小数方式右移（符号位不参与，数值位右移，高位补0）。
    *   **保留附加位：** 为了保证运算精度，尾数右移时，移出的低位不要丢掉，应保留（至少两位：保护位G和舍入位R，IEEE 754还可能引入粘位S）并参加尾数部分的运算。

**2. 尾数加减 (Add/Subtract Mantissas)**
*   对阶后，两个浮点数的阶码已相等，此时可以进行尾数的加减运算。
*   由于IEEE 754采用定点原码小数表示尾数，所以尾数加减实际上是 **定点原码小数的加减运算** (参见3.3.2节)。
*   运算时需要将隐藏位（通常是1）还原到尾数部分，并带上之前保留的附加位一起运算。

**3. 尾数规格化 (Normalize Mantissa)**
*   尾数加减运算后的结果不一定是规格化的。
*   IEEE 754的规格化尾数形式为 `±1.xxxx...`。
*   **可能出现的结果形式及处理：**
    *   `±1x.xxxx...` (结果绝对值 ≥ 2，例如两个同号大数相加)：**右规 (Right Normalize)**。
        *   操作：尾数右移一位，阶码加1。
        *   `M_b ← M_b × 2^{-1}`，`E_b ← E_b + 1`。
        *   右规时，最高位的"1"被移到小数点前一位作为隐藏位，最后一位移出时要考虑舍入。阶码加1时直接在末位加1。
    *   `±0.00...01xx...` (结果绝对值 < 1，例如两个相近的异号数相减，或一个数减去自身)：**左规 (Left Normalize)**。
        *   操作：数值位逐次左移，阶码逐次减1，直到将第一个非零有效位"1"移到小数点左边。
        *   假定结果中小数点后有 `k` 个连续的0，则 `M_b ← M_b × 2^k`，`E_b ← E_b - k`。
        *   左规时，数值部分最左的 `k` 个0被移出，小数点逻辑上右移 `k` 位。阶码减 `k` 时，每次在末位减1。

**4. 尾数的舍入处理 (Round Mantissa)**
*   在对阶和尾数右规时，可能会有尾数位移出。为保证运算精度，需要对保留的附加位进行舍入处理，将结果格式化为IEEE 754标准。
*   **需要解决的问题：**
    *   保留多少附加位才能保证精度？
    *   最终如何对保留的附加位进行舍入？
*   **附加位：** IEEE 754标准规定，所有浮点数运算的中间结果右边都必须至少额外保留两位：
    *   **保护位 (Guard bit, G):** 紧跟在尾数最低有效位之后。
    *   **舍入位 (Round bit, R):** 紧跟在保护位之后。
    *   **粘滞位 (Sticky bit, S):** （可选，但推荐）在舍入位之后，只要舍入位右边有任何非0数字，粘滞位就置1；否则为0。
*   **IEEE 754 舍入模式 (4种可选)：**
    1.  **就近舍入 (Round to Nearest, ties to even):** 舍入到最接近的可表示数。
        *   若移出部分 > 1/2 LSB (最低有效位)，则向上舍入 (末位加1)。
        *   若移出部分 < 1/2 LSB，则向下舍入 (截断)。
        *   若移出部分 = 1/2 LSB (即 G=1, R=0, S=0)，则向偶数舍入 (使结果的LSB为0)。如果LSB已为0，则截断；如果LSB为1，则末位加1。
        *   **使用粘滞位的好处：** 可以更精确地判断移出部分是否恰好等于1/2 LSB。例如，如果G=1, R=0, 但S=1，说明移出部分比1/2 LSB大一点点，应向上舍入。
    2.  **朝+∞方向舍入 (Round towards +∞ / Round up):** 总是取右边（或上方）最近的可表示数。
    3.  **朝-∞方向舍入 (Round towards -∞ / Round down):** 总是取左边（或下方）最近的可表示数。
    4.  **朝0方向舍入 (Round towards Zero / Truncate):** 直接截取所需位数，丢弃后面所有位。也称截断或恒舍法。这是最简单的，对正负数都是取更靠近原点的数。

**5. 阶码溢出判断 (Check for Exponent Overflow/Underflow)**
*   在尾数规格化（右规、左规）和尾数舍入（可能导致尾数再次溢出需要右规）时，阶码会进行加减运算，需要判断阶码是否溢出。
*   **阶码上溢 (Exponent Overflow):** 若一个正阶码超过了最大允许值 (如单精度127，双精度1023)，机器产生“阶码上溢”异常。
    *   处理：有些机器将结果置为 `+∞` (数符为0) 或 `-∞` (数符为1) 后继续执行；有些机器产生“溢出”异常。
*   **阶码下溢 (Exponent Underflow):** 若一个负阶码的绝对值超过了最大允许值 (即小于最小允许阶码，如单精度-126，双精度-1022)，机器产生“阶码下溢”异常。
    *   处理：一般将结果置为 `+0` (数符为0) 或 `-0` (数符为1)；有些机器引起“阶码下溢”异常。
*   **判断方法：**
    *   **右规/舍入 (阶码加1):** 先判断当前阶码是否已为全1 (最大正阶码)。若是，则不需右规/舍入，直接报上溢；否则，阶码加1后，再判断新阶码是否变为全1，若是则为上溢。
    *   **左规 (阶码减1):** 先判断当前阶码是否已为全0 (最小负阶码)。若是，则直接报下溢；否则，阶码减1后，再判断新阶码是否变为全0，若是则为下溢。

**浮点数加减运算流程图 (图3.30)：**
1.  **阶码调整 (对阶)：** 计算 `ΔE = E_x - E_y`。根据 `ΔE` 的符号和大小，对阶码较小的尾数进行右移，使两阶码相等。
2.  **尾数加减：** `M_b = M_x ± M_y`。
3.  **结果规格化：**
    *   判断 `M_b` 是否为0。若是，则结果为0，结束。
    *   判断 `M_b` 是否溢出 (左规结果是否 `±1x.xxx`，即最高数值位为1)。若是，则右规 (`E_b++`, `M_b` 右移1位)。
    *   判断 `M_b` 最左边是否有连续 `k` 个0 (右规结果是否 `±0.0...01xx`)。若是，则左规 (`E_b -= k`, `M_b` 左移 `k` 位)。
4.  **尾数舍入处理：** 对规格化后的 `M_b` 进行舍入。
5.  **阶码溢出判断：**
    *   检查 `E_b` 是否上溢。若是，置溢出标志，结果为 `±∞`。
    *   检查 `E_b` 是否下溢。若是，置溢出标志，结果为 `±0`。
    *   否则，运算正常结束，结果为 `M_b × 2^{E_b}`。

*   **示例 (例3.16):** IEEE 754单精度计算 `0.5 + (-0.4375)`。
    *   `x = 0.5 = (1.000)_2 × 2^{-1}`。 `[E_x]_移 = -1+127 = 126 = 01111110_2`。 `M_x = (1).000...` (隐藏位1)。
    *   `y = -0.4375 = -(0.01110...)_2 = -(1.110...)_2 × 2^{-2}`。 `[E_y]_移 = -2+127 = 125 = 01111101_2`。 `M_y = -(1).110...`。
    1.  **对阶：** `ΔE = E_x - E_y = -1 - (-2) = 1`。`E_y` 小，`M_y` 右移1位。
        `M_y' = -(0.1110...)_2` (保留两位附加位00)。`E_y' = E_x = -1`。
        `M_x = +(1).0000000...` `M_y' = -(0).1110000...` (小数点在隐藏位后)
    2.  **尾数相加：** `M_b = M_x + M_y' = (+1.0000000) + (-0.1110000) = +0.0010000...`。
    3.  **规格化：** `M_b` 数值部分高位有3个连续的0。左规3位。
        `M_b' = +(1).0000000...` (小数点移到第一个1后)。
        `E_b = E_x - 3 = -1 - 3 = -4`。 `[E_b]_移 = -4+127 = 123 = 01111011_2`。
    4.  **舍入：** `M_b'` 最后两位附加位为00，舍去。`M_b'' = +(1).000...`。
    5.  **溢出判断：** `E_b = -4`，未溢出。
    *   结果：阶码真值-4，尾数真值+1.0。`+1.0 × 2^{-4} = 1/16 = 0.0625`。

---

### 3.4.2 浮点数乘除运算

进行浮点数乘除运算前，同样需要对操作数进行判0、规格化和溢出判断。

已知两个浮点数 `X = M_x × 2^{E_x}` 和 `Y = M_y × 2^{E_y}`。
*   **乘法：** `X × Y = (M_x × M_y) × 2^{E_x + E_y}`
*   **除法：** `X / Y = (M_x / M_y) × 2^{E_x - E_y}`

**1. 浮点数乘法运算**
1.  **尾数相乘，阶码相加：**
    *   **尾数相乘：** `M_b = M_x × M_y`。采用 **定点原码小数乘法** (参见3.3.4节)。
        *   运算时将隐藏位1还原到尾数中。
        *   符号位由 `M_x` 和 `M_y` 的符号异或得到。
        *   数值部分将两个形如 `1.xxxx...` 的数进行n位数乘法，结果为2n位积 `xx.xxxx...` (小数点默认在第二位和第三位之间)。
    *   **阶码相加：** `E_b = E_x + E_y`。采用 **移码加法**。
        *   `[E_b]_移 = [E_x]_移 + [E_y]_移 - 偏置常数`。
        *   对于IEEE 754单精度 (偏置127)，公式为 `[E_b]_移 = [E_x]_移 + [E_y]_移 + [-127]_补 = [E_x]_移 + [E_y]_移 + 10000001_2 (mod 2^8)`。
        *   或者更常用的 `[E_b]_移 = [E_x]_移 + [E_y]_移 + 129 (mod 2^8)` （若用8位补码129）。
2.  **尾数规格化：**
    *   对于IEEE 754规格化尾数 `|M_x| ≥ 1` 和 `|M_y| ≥ 1`，则 `1 ≤ |M_x × M_y| < 4`。
    *   即乘积数值 `xx.xxxx...` 的整数部分可能是 `01`, `10`, 或 `11`。
        *   若为 `01.xxxx...`，则已是规格化形式，无需处理。
        *   若为 `10.xxxx...` 或 `11.xxxx...`，则需要 **右规** 一次：`M_b` 右移一位，`E_b` 加1。
    *   浮点数乘法不需要左规。
3.  **尾数舍入处理：** 对规格化后的尾数进行舍入。
4.  **阶码溢出判断：**
    *   阶码加法和右规时的溢出判断与浮点数加减运算中的类似。
    *   阶码加法溢出判断规则 (根据 `[E_x]_移, [E_y]_移, [E_b]_移` 的最高位)：
        *   **上溢：** 若 `[E_b]_移` 全1，或 `[E_x]_移` 和 `[E_y]_移` 最高位都为1而 `[E_b]_移` 最高位为0。
        *   **下溢：** 若 `[E_b]_移` 全0，或 `[E_x]_移` 和 `[E_y]_移` 最高位都为0而 `[E_b]_移` 最高位为1。

**2. 浮点数除法运算**
1.  **尾数相除，阶码相减：**
    *   **尾数相除：** `M_b = M_x / M_y`。采用 **定点原码小数除法** (参见3.3.7节)。
        *   运算时将隐藏位1还原到尾数中。
        *   符号位由 `M_x` 和 `M_y` 的符号异或得到。
        *   数值部分将两个形如 `1.xxxx...` 的数进行n位数除法，结果为n位商 `x.xxxx...` (小数点默认在第一位和第二位之间)。
    *   **阶码相减：** `E_b = E_x - E_y`。采用 **移码减法**。
        *   `[E_b]_移 = [E_x]_移 - [E_y]_移 + 偏置常数`。
        *   对于IEEE 754单精度，公式为 `[E_b]_移 = [E_x]_移 + [-[E_y]_移]_补 + 01111111_2 (mod 2^8)`。
2.  **尾数规格化：**
    *   对于IEEE 754规格化尾数 `|M_x| ≥ 1` 和 `|M_y| ≥ 1`，则 `1/2 < |M_x / M_y| < 2`。
    *   即商的数值 `x.xxxx...` 的整数部分可能是 `0` 或 `1`。
        *   若为 `0.xxxx...` (且第一位小数为1)，则需要 **左规** 一次：`M_b` 左移一位，`E_b` 减1。
        *   若为 `1.xxxx...`，则已是规格化形式。
    *   浮点数除法不需要右规。
3.  **尾数舍入处理：** 对规格化后的尾数进行舍入。
4.  **阶码溢出判断：**
    *   阶码减法和左规时的溢出判断与浮点数加减运算中的类似。
    *   阶码减法溢出判断规则 (根据 `[E_x]_移, [E_y]_移, [E_b]_移` 的最高位)：
        *   **上溢：** 若 `[E_b]_移` 全1，或 `[E_x]_移` 最高位为1、`[E_y]_移` 最高位为0，且 `[E_b]_移` 最高位为0。
        *   **下溢：** 若 `[E_b]_移` 全0，或 `[E_x]_移` 最高位为0、`[E_y]_移` 最高位为1，且 `[E_b]_移` 最高位为1。

