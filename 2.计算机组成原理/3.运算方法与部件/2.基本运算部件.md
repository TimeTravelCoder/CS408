
对于逻辑运算指令和定点加减运算指令，其实现相对简单：
*   **逻辑运算：** 可直接用基本逻辑门电路实现。
*   **定点加减运算：** 用定点补码加法器实现无符号数和带符号整数的加减运算。

一般情况下，会使用一个专门的 **算术逻辑部件 (Arithmetic and Logic Unit, ALU)** 来完成基本的逻辑运算和定点数加减运算。而各类定点乘除运算和浮点数运算则可利用加法器或ALU和移位器来实现。

因此，基本的运算部件主要包括：**加法器、ALU 和移位器**。其中，ALU的核心部件是加法器。

移位操作：
*   ALU内部也可实现左(右)移一位和两位的操作。
*   也可用一个 **移位寄存器** 实现移位。
*   这两种方式每次都只能固定移动一位或两位。对于需要一次移动若干位的操作（如MIPS的移位指令），通常用一个专门的 **桶形移位器 (Barrel Shifter)** 实现。桶形移位器利用大量多路选择器实现数据的快速移位，能够一次完成。
*   在ALU外单独设置桶形移位器，可以简化ALU的控制逻辑，并实现移位操作和ALU操作的并行性。
### 3.2.1 串行进位加法器 (Ripple Carry Adder, CRA)

*   **全加器 (Full Adder):** 是构成多位加法器的基本单元。它实现两个本位数 $X_i、Y_i$ 和来自低位的进位$C_{i-1}$ 相加，生成一位本位和 $F_i$ 及一位向高位的进位 $C_i$。
    *   逻辑表达式：
        *   $F_i = X_i ⊕ Y_i ⊕ C_{i-1}$ (全加和)
        *   $C_i = X_i C_{i-1} + Y_i C_{i-1} + X_i Y_i$ (全加进位)
    *   从 $C_{i-1} 到 C_i$ 的延迟是两级门延迟。
   ![[image-131.png]]
*   **n位串行进位加法器：** 将n个全加器串行连接而成。
	* ![[image-132.png]]
    *   实现了两个n位二进制数 $X = X_n X_{n-1} ... X_1 和 Y = Y_n Y_{n-1} ... Y_1$ 的逐位相加。
    *   得到的二进制和为$F = F_n F_{n-1} ... F_1$，进位输出为$C_n$。
    *   由于只有有限位数，高位自动丢失，实际上是在模2<sup>n</sup>运算系统下的加法运算，可以实现n位无符号数的加法和n位补码加法。
    *   **特点：**
        *   结构简单，所用元件少。
        *   进位是串行传送的：任意一位的加法运算都必须等到其低位加法完成并送来进位时才能正确进行。
        *   速度较慢：从最低位进位 $C_0$ 到最高位进位 $C_n$ 的延迟时间为 2n 级门延迟。若一个异或门为三级门延迟，则最后一位和 $F_n$ 的延迟时间为 $2n+1$ 级门延迟。
        *   运算时间随加数位数 n 的增加而增加，当 n 较大时，速度显著变慢。
    *   也称为 **行波进位加法器 (Carry Ripple Adder, CRA)**，因为最低位的进位像水波一样逐级向高位传播。

---

### *3.2.2 进位选择加法器 (Carry Select Adder)
       
*   **核心思想：** 提前进行高位部分的运算，以实现高、低两部分并行执行，从而加快运算速度。
*   **原理：**
    *   由于低位部分向高位部分的进位尚未得到，因此在进行高位部分的加运算时，同时用两个加法器实现：一个加法器的低位进位假定为0，另一个假定为1。
    *   等到低位部分的结果（即实际的进位）出来后，根据这个进位值选择使用哪一个高位加法器的结果。
    * ![[image-137.png]]
*   **结构示例 (8位):**
    *   将8位加法器分为两个4位部分（低4位和高4位）。
    *   低4位部分正常进行串行进位加法，产生进位 C_4。
    *   高4位部分使用两个4位加法器并行计算：
        *   一个假设来自低位的进位为0，计算 X[5:8] + Y[5:8]。
        *   另一个假设来自低位的进位为1，计算 X[5:8] + Y[5:8] + 1。
    *   使用一个多路选择器 (MUX)，根据低4位产生的实际进位 C_4 来选择其中一个高4位加法器的结果作为最终的高4位和。
*   **优点：** 通过用两个高位部分加法器代替一个，实现了高、低两部分的并行执行，可使运算时间减半。
*   **缺点：** 通过重叠设置加法器来加快速度，代价较大。
*   可以进一步将4位加法器分解成高、低各两位，使运算时间再减半。

---

### 3.2.3 并行进位加法器 (Carry Lookahead Adder, CLA)

*   **核心思想：** 减少进位之间的依赖，使各进位独立且并行产生，以加快运算速度。
*   **进位产生条件 (以4位加法器为例):**
    *   $C_1 = X_1 Y_1 + (X_1 + Y_1) C_0$
    *   $C_2 = X_2 Y_2 + (X_2 + Y_2) C_1 = X_2 Y_2 + (X_2 + Y_2) X_1 Y_1 + (X_2 + Y_2)(X_1 + Y_1) C_0$
    *   $C_3 = X_3 Y_3 + (X_3 + Y_3) C_2 = ...$
    *   $C_4 = X_4 Y_4 + (X_4 + Y_4) C_3 = ..$.
*   **定义辅助函数：**
    *   **进位生成函数 (Carry Generate):** $G_i = X_i Y_i$
        *   含义：当 $X_i 和 Y_i$ 均为1时，不管有无低位进位输入，本位一定向高位产生进位输出。
    *   **进位传递函数 (Carry Propagate):** $P_i = X_i + Y_i$ (有些教材定义为 $P_i = X_i ⊕ Y_i$)
        *   含义：当 $X_i 或 Y_i$ 中有一个为1时，若低位有进位输入，则该进位一定被传递到高位。这个进位可看作是低位进位越过本位直接向高位传递的。
*   **并行进位表达式：**
    *   $C_1 = G_1 + P_1 C_0$
    *   $C_2 = G_2 + P_2 G_1 + P_2 P_1 C_0$
    *   $C_3 = G_3 + P_3 G_2 + P_3 P_2 G_1 + P_3 P_2 P_1 C_0$
    *   $C_4 = G_4 + P_4 G_3 + P_4 P_3 G_2 + P_4 P_3 P_2 G_1 + P_4 P_3 P_2 P_1 C_0$
    *   从表达式可以看出，每个进位 $C_i 仅与 X_j、Y_j (j ≤ i) 和 C_0 有关，与 C_1 到 C_{i-1}$ 这些中间进位无关。只要所有 $X_i、Y_i 和 C_0$ 同时到达，就可几乎同时形成所有进位 $C_1 ~ C_4$，并同时生成各位的和。
*   **先行进位部件 (Carry Lookahead Unit, CLA部件):** 实现上述并行进位逻辑表达式的电路。
*   **全先行进位加法器：** 通过这种并行进位方式实现的加法器。
	* ![[image-138.png]]
    *   **4位CLA部件和4位全先行进位加法器示例：**
        *   从 $X_i, Y_i 到产生 P_i, G_i$ 需要1级门延迟。
        *   从 $P_i, G_i, C_0 到产生所有进位 C_1 ~ C_4$ 需要2级门延迟（通常是与非门 + 与或非门，或者与门 + 或门）。
        *   产生全部和需要 1 $(P_i, G_i) + 2 (C_i) + 3 (F_i, 异或门) = 6级门延迟$（假定异或门等于3级门延迟）。
*   **更高位数CLA的挑战：**
    *   理论上，更多位数的CLA部件只会增加逻辑门的输入端个数，而不会增加门的级数，延迟仍为6级门。
    *   但实际上，CLA部件中连线数量和输入端个数的增多，使得实现电路需要具有大驱动信号和大扇入门。当位数较多时，全先行进位实现方式不太现实（例如32位加法器的 $C_{32}$ 生成逻辑门的输入端会非常多）。
*   **实际实现方式：** 更多位数的加法器通常通过4位CLA部件或4位全先行进位加法器来构建。

    *   **单级先行进位加法器 (4n位):**
        *   将4n位加法器分成n组，每组是一个4位全先行进位加法器。
        *   采用 **“组内并行，组间串行”** 的进位方式。即每组内部进位并行产生，但组与组之间的进位（如 $C_4, C_8, C_{12}$）是串行传递的。
        *   **16位单级先行进位加法器示例 (图3.8):**
	        * ![[image-139.png]]
            *   关键路径延迟：$(X_{4-1}, Y_{4-1}, C_0) → (C_4) → (C_8) → (C_{12}) → (F_{16-13})$
            *   延迟为 $3 (C_4) + 2 (C_8) + 2 (C_{12}) + 5 (F_{16-13}) = 12$ 级门延迟。
            *   对于4n位单级先行进位加法器，延迟为 2n+4。
            *   相比之下，4n位串行进位加法器的延迟为 2(4n)+1 = 8n+1。速度大约提高了4倍。

    *   **两级先行进位加法器 (例如16位):**
        *   为了进一步提高速度，可以采用 **“组内并行，组间也并行”** 的进位方式。
        *   **定义组的进位传递和生成函数：**
            *   $C_4 = G_{m1} + P_{m1} C_0  (这里 G_{m1} 是第1个4位组的进位生成，P_{m1} 是第1个4位组的进位传递)$
            *   $P_{m1} = P_4 P_3 P_2 P_1$
            *   $G_{m1} = G_4 + P_4 G_3 + P_4 P_3 G_2 + P_4 P_3 P_2 G_1$
        *   **组间进位表达式 (以16位为例，分为4个4位组):**
            *   $C_4 = G_{m1} + P_{m1} C_0$
            *   $C_8 = G_{m2} + P_{m2} C_4 = G_{m2} + P_{m2} G_{m1} + P_{m2} P_{m1} C_0$
            *   $C_{12} = G_{m3} + P_{m3} C_8 = ...$
            *   $C_{16} = G_{m4} + P_{m4} C_{12} = ...$
        *   可以看出，组内进位 (式3-3) 和组间进位 (式3-5) 的逻辑表达式是类似的。
        *   **成组先行进位部件 (Block Carry Lookahead, BCLA) 或称第二级CLA部件：** 实现上述组间并行进位逻辑的电路。
        *   **16位两级先行进位加法器 (图3.9):** 由4个4位全先行进位加法器和1个BCLA部件构成。
	        * ![[image-140.png]]
            *   关键路径延迟：$(X_i, Y_i) → (P_{mi}, G_{mi}, C_0) → (C_4 \text{ in BCLA}) → (F_i \text{ in first group})$
            *   延迟为 $3 (P_{mi}, G_{mi}) + 2 (C_4 \text{ in BCLA}) + 3 (F_i) = 8$ 级门延迟。
            *   最终进位 $C_{16}$ 的延迟为 $3 (P_{mi}, G_{mi}) + 2 (C_{16} \text{ in BCLA}) = 5$ 级门延迟。
        *   **优点：** 延迟和加法器的位数没有关系，不会随着位数的增加而显著延长时间。
        *   计算机内部大多采用两级或多级先行进位加法器。

---
### 3.2.4 算术逻辑部件 (ALU)
*   ALU是一种能进行多种算术运算与逻辑运算的组合逻辑电路，其基本逻辑结构是加法器。
*   **符号表示 (图3.10):**
	* ![[image-141.png]]
    *   输入：两个N位操作数A和B，进位输入CarryIn，操作控制端ALUop。
    *   输出：运算结果Result，相应的运算结果标志信息（零标志Zero，溢出标志Overflow，进位标志CarryOut）。
    *   ALUop的位数决定了操作的种类。
*   **一位ALU结构示例 (图3.11):** 实现“与”、“或”、“加法”三种运算。
	* ![[image-142.png]]
    *   一位全加器实现加法。
    *   通过ALUop控制一个多路选择器 (Mux) 选择输出三种操作结果之一。
    *   ALUop至少需要两位。
*   **多位ALU的构建：**
    *   可利用串行进位、单级或多级先行进位等方式构建。
    *   由于先行进位速度快，ALU多采用先行进位方式。
*   **4位单级先行进位ALU示意图 (图3.12):**
	* ![[image-143.png]]
    *   由4个一位ALU和一个4位CLA部件构成。
    *   进位辅助函数仍为 $g_i = A_i B_i 和 p_i = A_i + B_i$ (这里的A, B指一位ALU的输入，具体是什么取决于ALUop选择的操作)。
*   **典型商售ALU芯片 - SN74181 (4位ALU组件):**
    *   能对两个4位二进制代码 $A_3A_2A_1A_0 和 B_3B_2B_1B_0$ 进行16种算术运算（当M为低电位时）和16种逻辑运算（当M为高电位时），产生结果 $F_3F_2F_1F_0$。
    *   功能选择端 $S_3S_2S_1S_0$ 控制具体运算。
    *   C_n 是最低位进位输入（低电平有效）。
    *   $C_{n+4}$ 是ALU进位输出信号。
    *   **功能表 (表3.2):** 展示了不同 $S_3S_2S_1S_0 和 C_n$ 组合下的算术和逻辑运算。
	    * ![[image-144.png]]
        *   例如，当 $S_3S_2S_1S_0 = 1001$ 且 $C_n = H$ (无进位) 时，进行算术加法 A+B。
        *   当 $S_3S_2S_1S_0 = 0110 且 C_n = L$ (有进位，相当于减法中的借位取反) 时，进行算术减法 A-B。
*   **构建更高位数ALU：**
    *   **SN74182 (4位BCLA部件):** 用于配合SN74181构建多级先行进位ALU。SN74181能提供组进位生成(G)和传递(P)信号给SN74182。
    *   **16位两级先行进位ALU (图3.15):** 用4个SN74181和一个SN74182构成，实现芯片间进位的并行生成和芯片内的并行运算。
    *   类似地，可以构建如64位的三级先行进位快速ALU。
    * ![[image-145.png]]
*   **注意：** 通用计算机处理器中的ALU是其内部电路的一部分，不会直接用SN74181/182这样的芯片连接而成，但其设计思想是类似的。