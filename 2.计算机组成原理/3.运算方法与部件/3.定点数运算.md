好的，这是关于“3.3 定点数运算”的学习笔记：

## 3.3 定点数运算

从前面3.1节介绍的高级语言和机器指令涉及的运算来看，定点运算主要包括：

*   **无符号数：**
    *   按位逻辑运算
    *   逻辑移位运算
    *   位扩展（0扩展）和截断运算
    *   加、减、乘、除运算
*   **带符号整数：**
    *   算术移位运算
    *   位扩展（符号扩展）和截断运算
    *   加、减、乘、除运算

无符号数的按位逻辑运算可用逻辑门电路实现，逻辑移位运算可用专门的移位器或斜送结果等方式实现。带符号数的移位运算、无符号数和带符号整数的位扩展和截断运算也可用简单电路较容易地实现。

因此，本节主要内容是介绍无符号数和带符号整数（主要为补码表示）的 **加、减、乘、除运算** 以及这些运算所涉及到的运算部件。

计算机内部带符号数基本都是用 **补码** 表示的，所以带符号整数的运算主要介绍补码运算。

浮点数由定点小数（尾数）和定点整数（阶码）表示。IEEE 754标准用原码定点小数表示尾数，用移码表示阶码。因此浮点数运算会涉及到原码定点小数的加、减、乘、除运算和移码的加、减运算。本节也会介绍这些运算。

---

### 3.3.1 补码加减运算

若两个补码表示的n位定点整数为 `[X]_补 = X_{s}X_{n-1}...X_0` 和 `[Y]_补 = Y_{s}Y_{n-1}...Y_0`，则其加减运算表达式如下：

*   **补码加法：** `[X+Y]_补 = [X]_补 + [Y]_补 (mod 2^n)`
*   **补码减法：** `[X-Y]_补 = [X]_补 + [-Y]_补 (mod 2^n)`

从公式可以看出：
1.  在补码表示方式下，无论X、Y是正数还是负数，加、减运算统一采用加法来处理。
2.  符号位 (MSB) 可以和数值位一起参与运算。
3.  加、减运算结果的符号位也在求和运算中直接得出。
4.  可以直接用前面3.2节介绍的加法器实现 `[X]_补 + [Y]_补 (mod 2^n)` 和 `[X]_补 + [-Y]_补 (mod 2^n)`。最终运算结果的高位丢弃，保留低n位，相当于对和数取模2<sup>n</sup>。
5.  实现减法的主要工作在于求 `[-Y]_补`。

**求 `[-Y]_补` 的方法：**
根据第2章介绍的补码运算特点，已知一个数 `Y` 的补码 `[Y]_补`，则其相反数 `-Y` 的补码 `[-Y]_补` 可以通过对 `[Y]_补` “各位取反、末位加1” 得到。

**补码加减运算部件 (图3.16)：**
	![[image-387.png]]
*   在原加法器的Y输入端，加入n个反相器实现各位取反。
*   使用一个2选1多路选择器，由控制端 `Sub` 控制：
    *   当 `Sub=0` (做加法) 时，选择 `[Y]_补` 输入加法器。
    *   当 `Sub=1` (做减法) 时，选择 `[Y]_补` 的反码 `[\bar{Y}]_补` 输入加法器。
*   将控制端 `Sub` 同时作为最低位的进位输入 `C_0`：
    *   当 `Sub=0` (加法) 时，`C_0=0`，实现 `[X]_补 + [Y]_补`。
    *   当 `Sub=1` (减法) 时，`C_0=1`，实现 `[X]_补 + [\bar{Y}]_补 + 1`，即 `[X]_补 + [-Y]_补`。

**溢出判断：**
所有指令系统对于带符号数的运算都要进行“溢出”判断。对于n位补码整数，可表示的数值范围为 `-2^{n-1}` 到 `2^{n-1}-1`。当运算结果超出该范围时，结果溢出。

*   **示例 (例3.2):** 用4位补码计算 “-7-6” 和 “-3-5” 的值。
    *   `[-7]_补 = 1001`, `[-6]_补 = 1010`
    *   `[-7-6]_补 = [-7]_补 + [-6]_补 = 1001 + 1010 = (1)0011` (丢弃最高进位) → `+3`。
        *   因为4位补码可表示范围为 -8 ~ +7，而 -7-6 = -13 < -8，所以结果 `0011 (+3)` 一定发生了溢出，是错误的值。
    *   `[-3]_补 = 1101`, `[-5]_补 = 1011`
    *   `[-3-5]_补 = [-3]_补 + [-5]_补 = 1101 + 1011 = (1)1000` (丢弃最高进位) → `-8`。
        *   结果 `-8` 没有超出范围，是正确的值。

*   **溢出判断的两种现象/方法：**
    1.  **方法一 (双进位判断法)：** 若符号位产生的进位 `C_s` (即 `C_n`) 与最高数值位向符号位的进位 `C_{n-1}` **不同**，则产生溢出。
        *   `Overflow = C_{n-1} ⊕ C_s`
        *   对应于例 “-7-6”：`C_s=1` (1001+1010最高位有进位)，`C_{n-1}=0` (001+010次高位无进位)。`C_s ≠ C_{n-1}`，溢出。
        *   对应于例 “-3-5”：`C_s=1`，`C_{n-1}=1`。`C_s = C_{n-1}`，未溢出。
        *   溢出判断电路 (图3.18): 用一个异或门实现。
	        * ![[image-388.png]]
    2.  **方法二 (操作数与结果符号判断法)：** 若两个加数的符号位 `X_s` 和 `Y_s` **相同**，且与和的符号位 `F_s` **不同**，则产生溢出。
        *   `Overflow = X_s Y_s \bar{F_s} + \bar{X_s} \bar{Y_s} F_s` (同为正数相加得负数，或同为负数相加得正数)
        *   对应于例 “-7-6”：`X_s=1, Y_s=1` (均为负)，`F_s=0` (结果为正)。符号不同，溢出。
        *   对应于例 “-3-5”：`X_s=1, Y_s=1` (均为负)，`F_s=1` (结果为负)。符号相同，未溢出。

*   **变形补码 (双符号位补码/模4补码)：**
    *   正数的双符号位为 `00`，负数的双符号位为 `11`。
    *   **溢出判断条件：** 若结果的两个符号位 `F_{s1}F_{s2}` **不一致** (即为 `01` 或 `10`)，则产生溢出。
        *   `Overflow = F_{s1} ⊕ F_{s2}`
        *   两个正数相加：不溢出结果 `00...`；正溢出结果 `01...` (实际结果为正)。
        *   两个负数相加：不溢出结果 `11...`；负溢出结果 `10...` (实际结果为负)。

**判零电路 (图3.17)：**
	![[image-389.png]]
MIPS指令中的分支指令需要对两个带符号数做减法，然后判断结果是否为0。补码加减运算部件中要有判0电路，通常是将结果的各位输入一个或非门（或与非门后取反）。

**标志寄存器 (Flag Register / Status Register)：**
许多机器除了记录运算结果的和数，还会提供进位标志(CF)、符号标志(SF)、零标志(ZF)、溢出标志(OF)、辅助进位标志(AF)、奇偶标志(PF)等。这些标志信息在运算电路中产生后，被记录到专门的标志寄存器中，供分支指令等用作检测条件。
*   **CF (Carry Flag):** 反映运算执行后是否在最高位产生进位或借位。
*   **AF (Auxiliary Carry Flag):** 反映运算后是否在低4位产生进位或借位 (主要用于BCD码调整)。
*   **PF (Parity Flag):** 反映运算结果低8位的奇偶性。
*   **ZF (Zero Flag):** 反映运算结果是否为0。
*   **SF (Sign Flag):** 反映运算结果符号是否为1 (负数)。
*   **OF (Overflow Flag):** 反映运算结果是否溢出。

---

### *3.3.2 原码加减运算

计算机中的浮点数多采用IEEE 754标准，其尾数用原码表示。因此有必要了解原码定点小数的运算。

在原码加减运算中，符号位和数值位是分开计算的：
*   符号位在运算过程中起判断和控制作用，并对结果的符号位产生影响。
*   数值位上进行加减运算。

**原码加减运算规则：**
1.  **比较操作数符号：**
    *   **加法：** 同号求和，异号求差。
    *   **减法：** 异号求和，同号求差。
2.  **求和操作：** 数值位相加。若最高位产生进位，则结果溢出。和的符号位取被加数（或被减数）的符号。
3.  **求差操作：** 被加数（或被减数）的数值位加上加数（或减数）的数值位的 **补码**，并按以下规则产生结果：
    *   **① 最高数值位产生进位：** 表明加法结果为正，所得数值位正确。差的符号位取被加数（或被减数）的符号。
    *   **② 最高数值位没有产生进位：** 表明加法结果为负，得到的是数值位的补码形式。需要对结果求补（各位取反末位加1），还原为绝对值形式的数值位。差的符号位为被加数（或被减数）的符号 **取反**。

*   **示例 (例3.3):** `[X]_原 = 1.0011`, `[Y]_原 = 1.1010`，计算 `[X+Y]_原`。
    *   同号（均为负），用加法求和。和的符号同被加数（1）。
    *   数值位：`0011 + 1010 = 1101`。
    *   结果：`[X+Y]_原 = 1.1101`。
*   **示例 (例3.4):** `[X]_原 = 1.0011`, `[Y]_原 = 1.1010`，计算 `[X-Y]_原`。
    *   同号（均为负），用减法求差。差的符号根据比较结果确定（这里是 `X` 符号取反）。
    *   数值位：`0011` (X的绝对值) + `(1010)_补` (Y的绝对值的补码)
        *   `(1010)_补` (相对于模 `2^4`)= `0101+1 = 0110`
        *   `0011 + 0110 = 1001`。最高数值位没有产生进位。
    *   表明结果为负，需对 `1001` 求补：`(1001)_补 = 0110+1 = 0111`。
    *   差的符号位为 `[X]_原` 的符号位取反，即 `0`。
    *   结果：`[X-Y]_原 = 0.0111`。

上述运算过程在浮点数运算部件中的尾数加减法器中实现。

---

### *3.3.3 移码加减运算

计算机中的浮点数多采用IEEE 754标准，其阶码用移码表示。在浮点数加减运算中需要比较阶码大小，在浮点数乘除运算中需要求阶码的和与差。因此浮点数运算涉及到移码定点加减运算。

假设E为阶，移码位数为n，根据移码和补码的定义：
*   `[E]_移 = 2^{n-1} + E`  (`-2^{n-1} ≤ E < 2^{n-1}`)
*   `[E]_补 = E`  (`0 ≤ E < 2^{n-1}`)  或  `[E]_补 = 2^n + E`  (`-2^{n-1} ≤ E < 0`)  (mod 2<sup>n</sup>)

可以推导出移码的加减运算规则：
*   **移码加法：** `[E1]_移 + [E2]_移 = (2^{n-1}+E1) + (2^{n-1}+E2) = 2^n + E1 + E2 = [E1+E2]_补 (mod 2^n)`
*   **移码减法：** `[E1]_移 - [E2]_移 = [E1]_移 + [-[E2]_移]_补 = (2^{n-1}+E1) + (2^n - (2^{n-1}+E2)) = 2^n + E1 - E2 = [E1-E2]_补 (mod 2^n)`

**结论：移码的和/差 等于 和/差的补码。**

根据移码和补码仅符号位相反的关系，可得出移码加减运算的步骤：
1.  **加法：** 直接将 `[E1]_移` 和 `[E2]_移` 进行模2<sup>n</sup>相加，然后对结果的 **符号位取反**。
2.  **减法：** 先将减数 `[E2]_移` 求补（各位取反，末位加1，得到 `[-[E2]_移]_补`），然后再与被减数 `[E1]_移` 进行模2<sup>n</sup>相加，最后对结果的 **符号位取反**。
3.  **溢出判断规则：** 进行模2<sup>n</sup>相加时，如果两个加数的符号相同，并且与和数的符号也相同，则发生溢出。

*   **示例 (例3.5):** 用4位移码计算 “-7+(-6)” 和 “-3+6” 的值。
    *   `[-7]_移 = 0001`, `[-6]_移 = 0010`, `[-3]_移 = 0101`, `[6]_移 = 1110`。
    *   `[-7]_移 + [-6]_移 = 0001 + 0010 = 0011`。符号位取反后为 `1011` (真值为+3)。
        *   两个加数符号为0，结果符号为0，发生溢出。 (因为 -7+(-6)=-13，小于4位移码最小数-8)
    *   `[-3]_移 + [6]_移 = 0101 + 1110 = (1)0011`。符号位取反后为 `1011` (真值为+3)。
*   **示例 (例3.6):** 用4位移码计算 “-7-(-6)” 和 “-3-5” 的值。
    *   `[-[-6]_移]_补 = [-(0010)]_补 = [1101+1]_补 = 1110`。
    *   `[-7]_移 - [-6]_移 = 0001 + 1110 = 1111`。符号位取反后为 `0111` (真值为-1)。
    *   `[5]_移 = 1101`, `[-[5]_移]_补 = [-(1101)]_补 = [0010+1]_补 = 0011`。
    *   `[-3]_移 - [5]_移 = 0101 + 0011 = 1000`。符号位取反后为 `0000` (真值为-8)。

上述移码加减运算主要用于浮点数乘除运算中的阶码相加减。

---

### 3.3.4 原码乘法运算

原码作为浮点数尾数的表示形式，需要计算机能实现定点原码小数的乘法运算。
根据每次部分积是一位还是两位相乘得到，可以有原码一位乘法和原码两位乘法等。

**1. 原码一位乘法**
用原码实现乘法运算时，符号位与数值位分开计算：
1.  **确定乘积的符号位：** 由两个乘数的符号异或得到 (`Z_s = X_s ⊕ Y_s`)。
2.  **计算乘积的数值位：** 乘积的数值部分为两个乘数的数值部分（绝对值）之积。
    *   `[X × Y]_原 = (X_s ⊕ Y_s) . (|X| × |Y|)`
    *   可以不管小数点，将数值部分看作两个无符号整数相乘。

**手算乘法示例 (0.1011 × 0.1101):**
```
      0.1011   (被乘数 X = 0.X1X2X3X4)
    x 0.1101   (乘数 Y = 0.Y1Y2Y3Y4)
    ----------
      1011     (X * Y4 * 2^-4)
     0000      (X * Y3 * 2^-3)
    1011       (X * Y2 * 2^-2)
   1011        (X * Y1 * 2^-1)
  ------------
  0.10001111   (乘积)
```
由此可知 `X × Y = Σ (X × Y_i × 2^-i)` (i从1到n)

**计算机实现无符号数乘法的改进：**
1.  **逐位乘累加：** 每将乘数Y的一位乘以被乘数X得 `X × Y_i` 后，就将该结果与前面所得的部分积 (Partial Product, PP) 累加，得到新的部分积 `P_j`。减少了保存每次相乘结果的开销。
2.  **部分积右移：** 在每次求得 `X × Y_i` 后，不是将其左移与前次部分积 `P_j` 相加，而是将部分积 `P_j` 右移一位与 `X × Y_i` 相加。
3.  **条件加法：** 对乘数中为“1”的位执行加法和右移运算；对为“0”的位只执行右移运算，不需执行加法。

**递推公式：**
`P_{i+1} = 2^{-1} (P_i + X × Y_{n-i})`  (i = 0, 1, ..., n-1)，初始 `P_0 = 0`。
其中 `Y_{n-i}` 是乘数从低位到高位的第 `i` 位。
运算过程：
*   `P_1 = 2^{-1} (P_0 + X × Y_n)`
*   `P_2 = 2^{-1} (P_1 + X × Y_{n-1})`
*   ...
*   `P_n = 2^{-1} (P_{n-1} + X × Y_1)`

**迭代过程：**
1.  取乘数的最低位 `Y_{n-i}` 判断。
2.  若 `Y_{n-i} = 1`，则将当前部分积 `P_i` 与被乘数 `X` 相加；若 `Y_{n-i} = 0`，则什么也不做（相当于加0）。
3.  将（可能加了X后的）部分积和乘数一起右移一位，产生本次迭代的部分积 `P_{i+1}`。
    ![[image-390.png]]
**硬件结构 (图3.19 - 32位无符号数乘法)：**
*   **被乘数寄存器 X：** 存放被乘数。
*   **乘积寄存器 P (高位部分)：** 初始为0；结束时存放64位乘积的高32位。
*   **乘数寄存器 Y (低位部分)：** 初始为乘数；结束时存放64位乘积的低32位。P和Y逻辑上组成一个64位寄存器。
*   **进位触发器 C：** 保存加法器的进位信号。
*   **计数器 Ct：** 存放循环次数，初值为n，每循环一次减1，当Ct=0时运算结束。
*   **ALU：** 执行 P+X 操作。
*   **控制逻辑：**
    *   根据Y的最低位决定是否将X加到P。
    *   控制P和Y的同步右移（C的内容移入P的最高位，P的最低位移入Y的最高位，Y的最低位移出，0移入C）。
*   **流程图 (图3.20)：**
	* ![[image-391.png]]
    1.  初始化：C=0, P=0, X=被乘数, Y=乘数, Ct=n。
    2.  判断Y的最低位 (Y0)。
    3.  若 Y0=1，则 C,P = P+X。
    4.  C,P,Y 逻辑右移一位。
    5.  Ct = Ct-1。
    6.  若 Ct≠0，转到步骤2。否则结束。

*   **示例 (例3.7):** `[X]_原 = 0.1101`, `[Y]_原 = 0.1011`，计算 `[X×Y]_原`。
    *   符号位：`0 ⊕ 0 = 0`。
    *   数值部分 (1101 × 1011) 的无符号乘法过程 (C, P, Y 的变化)：
        | C   | P    | Y    | 说明                     |
        |-----|------|------|--------------------------|
        | 0   | 0000 | 1011 | P0=0                     |
        |     | +1101|      | Y0=1, +X                 |
        | 0   | 1101 |      |                          |
        | 0   | 0110 | 1101 | C,P,Y 右移一位, 得 P1     |
        |     | +1101|      | Y0=1, +X                 |
        | 1   | 0011 |      |                          |
        | 0   | 1001 | 1110 | C,P,Y 右移一位, 得 P2     |
        |     | +0000|      | Y0=0, +0                 |
        | 0   | 1001 |      |                          |
        | 0   | 0100 | 1111 | C,P,Y 右移一位, 得 P3     |
        |     | +1101|      | Y0=1, +X                 |
        | 1   | 0001 |      |                          |
        | 0   | 1000 | 1111 | C,P,Y 右移一位, 得 P4     |
    *   乘积数值为 P 和 Y 组成：`10001111`。
    *   最终结果：`[X×Y]_原 = 0.10001111`。
    *   注意：当被乘数或乘数中至少一个为全0时，结果直接得0，不再进行乘法运算。

*   **2. 原码两位乘法**
    *   为了提高速度，可以对乘数的每两位取值情况进行判断，每步求出对应两位的部分积。
    *   考察乘数每两位 `Y_{i-1}Y_i` 的组合及对应的部分积操作：
        *   `00`: `P_{i+1} = 2^{-2} (P_i + 0)`
        *   `01`: `P_{i+1} = 2^{-2} (P_i + X)`
        *   `10`: `P_{i+1} = 2^{-2} (P_i + 2X)`  (`2X` 通过X左移1位实现)
        *   `11`: `P_{i+1} = 2^{-2} (P_i + 3X)`
    *   **处理 `+3X`:**
        *   方法一：分两次加法（+X 和 +2X）。
        *   方法二：`3X = 4X - X`。本次运算只执行 `-X`，而 `+4X` 延迟到下一次执行。这需要一个触发器T记录是否需要在下次执行 `+X`。
            *   若 `P_{i+1} = 2^{-2}(P_i + 3X) = 2^{-2}(P_i - X + 4X) = 2^{-2}(P_i - X) + X`。
            *   实际操作中根据 `Y_{i-1}, Y_i` 和 `T` 三位来控制乘法操作 (见表3.3)。
    *   **数值表示：** 因为涉及加减运算和 `2X` (可能导致数值左移一位)，需要使用补码运算，并在无符号数前添加符号位。为防止左移和加法溢出，部分积和被乘数通常采用3位符号位（模8补码）操作。
    *   **示例 (例3.8):** `[X]_原 = 0.111001`, `[Y]_原 = 0.100111`。
        *   `[|X|]_补 = 000111001`, `[|2X|]_补 = 001110010`, `[-|X|]_补 = 111000111`。
        *   运算过程（P, Y, T 的变化，每次右移两位）：
            | P             | Y        | T | 说明                            |
            |---------------|----------|---|---------------------------------|
            | 000 000000    | 100111   | 0 | P0=0, T=0                       |
            | +111 000111   |          |   | Y1Y0T=110, -X, T=1              |
            | 111 000111    |          |   |                                 |
            | 111 110001    | 111001   | 1 | P,Y 右移两位, 得 P1             |
            | +001 110010   |          |   | Y3Y2T=011, +2X, T=0             |
            | 001 100011    |          |   |                                 |
            | 000 011000    | 111110   | 0 | P,Y 右移两位, 得 P2             |
            | +001 110010   |          |   | Y5Y4T=100, +2X, T=0             |
            | 010 001010    |          |   |                                 |
            | 000 100010    | 101111   | 0 | P,Y 右移两位, 得 P3             |
        *   加上符号位，结果 `0.100010101111`。
    *   两位乘法比一位乘法循环次数减半，速度加快。

---

### 3.3.5 补码乘法运算

补码作为机器中带符号整数的表示形式，需要计算机能实现定点补码整数的乘法运算。

**1. 补码一位乘法 (Booth算法)**
*   **直接用补码相乘的问题：**
    *   若 `X>0, Y>0`，则 `[X×Y]_补 = [X]_补 × [Y]_补` 成立。
    *   否则不一定成立。例如 `X=+1011, Y=-0001`，则 `[X]_补=01011, [Y]_补=11111`。
        `[X×Y]_补 = [-1011]_补 = 111110101`。
        `[X]_补 × [Y]_补 = 01011 × 11111 = 101010101`。两者不等。
*   **Booth算法：** A. D. Booth提出的一种补码相乘算法，可以将符号位与数值位合在一起参与运算，直接得出用补码表示的乘积，且正数和负数同等对待。
*   **Booth算法递推公式推导：**
    设 `[X]_补` 和 `[Y]_补` 是两个n位 (偶数位) 补码整数。
    `Y` 的真值 = `-y_{n-1}2^{n-1} + Σ_{i=0}^{n-2} y_i 2^i`
            `= Σ_{i=0}^{n-1} (y_{i-1} - y_i) 2^i`  (假设 `y_{-1}=0`)
    则 `[X×Y]_补 = [X × Σ_{i=0}^{n-1} (y_{i-1} - y_i) 2^i]_补`
    展开后得到递推公式：
    `[P_{i+1}]_补 = [2^{-1} (P_i + (y_{i-1} - y_i)X)]_补`  (i = 0, 1, ..., n-1)
    其中 `P_0=0`。最终 `[X×Y]_补 = 2^n [P_n]_补` (即 `P_n` 左边的n位是乘积)。
*   **运算规则 (根据 `y_i y_{i-1}` 的值判断)：**
    *   `y_i y_{i-1} = 00` 或 `11`：部分积加 `0 × X`。
    *   `y_i y_{i-1} = 01`：部分积加 `1 × X`。
    *   `y_i y_{i-1} = 10`：部分积加 `-1 × X` (即 `+ [-X]_补`)。
    *   每次加减后，部分积和乘数一起进行 **算术右移** 一位。
    *   需在乘数最低位后增加一位辅助位 `y_{-1}`，初始为0。
*   **硬件结构 (图3.22 - 32位补码一位乘法)：** 类似原码乘法，但：
	* ![[image-393.png]]
    *   ALU需要执行加法和减法。
    *   右移是算术右移。
    *   控制逻辑根据 `Y_0` 和 `Y_{-1}` 判断操作。
*   **流程图 (图3.21)：**
	* ![[image-392.png]]
    1.  初始化：`P=0`, `Y_{-1}=0`, `X=被乘数`, `Y=乘数`, `Ct=n`。
    2.  判断 `Y_0 Y_{-1}` 的值。
        *   `01`: `P = P+X`。
        *   `10`: `P = P+[-X]_补`。
        *   `00`或`11`: 不操作。
    3.  P, Y, Y<sub>-1</sub> 算术右移一位。
    4.  Ct = Ct-1。
    5.  若 Ct≠0，转到步骤2。否则结束。
*   **示例 (例3.9):** `[X]_补 = 1101` (-3), `[Y]_补 = 0110` (+6)。计算 `[X×Y]_补`。
    *   `[-X]_补 = 0011`。
    *   运算过程 (P, Y, Y<sub>-1</sub> 的变化)：
        | P    | Y    | Y<sub>-1</sub> | 说明                             |
        |------|------|----------------|----------------------------------|
        | 0000 | 0110 | 0              | P0=0, Y<sub>-1</sub>=0             |
        |      |      |                | Y0Y<sub>-1</sub>=00, P不变         |
        | 0000 | 0011 | 0              | 算术右移, P1                      |
        | +1101|      |                | Y0Y<sub>-1</sub>=10, P = P+[-X]    |
        | 1101 |      |                |                                  |
        | 1110 | 1001 | 1              | 算术右移, P2                      |
        | +0011|      |                | Y0Y<sub>-1</sub>=11, P不变 (错误,应为01,P=P+X)  |
        |      |      |                | *教材此处有误，Y0Y<sub>-1</sub>=11时P不变，但上一步是Y0=1, Y-1=0, 所以是P=P+[-X], 得到1101。再右移为1110, Y=1001, Y-1=1。此时 Y0Y-1 = 11, P不变。*  |
        |      |      |                | *按正确逻辑：Y0Y<sub>-1</sub>=11, P不变*  |
        | 1111 | 0100 | 1              | 算术右移, P3                      |
        | +1101|      |                | Y0Y<sub>-1</sub>=01, P = P+X       |
        | 1110 | 1001 |                |                                  |
        | 1110 | 1100 | 1              | 算术右移, P4                      |
    *   结果：`P` 和 `Y` 组成 `11101110`。(-18)
    *   Booth算法对于连续的1或0可以跳过加法，效率较高。

*   **2. 补码两位乘法 (改进Booth算法 / MBA / Radix-4 Booth)**
    *   将补码一位乘法的推导扩展，每次考察乘数的三位 `y_{i+1} y_i y_{i-1}` 来决定操作。
    *   `[P_{i+2}]_补 = 2^{-2} ([P_i]_补 + (y_{i-1} + y_i - 2y_{i+1})[X]_补)`
    *   **运算规则 (根据 `y_{i+1} y_i y_{i-1}` 的值判断，见表3.4)：**
        *   `000` 或 `111`: 部分积加 `0 × X`。
        *   `001` 或 `010`: 部分积加 `1 × X`。
        *   `011`: 部分积加 `2 × X`。
        *   `100`: 部分积加 `-2 × X` (即 `+ [-2X]_补`)。
        *   `101` 或 `110`: 部分积加 `-1 × X` (即 `+ [-X]_补`)。
    *   `±2X` 通过 `X` 左移一位实现。因为左移可能改变符号，数值部分需要使用两位符号位。
    *   每次部分积和乘数一起 **算术右移两位**。
    *   初始时，附加位 `y_{-1}=0`，乘积寄存器P最高位前添加一位附加符号位0。
    *   因为字长总是8的倍数，补码位数n为偶数，总循环次数为 n/2。
   
---

### *3.3.6 快速乘法器

*   **阵列乘法器 (Array Multiplier):**
    *   基于手算乘法的“移位与求和”算法，用硬件组合逻辑实现。
    *   **4x4位无符号数手算过程 (图3.23):** 产生4行部分积，每行是 `X_i Y_j`，并错位相加。
	    * ![[image-394.png]]
    *   **4x4位基于CRA的阵列乘法器 (图3.24):**
	    * ![[image-395.png]]
        *   每个 `X_i Y_j` 用一个与门实现。
        *   每行用一组全加器 (FA) 实现与上一行部分积的相加。
        *   FA的空间错位实现了部分积的逻辑左移。
        *   整个电路的延迟取决于加法阵列的结构。若基于CRA，则每一级部分积的生成依赖上一级的最终进位，速度慢。
    *   **基于CSA的阵列乘法器 (图3.25 - 6x6位):**
	    * ![[image-396.png]]
        *   **进位保留加法器 (Carry Save Adder, CSA):** 将本级进位与本级和一样同时输出至下一级，而不是向前传递到本级的下一位。求和速度快，且向下级传递的速度与字长无关。
        *   结构规范，标准化程度高，适合大规模集成电路实现。
    *   **华莱士树 (Wallace Tree, WT):**
        *   阵列乘法器至少要做 O(N) 次加法。
        *   WT是一种树形结构，用于减少部分积求和的级数，将N行部分积通过多级CSA压缩到两行，最后用高速加法器（如CLA）求和。
        *   WT结构只需做 O(logN) 次加法，速度快。
        *   可将改进Booth算法 (MBA，减少部分积个数) 和WT (缩短部分积求和时间) 结合，进一步加快乘法速度。

---

### 3.3.7 原码除法运算

在进行定点数除法运算前，需要进行判断：
1.  若被除数为0，除数不为0，或定点整数除法时 `|被除数| < |除数|`，则商为0。
2.  若被除数不为0，除数为0，则发生“除数为0”异常。
3.  若被除数和除数都为0，有些机器产生NaN (quiet NaN)。
只有当被除数和除数都不为0，且商不可能为0时，才进行除法运算。

**手算除法步骤 (10011101 ÷ 1011):**
```
        1110   (商)
      _______
1011 |10011101 (被除数)
      -1011      (够减，商1)
      -----
       00001
         -0      (不够减，商0，将除数右移一位)
         ----
          0011
           -0    (不够减，商0)
           ---
           0111
           -1011 (够减，商1) (错误，这里应该是00111，不够减，商0)
           ----
            00110
            -1011 (够减，商1)
            ----
             0011  (余数)
```
*   **基本要点：**
    1.  被除数（或中间余数）与除数相减，若够减，则上商为1；若不够减，则上商为0。
    2.  每次得到的差为中间余数。
    3.  用中间余数减去除数（逻辑上是除数右移后与上次中间余数比较）。

**计算机实现原码除法：**
*   符号位与数值位分开处理。商的符号为两数符号的“异或”值，商的数值为两数绝对值之商。
*   **硬件结构 (图3.26 - 32位除法)：** 类似于乘法。
	* ![[image-397.png]]
    *   **除数寄存器 Y：** 存放除数。
    *   **余数寄存器 R (高位部分)：** 初始为被除数高32位；结束时存放余数。
    *   **余数/商寄存器 Q (低位部分)：** 初始为被除数低32位；结束时存放32位商。R和Q逻辑上组成一个64位寄存器，存放被除数或中间余数。
    *   **计数器 Ct：** 存放循环次数。
    *   **ALU：** 执行 R-Y 操作。
    *   **控制逻辑：**
        *   根据ALU运算结果的符号位决定上商0还是1。
        *   控制R和Q的同步“左移”。Q的最高位移入R的最低位，Q的最低位补上商。
*   **被除数扩展：** n位定点数除法，是用一个2n位的数去除以一个n位的数，得到一个n位的商。
    *   **定点正整数相除 (单精度除法)：** 被除数X高位添n个0。R初值为0，Q初值为X。
    *   **定点正小数相除 (浮点数尾数)：** 被除数X低位添n个0。R初值为X，Q初值为0。若 `|被除数| ≥ |除数|`，则商的数值部分会溢出到小数点前。
    *   **双精度除法：** 被除数在两个寄存器中，无需扩展。商可能多于n位，可能溢出。

**根据余数恢复方式的不同，有“恢复余数法”和“不恢复余数法”。**

**1. 恢复余数法 (Restoring Division)**
运算步骤 (设被除数X为2n位，除数Y和商Q为n位)：
1.  **操作数预置：** R,Q = X, Y=除数。
2.  **试商：** `R = R - Y`。
3.  **上商并恢复余数：**
    *   若 `R < 0` (不够减)，则上商 `q_i = 0`，并恢复余数 `R = R + Y`。
    *   若 `R ≥ 0` (够减)，则上商 `q_i = 1`。
4.  **左移：** R,Q 左移一位，Q的最低位补上商 `q_i`。
5.  重复步骤2-4共n次。

*   **对于定点小数：** 第一次求得的商 `q_n` 是商的整数部分。若 `q_n=1`，则溢出。
*   **流程图 (图3.27)：**
	* ![[image-398.png]]
*   **示例 (例3.11):** `[X]_原 = 0.1011`, `[Y]_原 = 1.1101`。计算 `[X/Y]_原`。
    *   商的符号 `0⊕1=1`。
    *   数值部分 (0.1011 ÷ 0.1101)。R初值 `0.1011`, Q初值 `0000`。 `|Y|=0.1101`, `[-|Y|]_补=1.0011`。
    *   过程 (R, Q 的变化，符号位用一位表示)：
        ![[image-399.png]]
    *   商的最高位 `q4=0`，未溢出。商的数值为 `1101`。余数为 `0.0111 × 2^{-4}`。
    *   结果 `[X/Y]_原 = 1.1101`。
*   **示例 (例3.12):** 无符号整数 X=1101 (13), Y=1011 (11)。
    *   R初值 `00000`, Q初值 `1101`。
    *   ... (过程类似，注意R和Q的位数)
    *   商 `0001`，余数 `0010`。

**2. 不恢复余数法 (Non-Restoring Division / 加减交替法)**
当 `R_i = 2R_{i-1} - Y < 0` (不够减) 时，不恢复余数，而是利用 `R_{i+1} = 2(R_i+Y)-Y = 2R_i+Y`。
*   **算法要点：**
    *   若当前余数 `R_i ≥ 0`，则上商1，下次操作 `2R_i - Y`。
    *   若当前余数 `R_i < 0`，则上商0，下次操作 `2R_i + Y`。
*   **最后一步修正：** 如果最后一步上商为0 (即最后余数为负)，则必须恢复余数，将试商时减掉的除数加回去。
*   **流程图 (图3.28)：**
	* ![[image-400.png]]
*   **示例 (例3.13):** `[X]_原 = 0.1011`, `[Y]_原 = 1.1101`。
    * ![[image-401.png]]
    *   结果与恢复余数法相同。
*   **节省时间：** 第一次试商后，若余数为负，则直接左移并做加法，节省了一次加法操作。
*   n位定点整数除法，第一次无需试商，直接左移。

---

### *3.3.8 补码除法运算

补码除法也可以将符号位和数值位合在一起运算，商符直接在运算中产生。
需要对被除数进行符号扩展。

**判断是否够减的规则 (表3.5 / 根据加减前后余数符号变化)：**
1.  当被除数（或中间余数R）与除数Y **同号** 时，做 **减法** (`R = R-Y`)。
2.  当被除数（或中间余数R）与除数Y **异号** 时，做 **加法** (`R = R+Y`)。
3.  若加/减运算后得到的新余数符号与 **原余数R** 符号 **一致**，即余数符号未改变，表示 **够减**。
4.  若加/减运算后得到的新余数符号与 **原余数R** 符号 **不一致**，即余数符号改变，表示 **不够减**。

**1. 补码恢复余数除法**
1.  **预置：** 除数Y，被除数X (符号扩展后在R,Q)。
2.  **左移：** R,Q 同步左移一位。
3.  **试商并上商：**
    *   若R与Y同号，`R = R-Y`；否则 `R = R+Y`。
    *   若R和Q中的中间余数=0，或R操作前后符号未变，则够减，`q_0=1`。
    *   若R操作前后符号已变，则不够减，`q_0=0`，并恢复R值 (若减了Y则加回Y，若加了Y则减回Y)。
4.  重复2-3共n次。
5.  **商的修正：** 若被除数与除数同号，Q中是真商；否则，将Q求补。
6.  **余数在R中。**

*   **示例 (例3.14):** 7/3 和 -7/3 (4位补码)。
    *   7/3: `[X]_补=00000111`, `[Y]_补=0011`, `[-Y]_补=1101`。
        | R    | Q    | 操作                 | 说明                                     |
        |------|------|----------------------|------------------------------------------|
        | 0000 | 0111 |                      | R0=[X]                                   |
        | 0000 | 111  | 2R0 (左移)           | Q末位空出                                |
        | +1101|      | R,Y同号(0,0), R=R-Y |                                          |
        | 1101 | 111  | R符号变(0→1), q0=0  |                                          |
        | +0011|      | 恢复R                |                                          |
        | 0000 | 1110 |                      | 得R1, Q末位补0                           |
        | 0001 | 110  | 2R1 (左移)           |                                          |
        | +1101|      | R,Y同号(0,0), R=R-Y |                                          |
        | 1110 | 110  | R符号变(0→1), q0=0  |                                          |
        | +0011|      | 恢复R                |                                          |
        | 0001 | 1100 |                      | 得R2, Q末位补0                           |
        | 0011 | 100  | 2R2 (左移)           |                                          |
        | +1101|      | R,Y同号(0,0), R=R-Y |                                          |
        | 0000 | 1001 | R符号未变(0→0), q0=1| 得R3, Q末位补1                           |
        | 0001 | 001  | 2R3 (左移)           |                                          |
        | +1101|      | R,Y同号(0,0), R=R-Y |                                          |
        | 1110 | 001  | R符号变(0→1), q0=0  |                                          |
        | +0011|      | 恢复R                |                                          |
        | 0001 | 0010 |                      | 得R4, Q末位补0                           |
    *   商 `0010` (2)，余数 `0001` (1)。被除数与除数同号，商不需修正。
    *   -7/3: `[X]_补=11111001`, `[Y]_补=0011`, `[-Y]_补=1101`。 (过程类似)
        *   商 `1110` (-2)，余数 `1111` (-1)。被除数与除数异号，商 `1101` 求补得 `1110`。

**2. 补码不恢复余数除法 (加减交替法)**
1.  **预置。**
2.  **求第一位商 `q_n` (判断溢出)：** 若X与Y同号，`R1=X-Y`；否则 `R1=X+Y`。
    *   若新余数R1与Y同号，`q_n=1`。
    *   若新余数R1与Y异号，`q_n=0`。
    *   `q_n` 用来判断是否溢出，不是真商。
3.  **对于 i=1 到 n，求n位商：**
    *   若R与Y同号，`q_{n-i}=1`, `R_{i+1}=2R_i - Y`。
    *   若R与Y异号，`q_{n-i}=0`, `R_{i+1}=2R_i + Y`。
    *   Q寄存器左移一位，最低位补上商。
4.  **商的修正：** 最后一次Q左移，将`q_n`移出，最低位补`q_0`。若被除数与除数同号，Q中是真商；否则，Q的末位加1。
5.  **余数的修正：** 若余数R的符号与被除数X的符号不同，则：当被除数和除数符号相同时，最后余数加除数；否则，最后余数减除数。

*   **口诀：“同1减，异0加”。** (指上商和下次操作)
*   **示例 (例3.15):** X=-9, Y=2。`[X]_补=1111110111`, `[Y]_补=00010`, `[-Y]_补=11110`。
    *   过程 (R, Q 的变化)：
        | R     | Q     | 操作                | 说明                                        |
        |-------|-------|---------------------|---------------------------------------------|
        | 11111 | 10111 |                     | R0=[X] (符号扩展)                            |
        | +00010|       | R1=[X]+[Y] (X,Y异号)|                                             |
        | 00001 | 10111 | R1,Y同号, q5=1      |                                             |
        | 00011 | 0111  | 2R1, 左移Q并补q5=1  |                                             |
        | +11110|       | R2=2R1+[-Y] (R,Y同号)|                                             |
        | 00001 | 0111  | R2,Y同号, q4=1      |                                             |
        | 00010 | 1111  | 2R2, 左移Q并补q4=1  |                                             |
        | +11110|       | R3=2R2+[-Y] (R,Y同号)|                                             |
        | 00000 | 1111  | R3,Y同号, q3=1      |                                             |
        | 00001 | 1111  | 2R3, 左移Q并补q3=1  |                                             |
        | +11110|       | R4=2R3+[-Y] (R,Y同号)|                                             |
        | 11111 | 1111  | R4,Y异号, q2=0      |                                             |
        | 11111 | 11110 | 2R4, 左移Q并补q2=0  |                                             |
        | +00010|       | R5=2R4+[Y] (R,Y异号) |                                             |
        | 00001 | 11110 | R5,Y同号, q1=1      |                                             |
        | 00011 | 11101 | 2R5, 左移Q并补q1=1  |                                             |
        | +11110|       | R6=2R5+[-Y] (R,Y同号)|                                             |
        | 00001 | 11101 | R6,Y同号, q0=1      |                                             |
        |       | 11100 | Q左移一位,补q0=1    | 商的符号位q5=1 (负)                         |
        |       | +   1 |                     | X,Y异号, 商末位加1                          |
        |       | 11100 |                     | 最终商为 11100 (-4)                         |
        | 11111 |       | R符号(1)与X符号(1)同 | 余数R=00001。需修正: R符号(0)与X符号(1)不同。 |
        |       |       |                     | *教材此处余数R6=00001，与X=11111异号，X,Y异号，则R6=R6-Y。* |
        |       |       |                     | *按正确逻辑：R=00001。R与X异号，X与Y异号，余数R=R-Y = 00001-00010 = 11111 (-1)* |
    *   结果 `[X/Y]_补 = 11100` (-4)，余数 `11111` (-1)。 -9 = 2×(-4) + (-1)。

---

### *3.3.9 阵列除法器

与乘法类似，除法运算也可以采用专门的阵列除法器实现。
*   **可控加减单元 (CAS - Controllable Adder/Subtractor) (图3.29a):**
    *   输入：一位数x, y, 低位进/借位ci, 控制信号p。
    *   输出：一位结果s, 高位进/借位co。
    *   `s = x ⊕ (p⊕y) ⊕ ci`
    *   `co = (x⊕ci)(p⊕y) + xci` (教材公式有误，应为全加器的进位 `co = (x⊕(p⊕y))ci + x(p⊕y)`)
    *   当 `p=0`，CAS作全加器。
    *   当 `p=1`，输入y被取反，CAS作全减器（若ci也接p，则实现y取反末位加1）。
*   **基于CAS的阵列除法器 (对两个正数按不恢复余数法相除) (图3.29b):**
    *   每行最高位单元的p和最低位单元的ci连在一起。
    *   第一行控制线p固定为1（第一次总是做减法）。
    *   每行最高位CAS的进位输出co即为中间余数的符号，决定对应位的商q<sub>i</sub>以及下一行的控制位p。
        *   若 `co=1` (正，够减)，则 `q_i=1`，下一行 `p=1` (做减法)。
        *   若 `co=0` (负，不够减)，则 `q_i=0`，下一行 `p=0` (做加法)。

这个笔记总结了定点数的各种运算方法及其实现原理，包括补码、原码、移码的加减运算，以及原码和补码的乘除法（一位和两位），并简要介绍了快速乘法器和阵列除法器的概念。