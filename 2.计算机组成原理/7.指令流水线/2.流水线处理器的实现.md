好的，这是关于“7.2 流水线处理器的实现”的学习笔记：

## 7.2 流水线处理器的实现

**目标**：实现一个支持11条MIPS指令（与第6章单周期、多周期处理器相同）的流水线处理器。

### 7.2.1 每条指令的流水段分析

设计流水线的第一步是分析每条指令的执行过程，确定各功能段及其执行时间。

**公共前两段**：
*   **Ifetch (取指)**: 取指令并计算 PC+4。
*   **Reg/Dec (寄存器取数/译码)**: 寄存器取数并译码。

**后续功能段因指令类型而异**：

1.  **R-型指令功能段划分** (如 add, sub)：
    *   **Ifetch**
    *   **Reg/Dec**
    *   **Exec (执行)**: 在 ALU 中对 Rs 和 Rt 内容进行运算。 (add, sub 还需判断溢出)
    *   **Write (写回)**: 将 ALU 运算结果写回目的寄存器 Rd。
    *   *(图 7.2: Ifetch -> Reg/Dec -> Exec -> Write)
	    * ![[image-281.png]]
    
2.  **I-型运算类指令功能段划分** (如 addi, ori)：
    *   对16位立即数进行符号扩展或零扩展，然后和 Rs 内容运算，结果送目的寄存器 Rt。
    *   流水段划分与R-型指令相同： **Ifetch -> Reg/Dec -> Exec -> Write**

3.  **lw (加载字) 指令功能段划分**: R[Rt] <- M[R[Rs] + SignExt(imm16)]
    *   **Ifetch**
    *   **Reg/Dec**
    *   **Exec (执行)**: 在 ALU 中计算地址 (R[Rs] + SignExt(imm16))。
    *   **Mem (访存)**: 从存储器中读数据。
    *   **Write (写回)**: 将数据写入寄存器 Rt。
    *   *(图 7.3: Ifetch -> Reg/Dec -> Exec -> Mem -> Write)*

4.  **sw (存储字) 指令功能段划分**: M[R[Rs] + SignExt(imm16)] <- R[Rt]
    *   **Ifetch**
    *   **Reg/Dec**
    *   **Exec (执行)**: 在 ALU 中计算地址 (R[Rs] + SignExt(imm16))。
    *   **Mem (访存)**: 将寄存器 Rt 内容写入存储器。
    *   *(与 lw 相比，少了一步写寄存器的工作)*
    *   *(图 7.4: Ifetch -> Reg/Dec -> Exec -> Mem)*
	    * ![[image-282.png]]

5.  **beq (条件分支) 指令功能段划分**: if (R[Rs] == R[Rt]) then PC <- PC+4 + (SignExt(imm16) << 2) else PC <- PC+4
    *   **Ifetch**
    *   **Reg/Dec**
    *   **Exec (执行)**: ALU 做减法比较 Rs 和 Rt 是否相等；同时用加法器计算转移目标地址。
    *   **WrPC (写PC)**: 若相等，则将转移目标地址写入 PC。（WrPC 操作时间比 Mem 短）
    *   为了规整，可以将 WrPC 向 Mem 段靠拢，即**最后的功能段用 Mem 表示**。
    *   功能段划分类似 sw 指令：**Ifetch -> Reg/Dec -> Exec -> Mem** (如图 7.4)

6.  **j (无条件跳转) 指令功能段划分**: PC <- TargetAddress
    *   **Ifetch**
    *   **Reg/Dec**
    *   **WrPC (写PC)**: 直接将目标地址送 PC。（WrPC 操作时间比 Exec 短）

**统一流水段 (插入“空”段)**：
*   最复杂的指令是 `lw`，有5个功能段。
*   为了使所有指令都有5个功能段，需要为其他指令插入“空”功能段，使其与 `lw` 指令对齐。
*   **插入“空”段的原则**:
    1.  每个功能部件每条指令只能用一次（如寄存器写口不能用两次）。
    2.  每个功能部件必须在相同的阶段被使用（如寄存器写口总是在第5阶段）。
*   **具体对齐**：
    *   R-型、I-型运算类指令：在 Write 前加入一个空的 "Mem" 段。 (Ifetch -> Reg/Dec -> Exec -> **Mem(空)** -> Write)
    *   sw、beq 指令：在 Mem 段后加入一个空的 "Write" 段。 (Ifetch -> Reg/Dec -> Exec -> Mem -> **Write(空)**)
    *   j 指令：在 WrPC (可看作 Exec 或 Mem) 后添加空的 "Mem" 和 "Write" 段（或调整 WrPC 位置并补空段）。
*   最终，所有指令都可以设计成 **5个流水段**。

### 7.2.2 流水线数据通路的设计

*   每条指令经历 IF, ID, Ex, Mem, Wr 五个流水段，在不同功能部件中执行。
*   流水段之间设置 **流水段寄存器** (Pipeline Registers)，如 IF/ID 寄存器。
*   流水段寄存器用于存放从当前流水段传递到后续流水段的所有信息。
*   不同流水段寄存器的长度可能不同，因为段间传递的信息不同。
*   *(图 7.5: 5段流水线数据通路基本框架)*
	* ![[image-283.png]]

**各流水段的功能、部件、传递信息及控制信号**：

**公共部分（前两段无独立控制信号，因功能固定）**：
*   PC 和流水段寄存器没有写使能信号，因为它们每个时钟周期都会更新。

**Exec 段的控制信号 (5个)**：
*   **ExtOp (扩展器操作)**: 1-符号扩展; 0-零扩展。
*   **ALUSrc (ALU的B口来源)**: 1-来源于扩展器; 0-来源于 busB (寄存器堆读出端口)。
*   **ALUOp (ALU操作控制)**: 三位编码，辅助局部 ALU 控制逻辑决定 ALUCtr 信号。
*   **RegDst (指定目的寄存器)**: 1-Rd (R-型); 0-Rt (I-型/lw)。
*   **R-Type (区分是否为R-型指令)**: 1-R-型指令; 0-非R-型指令。

**Mem 段的控制信号 (2个)**：
*   **MemWr (数据存储器DM的写信号)**: sw 指令时为1, 其他为0。
*   **Branch (是否为分支指令)**: 分支指令时为1, 其他为0。

**Wr 段的控制信号 (2个)**：
*   **MemtoReg (寄存器的写入源)**: 1-DM输出 (lw); 0-ALU输出 (R-型/I-型运算)。
*   **RegWr (寄存器堆写信号)**: 结果写寄存器的指令为1, 其他为0。

**各流水段详解**：

1.  **Ifetch (IF) 段**：
    *   **功能**: 将 PC 值作为地址到指令存储器 IM 取指令，并计算 PC+4 送 PC 输入端。
    *   **部件**: 取指部件 (IUnit)。
    *   *(图 7.6: IUnit 内部实现)*
	    * ![[image-284.png]]
        *   PC 输入端来自一个多路选择器，用于处理顺序执行 (PC+4) 和转移 (目标地址)。
    *   **IF/ID 寄存器保存信息**:
        *   从 IM 取出的指令。
        *   PC+4 的值 (若当前指令是分支指令，后续流水段需要用它计算相对转移地址)。
    *   **控制**: PC 输入的多路选择器由 Mem 段产生的 Branch 信号和 Zero 标志控制。在 IF 阶段，Branch=0，选择 PC+4。

2.  **Reg/Dec (ID) 段**：
    *   **功能**: 根据指令中的 Rs 和 Rt 字段从寄存器堆取出相应值；对指令操作码 op 字段译码，生成控制信号。
    *   **部件**: 寄存器堆读口、控制器。
    *   **ID/Ex 寄存器保存信息**:
        *   Reg[Rs], Reg[Rt] (寄存器内容)
        *   Rt, Rd (目标寄存器/源寄存器编号)
        *   imm16 (立即数)
        *   func 字段 (R-型指令)
        *   PC+4
        *   *(指令本身不再需要传递，因为所需信息已提取)*
    *   *(控制器实现在 7.2.3 节介绍)*

3.  **Exec (Ex) 段**：
    *   **功能**: 由具体指令和 ID 段译码得到的控制信号确定，控制执行部件操作。
    *   **部件**: 执行单元 (Exec Unit)，包括 ALU、加法器 (用于beq地址计算)、扩展器、多路选择器等。
    *   *(图 7.7: Exec Unit 内部实现)*
	    * ![[image-285.png]]
    *   **各类指令在 Ex 段的功能及控制信号取值**:
        *   **(1) R-型指令 (add, sub, subu, slt, sltu)**:
            *   ALU 对 busA 和 busB 数据运算，结果送 ALUout，产生 Zero 和 Overflow 标志。
            *   控制信号: RegDst=1, ExtOp=x (不关心), ALUSrc=0, ALUop=xxx (由func决定), R-type=1。
        *   **(2) I-型运算类指令 (ori, addiu)**:
            *   ALU 对立即数扩展后数据与 busA 数据运算，结果送 ALUout，产生 Zero 和 Overflow 标志。
            *   ori: RegDst=0, ExtOp=0 (零扩展), ALUSrc=1, ALUop=or, R-type=0。
            *   addiu: RegDst=0, ExtOp=1 (符号扩展), ALUSrc=1, ALUop=addu, R-type=0。
        *   **(3) lw/sw 指令**:
            *   ALU 对立即数符号扩展后数据与 busA 数据进行加法运算，得到存储器地址送 ALUout。
            *   lw: RegDst=0 (目的寄存器是Rt), ExtOp=1, ALUSrc=1, ALUop=addu, R-type=0。
            *   sw: RegDst=x (不写寄存器), ExtOp=1, ALUSrc=1, ALUop=addu, R-type=0。
        *   **(4) beq 指令**:
            *   ALU 对 busA 和 busB 数据做减法，产生 Zero 标志。
            *   同时，立即数符号扩展、左移两位后与 PC+4 相加，得到转移目标地址。
            *   控制信号: RegDst=x (不写寄存器), ExtOp=1, ALUSrc=0, ALUop=subu, R-type=0。
        *   **(5) j 指令**:
            *   生成32位转移目标地址 (PC<31:28> || target<25:0>)。
            *   控制信号: RegDst=x, ExtOp=x, ALUSrc=x, ALUop=xxx, R-type=x。
    *   **Ex/Mem 寄存器保存信息**: ALU 运算结果 (ALUout), Zero 标志, Overflow 标志 (若有), 转移目标地址 (beq/j), Reg[Rt] (sw用), 目的寄存器编号 (Rd或Rt)。

4.  **Mem 段**：
    *   **功能**: 由具体指令确定。
    *   **控制信号**: Branch, MemWr。
    *   **各类指令在 Mem 段的功能及控制信号取值**:
        *   **(1) R-型或 I-型运算类指令**: “空”操作，传递信息。
            *   控制信号: Branch=0, MemWr=0。
        *   **(2) lw 指令**: 取数操作。Ex 段得到的地址送 DM 读地址端 RA，数据从 Do 输出。
            *   控制信号: Branch=0, MemWr=0。
        *   **(3) sw 指令**: 存数操作。Ex 段得到的地址送 DM 写地址端 WA，Ex/Mem 传来的 Reg[Rt] 送 Di。
            *   控制信号: Branch=0, MemWr=1。
        *   **(4) beq 或 j 指令**: 更新 PC。Ex 段生成的转移目标地址更新到 PC (通过图7.5和7.7中的数据通路)。
            *   beq: Branch=1, MemWr=0。若 Ex 段 Zero=1，则 PC 输入选择器选择转移目标地址。
    *   **Mem/Wr 寄存器保存信息**: 从 DM 读出的数据 (lw), ALU 运算结果 (R-型/I-型), 目的寄存器编号。

5.  **Wr 段**：
    *   **功能**: 由具体指令确定，主要涉及写寄存器堆。
    *   **部件**: 寄存器堆写口，多路选择器 (选择写入数据来源)。
    *   **控制信号**: MemtoReg, RegWr。
    *   **各类指令在 Wr 段的功能及控制信号取值**:
        *   **(1) R-型或 I-型运算类指令**: 将 ALU 输出结果写入目的寄存器。
            *   控制信号: MemtoReg=0, RegWr=1。
        *   **(2) lw 指令**: 将 DM 读出结果写入目的寄存器。
            *   控制信号: MemtoReg=1, RegWr=1。
        *   **(3) sw、beq 或 j 指令**: 不写寄存器。
            *   控制信号: MemtoReg=x, RegWr=0。

### 7.2.3 流水线控制器的设计

*   **控制信号的传递**: 某一时刻，不同流水段执行的是不同指令的不同阶段，因此每个流水段的控制信号应是**正在该段执行的指令所对应的功能段的控制信号**。
*   *(图 7.8: 流水线执行情况举例 - lw, ori, add 指令)*
	* ![[image-287.png]]
    *   指令在 ID (Reg/Dec) 段译码产生控制信号。
    *   这些控制信号随指令流经后续流水段时被使用：
        *   Exec 阶段的信号 (RegDst, ExtOp, ALUSrc, ALUop, R-type) 在**下一个周期** (Ex段) 使用。
        *   Mem 阶段的信号 (MemWr, Branch) 在**随后第二个周期** (Mem段) 使用。
        *   Write 阶段的信号 (MemtoReg, RegWr) 在**随后第三个周期** (Wr段) 使用。
*   **控制信号的存储**: 各流水段寄存器中需要保存相应的控制信号，与数据信息同步传递。
    *   *(图 7.9: 控制信号在流水线中的传递)*
	    * ![[image-288.png]]
*   **控制器设计**:
    *   控制信号一旦在 ID 段由控制器生成，就不会改变。
    *   这与单周期控制器的设计类似，可以完全按照单周期控制器设计的思路进行。
    *   与多周期控制器（采用有限状态机）不同。

**总结**：流水线处理器的实现关键在于将指令执行划分为均衡的流水段，设计好数据通路和流水段寄存器来传递数据和控制信号，并确保控制信号在正确的时机作用于相应的流水段。