好的，这是关于“7.4 高级流水线技术”的学习笔记：

## 7.4 高级流水线技术

高级流水线技术旨在充分利用**指令级并行 (Instruction-Level Parallelism, ILP)** 来进一步提高流水线的性能。主要有两种策略：

1.  **超流水线 (Super-pipelining)**
2.  **多发射流水线 (Multiple Issue Pipelining)**

### 超流水线 (Super-pipelining)

*   **核心思想**: 通过增加流水线的级数（将原有流水段划分得更细、更均匀）来使更多的指令同时在流水线中重叠执行。
*   **对 CPI 的影响**: 超流水线本身并**不改变理想 CPI 的值**，CPI 仍然是 1 (理想情况下)。
*   **性能提升原理**:
    *   理想情况下，流水线的加速比与流水段的数目成正比。
    *   流水段越多（流水线越深），每个流水段的延迟可以做得越小，从而可以**缩短时钟周期**。
    *   时钟周期缩短，意味着指令的吞吐率提高。
*   **与普通流水线的比较**: 超流水线的性能通常优于相同功能但级数较少的普通流水线。
*   **局限性**:
    *   流水线级数越多，用于流水段寄存器的开销（如建立时间、传输延迟）在整个时钟周期中所占的比例就越大。
    *   流水线级数不可能无限增加，存在一个最优的平衡点。

### 多发射流水线 (Multiple Issue Pipelining)

*   **核心思想**: 在一个时钟周期内同时启动（发射）多条指令，让它们在处理器内部的多个独立执行单元上并行运行，以提高指令并行性。
*   **处理器类型**: 采用多发射流水线技术的处理器称为**超标量 (Superscalar)** 处理器。
*   **前提条件**: 数据通路中必须有多个执行部件，例如多个定点 ALU、浮点运算单元、乘除法器、加载/存储单元等。
*   **对 CPI 的影响**: 多发射流水线的 CPI 能达到**小于 1**。
*   **IPC (Instructions Per Cycle)**: 由于 CPI 可能小于 1，有时用 CPI 的倒数 IPC 来衡量其性能。IPC 是指每个时钟周期内完成的指令条数。例如，一个 4 路多发射流水线的理想 IPC 为 4。

**实现多发射流水线的关键任务**：

1.  **指令打包 (Instruction Bundling/Packing)**:
    *   将能够并行处理的多条指令在同一时钟周期内同时发送到发射槽 (issue slots)。
    *   处理器需要知道每个周期能发射几条指令，以及哪些指令可以同时发射。
    *   依赖于**推测 (Speculation)** 技术：
        *   **软件推测**: 由编译器根据指令间的相关性进行静态分析和重排，使指令执行能达到最大可能的并行。
        *   **硬件推测**: 处理器在运行时动态预测指令执行结果，调整指令执行顺序。
        *   **推测的挑战**: 推测可能是错误的，需要有**错误检测和回退 (rollback)** 机制。当检测到推测错误时，能撤销被错误执行的指令及其影响。错误推测会导致额外开销。
        *   通常结合软件推测（静态重排，必须保证正确性）和硬件推测（动态调度）。

2.  **冒险处理 (Hazard Handling)**:
    *   多发射使得冒险的种类和复杂性增加。

**多发射技术的分类 (根据推测和打包任务由谁主要完成)**：

### *7.4.1 静态多发射处理器*

*   **核心特点**: 主要依靠**编译器**进行静态推测来辅助完成“指令打包”和“冒险处理”。
*   **指令包 (Issue Packet / Bundle)**: 同时发射的多条指令被编译器组合成一个“长指令”或“发射包”。
*   **VLIW (Very Long Instruction Word) 处理器**:
    *   静态多发射指令最初的实现形式。
    *   处理器架构中，指令字非常长，明确包含了多个可以并行执行的独立操作。
*   **EPIC (Explicitly Parallel Instruction Computing)**:
    *   Intel IA-64 架构采用的技术，是 VLIW 的一种演进。
    *   编译器显式地在指令中标记出并行性。
*   **硬件限制**: 数据通路中功能部件及其数量是确定的，因此一个时钟周期内发射的指令类型和数量是受限的。例如，若只有一个 ALU 和一个 Load/Store 单元，则一个周期最多发射一条 ALU/分支指令和一条 Load/Store 指令。
*   **冒险处理方式**:
    1.  **完全由编译器静态处理**: 通过代码调度和插入 `nop` 指令来消除所有冒险，硬件无需实现冒险检测和流水线阻塞。
    2.  **编译器静态预测 + 硬件检测数据冒险**: 编译器通过静态分支预测和代码调度来消除打包指令的内部依赖，而由硬件检测数据冒险并进行流水线阻塞。

*   **2-发射 MIPS 处理器示例 (静态调度)**：
    *   **硬件改进**:
        1.  **取指/译码**: 同时取/译码两条指令，可将两条指令打包成64位长指令。ALU/beq 指令在前，Load/Store 指令在后，无配对指令时用 `nop` 代替。64位长指令的两个操作码同时送控制器译码。
        2.  **寄存器堆**: 增加一个读口和一个写口，以支持两条指令可能同时读/写寄存器。
        3.  **执行单元**: 可能需要增加额外的 ALU 或加法器（如一条 ALU/beq 指令运算时，另一条 Load/Store 指令计算地址）。
        4.  **流水段寄存器**: 增宽，以分别传送两条指令的数据和控制信号。
    *   **性能与挑战**:
        *   理论性能可提高近两倍，但实际受限。
        *   **结构冒险**: 需要增加硬件部件来消除。
        *   **数据/控制冒险**: 一旦发生，会阻塞更多指令，性能损失更大（如 Load-use 冒险，单发射只延迟1条，2-发射可能延迟2条）。
        *   **ALU-Load/Store 数据冒险**: 单发射时，ALU 结果可转发给 Load/Store 的 Ex 段；但在2-发射时，两条指令同时进行，ALU 结果不能直接转发，Load/Store 需延迟一个周期。
        *   **编译器依赖**: 性能高度依赖编译器的静态调度能力，以充分消除指令依赖，最大化并行性。
    *   **循环展开 (Loop Unrolling)**: 一种重要的编译器静态调度技术。
        *   **思想**: 将循环体复制多份展开，然后在展开的指令序列中进行统筹调度，以减少循环控制开销和发掘更多并行性。
        *   *(图 7.25: 2-发射 MIPS 流水线的指令代码调度例子，CPI=0.8, IPC=1.25)*
        *   *(图 7.26 & 7.27: 循环展开4次的调度例子，CPI=8/14 ≈ 0.57)*
        *   **重命名寄存器**: 循环展开时，为避免伪相关（名字依赖），会使用更多的临时寄存器。
        *   **代价**: 代码长度增加，程序所占存储空间变大。

*   **Intel IA-64 的结构特点 (回顾)**：
    *   **寄存器**: 更多的寄存器 (128个整数，128个浮点，8个分支，64个谓词)。支持寄存器窗口重叠。
    *   **显式并行**: 编译器通过“指令组 (instruction group)”标记并行性（指令组内无寄存器级数据依赖）。“停止标记 (stop bit)”分隔指令组。
    *   **指令包 (Bundle)**: 128位长，包含一个5位模板字段和三个41位指令槽。模板字段指示三条指令的类型以及是否是指令组的结束。
    *   **谓词化 (Predication)**:
        *   指令的执行与否由一个谓词寄存器的状态决定，而不是传统的分支指令。
        *   指令格式中包含谓词寄存器编号。
        *   用于消除短小的 if-then-else 分支，提高并行度。
        *   例如 `if (p) {S1} else {S2}` 可编译为：
            *   `(p) S1`
            *   `(~p) S2`
            *   这两条指令可以完全独立并行执行。

### *7.4.2 动态多发射处理器*

*   **核心特点**: 在指令执行时由**处理器硬件动态地**进行流水线调度，完成“指令打包”和“冒险处理”，在一个时钟周期内执行一条以上指令。
*   **与静态多发射的比较**:
    *   **静态调度 (VLIW)**: 编译结果与具体机器结构密切相关。
    *   **动态调度**: 编译器仅进行指令顺序调整，不需根据具体机器结构打包指令，硬件决定发射时机和数量。
*   **性能**: 通常也需要编译器进行静态调度以尽量消除依赖，达到较高发射率。
*   **乱序执行 (Out-of-Order Scheduling/Execution)**:
    *   动态多发射处理器通常结合动态流水线调度技术。
    *   处理器通过指令相关性检测和动态分支预测等手段，**投机地 (speculatively)** 不按指令顺序执行。
    *   当发生流水线阻塞时，根据指令的依赖关系，动态地到指令流后面找一些没有依赖关系的指令提前执行。
*   **通用模型示意图**: *(图 7.28: 动态多发射流水线处理器的通用模型)*
	* ![[image-303.png]]
    1.  **指令预取和译码单元**: 预取指令，译码后放入指令队列。
    2.  **指令分派 (Dispatch) 器**: 分析指令功能和依赖关系，根据功能部件空闲情况，确定何时、发射哪条指令到哪个功能单元。
    3.  **功能单元 (Functional Units)**: 多个独立单元（整数加/乘/除，浮点加/乘/除，加载/存储等）。每个单元有自己的缓冲器 (保留站 - Reservation Station) 存储操作数和操作命令。
        *   **执行周期数 (Latency)**: 完成操作所需的时钟周期数。
        *   **发射时间 (Issue Time)**: 连续两次独立操作之间的最短周期数 (体现流水化程度)。
        *   *(表 7.1: Pentium II 的部分功能部件性能)*
    4.  **重排序缓冲 (ReOrder Buffer, ROB)**:
        *   用于保存已完成指令的结果，等待在可能的时候写回寄存器堆 (按序提交)。
        *   功能部件完成操作后，结果会送到等待该结果的保留站和 ROB。
        *   指令结果也可在 ROB 中被“转发”。
        *   当指令发射时，其源操作数可能来自寄存器堆或 ROB。
*   **动态多发射流水线的执行模式**:
    *   **按序发射，按序完成 (In-order issue, In-order completion)**: 所有阶段按序。
        *   *(图 7.30(a) & 例 7.5)*
        * ![[image-384.png]]
    *   **按序发射，乱序完成 (In-order issue, Out-of-order completion)**: 执行和写回阶段可乱序。
        *   *(图 7.30(b) & 例 7.5)*
        * ![[image-385.png]]
    *   **乱序发射，乱序完成 (Out-of-order issue, Out-of-order completion)**: 译码后的指令放入“指令窗口 (instruction window)”等待发射。当所需功能部件可用且无相关性阻碍时，即可从窗口发射。
        *   *(图 7.30(c) & 例 7.5)* 性能通常最高。
        * ![[image-386.png]]
*   **编译器静态调度的作用**: 即使是动态调度，编译器先进行静态调度，尽量消除依赖，可使流水线达到更高的动态发射速率。
    *   *(图 7.31: 静态调度后的乱序发射乱序完成)*
	    * ![[image-304.png]]

### *7.4.3 Pentium 4 处理器的流水线结构*

*   **"CISC壳，RISC核"**: x86 指令 (CISC) 被解码成类 RISC 的微操作 (µop)。
*   **踪迹高速缓存 (Trace Cache, TC)**: 存储解码后的 µop 序列，作为指令 Cache。
*   **超长流水线**: 对 µop 的执行采用约 20 级的超流水线技术。
    *   流水线级数多导致分支预测错误损失大，因此采用静态和动态两级分支预测。
*   **逻辑结构**: *(图 7.32: Pentium 4 处理器的逻辑结构)*
	* ![[image-305.png]]
    *   **前端 (Front End)**: 总线接口部件、预取控制逻辑、L2 Cache、指令预取部件、指令译码器、Trace Cache、微码 ROM、动态分支预测器 (BTB1, BTB2)、µop 缓冲队列。
    *   **乱序执行核心 (Out-of-Order Core)**: 资源分配/寄存器换名/µop 排队/调度/分派部件。
    *   **执行单元 (Execution Units)**: 多个整数和浮点执行单元，L1 数据 Cache。
    *   **退休单元 (Retirement Unit)**: ROB。
*   **µop 流水线 (20级)**: *(图 7.33: Pentium 4 µop 的20级流水线)*
	* ![[image-306.png]]
    *   **TC 下指针 (TC Next IP) (5级)**: 计算下次从 TC 取 µop 的指针，分支预测。
    *   **TC 取 (TC Fetch) (4级)**: 从 TC 取 µop 到 µop 队列。若复杂指令未转换，则从微码 ROM 取。
    *   **分配/换名 (Allocate/Rename) (5级)**: 为 µop 分配 ROB、物理寄存器等资源，进行寄存器换名。
    *   **µop 排队 (Queuing) (隐式)**: µop 进入各自功能单元的调度队列。
    *   **调度 (Schedule) (2级)**: 调度器检测 µop 数据相关性，确定执行顺序。
    *   **分派 (Dispatch) (1级)**: 将就绪的 µop 分派到功能单元，并读取物理寄存器。
    *   **寄存器文件 (Register File) (3级)**: 读取源操作数（若为内存数据，则从 L1-D Cache 旁路）。
    *   **执行 (Execute) (1级)**: 功能单元执行。
    *   **标志 (Flags) (1级)**: 建立标志位，结果写入物理寄存器。
    *   **分支检测 (Branch Check) (1级)**: 确认分支预测，修改 BTB2。
    *   **驱动 (Drive) (1级)**: 将结果驱动到 ROB。
*   **总结**: Pentium 4 结合了超长流水线、超标量（动态多发射）、乱序执行、分支预测、踪迹缓存等多种高级技术来提升性能。