好的，这是关于 "6.2 单周期处理器设计" 的学习笔记。

## 6.2 单周期处理器设计

处理器设计涉及数据通路的设计和控制逻辑的设计。
**设计过程:**
1.  **第一步：分析每条指令的功能。**
2.  **第二步：根据指令功能给出所需的元件，并考虑如何将它们互连。**
3.  **第三步：确定每个元件所需控制信号的取值。**
4.  **第四步：汇总各指令涉及的控制信号，生成反映指令与控制信号之间关系的关系表。**
5.  **第五步：根据关系表，得到每个控制信号的逻辑表达式，据此设计控制电路。**
本节以 MIPS 指令系统为例说明设计过程。

---
### 6.2.1 指令功能的描述

首先确认每条指令的功能。选择以下 11 条 MIPS 指令作为实现目标 (图 6.13 为 MIPS 指令格式)：
![[image-239.png]]
**5 条 R-型指令:**
*   `add rd, rs, rt`
*   `sub rd, rs, rt`
*   `subu rd, rs, rt`
*   `slt rd, rs, rt`
*   `sltu rd, rs, rt`
**5 条 I-型指令:**
*   `ori rt, rs, imm16`
*   `addiu rt, rs, imm16`
*   `lw rt, rs, imm16`
*   `sw rt, rs, imm16`
*   `beq rs, rt, imm16`
**1 条 J-型指令:**
*   `j target`
这些指令具有代表性，涵盖 R/I/J 型指令，算术/逻辑运算，取数/存数，条件/无条件转移，溢出判断，有/无符号数比较等。

**表 6.1 给出了 11 条目标指令功能的 RTL 描述:**
(每条指令的第一步都是取指令并 PC 加 4，表中除 add 指令外，其余指令省略了此步)

![[image-241.png]]
---

### 6.2.2 数据通路的设计

为简化设计，假定所用 **数据存储器** 和 **指令存储器** 均为 **理想存储器** (如图 6.14)：
	![[image-242.png]]
*   一个 32 位数据输入端 `Data In`。
*   一个 32 位数据输出端 `Data Out`。
*   一个读写公用的地址输入端 `Address`。
*   控制信号：写使能 `WE`。写操作受时钟 `Clk` 控制 (下降沿触发)。
*   读操作是组合逻辑：`Address` 有效后，经“取数时间”，`Data Out` 上数据有效。
*   写操作是时序逻辑：`WE=1` 且时钟下降沿到来，`Data In` 写入存储单元。

**1. 算术逻辑部件 (ALU) 的设计 (如图 6.15)**
![[image-243.png]]
为支持 11 条指令的运算，ALU 需具备：带溢出判断的加/减法、带/无符号整数大小判断、相等判断、逻辑运算 (按位或)。
*   **输入:** 两个 32 位操作数 A 和 B。
*   **核心:** 能进行加减运算的加法器 (输出和/差 `Add-Result`，进位 `Add-carry`，零标志 `Zero`，溢出 `Add-Overflow`，符号 `Add-Sign`)。
*   **输出:** 运算结果 `Result`，零标志 `Zero`，溢出标志 `Overflow`。
*   **ALU 操作控制 (ALUctr):**
    *   `SUBctr`: 控制加法(0)或减法(1)。
    *   `OPctr`: (两位) 选择哪种运算结果作为 `Result` 输出 (加减、按位或、小于置 1)。
    *   `OVctr`: 控制是否进行溢出判断 (1 为判断，结果溢出则 `Overflow` 为 1)。
    *   `SIGctr`: 控制执行“带符号数比较小于置 1”(1) 还是“无符号数比较小于置 1”(0)。

**表 6.2: 11 条指令对应的 4 种 ALU 操作控制信号取值**
![[image-244.png]]
(根据表 6.1 指令功能和 ALU 设计得出)
*   11 条指令可归纳为 7 种 ALU 操作: `add`、`sub`、`subu`、`slt`、`sltu`、`or`、`addu` (不判溢出的加法，用于 `addiu`、`lw`、`sw`、`beq` 地址计算)。
*   因此 `ALUctr` 至少需要 3 位。

**表 6.3: ALUctr 的三位编码及其对应的操作类型和 ALU 控制信号**
![[image-245.png]]
(一种优化编码方案，将加减、溢出、符号控制分配到不同位)
*   给出了 `SUBctr`、`OVctr`、`SIGctr`、`OPctr<1:0>` 的逻辑表达式 (基于 `ALUctr<2:0>`)。
*   **如果要实现更多指令 (如取负、取反、与、异或、或非)，需要扩展 ALU 逻辑电路，`OPctr` 和 `ALUctr` 的位数也需增加。**

**表 6.4: ALUctr 的四位编码 (支持更多操作) 及其对应的操作类型和 ALU 控制信号**
(`ALUctr<3>` 对应 `SUBctr`，`ALUctr<0>` 对应 `OVctr/SIGctr`)
![[image-246.png]]![[image-247.png]]
**2. 取指令部件的设计 (如图 6.16)**
![[image-248.png]]
每条指令第一步都是取指令并计算下条指令地址。
*   **假定:** 指令专门存放在 **指令存储器** 中，只有读操作 (组合逻辑，无须控制信号)。
*   给出指令地址，经“取数时间”，指令被送出。
*   **指令地址来自 PC。**
*   有专门的 **下地址逻辑** 计算下条指令地址，然后送 PC。
*   单周期处理器，每时钟执行一条指令，PC 每时钟更新一次 (无须写使能)。
*   **下地址逻辑:**
    *   **顺序执行:** PC+4。
    *   **转移执行:** 根据当前是分支指令还是跳转指令计算转移目标地址。

**3. R-型指令的数据通路 (如图 6.17)**
![[image-249.png]]
R-型指令对 Rs 和 Rt 内容运算，结果送 Rd。`add`、`sub` 等需判断溢出。
*   **连接:**
    *   寄存器堆的读地址端 Ra、Rb 分别与指令的 Rs、Rt 字段相连。
    *   寄存器堆的写地址端 Rw 与指令的 Rd 字段相连。
    *   ALU 运算结果连到寄存器堆的输入端 `busW`。
*   **控制信号:** `RegWr` (写使能)。当 `RegWr=1` 且不溢出时，结果写入寄存器堆。
*   **ALU 操作:** 5 种 (`add`、`sub`、`subu`、`slt`、`sltu`)，由 `ALUctr` 控制。
*   **定时:** 运算结果在下个时钟到来时开始写到寄存器堆。ALU 操作控制信号需保持稳定。

**4. 立即数运算指令的数据通路 (如图 6.18)**
I-型立即数运算指令 (`ori`、`addiu`) 涉及 16 位立即数扩展，然后与 Rs 内容运算，结果送 Rt。
![[image-250.png]]
*   在图 6.17 基础上增加功能：
    *   **(1) 目的寄存器选择:** 寄存器堆写地址端 Rw 增加多路选择器，由 `RegDst` 控制选择 Rd (R-型) 还是 Rt (I-型)。
    *   **(2) 立即数扩展:** 增加 **扩展器 (Extender)**，由 `ExtOp` 控制进行符号扩展 (算术) 或零扩展 (逻辑)。输入为指令 `imm16` 字段。
    *   **(3) ALU B口操作数来源:** ALU 的 B 口增加多路选择器，由 `ALUSrc` 控制选择 `busB` (寄存器 Rt 内容，R-型) 还是扩展器输出 (I-型)。

**5. Load/Store 指令的数据通路 (如图 6.19)**
![[image-251.png]]
`lw`/`sw` 是 I-型指令。地址计算 (`R[Rs] + SignExt(imm16)`)，然后读/写内存。
*   在图 6.18 基础上增加功能：
    *   **(1) 写回数据来源选择:** 寄存器堆输入端 `busW` 增加多路选择器，由 `MemtoReg` 控制选择 ALU 结果 (运算类) 还是存储器读出数据 (Load)。
    *   **(2) 数据存储器:** 增加数据存储器。
        *   访存地址 (Adr) 来自 ALU 输出。
        *   Store 指令: Rt 内容 (来自 `busB`) 送数据存储器 `Data In` 端。
        *   Load 指令: 数据存储器 `Data out` 端连接到 `busW` 的多路选择器。
        *   控制信号: `MemWr` (写使能)。
    *   地址运算 (`imm16` 符号扩展) 的 `ALUctr` 为 `addu` (不判溢出加法)。

**6. 分支指令的数据通路 (如图 6.20)**
![[image-252.png]]
`beq` 是 I-型指令。根据 `R[Rs]` 和 `R[Rt]` 是否相等进行分支。
*   在图 6.19 基础上主要增加 **取指令部件**，转移目标地址计算在 **下地址逻辑** 中实现。
*   ALU 执行不判溢出的减法 (`subu`)，产生 `Zero` 标志。
*   **下地址逻辑输入:** PC, `Zero` 标志, `imm16`, 控制信号 `Branch`。
*   ALU 输出的 `Zero` 标志送到下地址逻辑。`imm16` 和 PC 也送到下地址逻辑。
*   控制信号 `Branch` 表示当前是否为分支指令，决定下地址逻辑如何计算下条指令地址。

**下地址逻辑的计算方法:** (指令长度 32 位，字节编址，PC 只需存高 30 位 `PC<31:2>`)
*   **顺序执行时:** `PC<31:2> ← PC<31:2> + 1`
*   **转移执行时 (beq):** `PC<31:2> ← PC<31:2> + 1 + SignExt(imm16)` (imm16 已是字偏移量)
*   **取指令时:** 指令地址 = `PC<31:2> || "00"`

**图 6.21: 分支指令的下地址逻辑实现方式**
![[image-253.png]]
*   **(a) 快速但昂贵:** 只要不是分支指令 (`Branch=0`)，立即得到 `PC+1`。
*   **(b) 慢速但节省:** 需等 `Zero` 有值后才计算。单周期中性能无影响 (因 Load 指令更慢)。用低位进位 1 实现 "+1"，省去加法器。
*   每时钟，当前 PC 送指令存储器取指令，同时下地址逻辑计算下条指令地址送 PC 输入端，下时钟写入 PC。

**7. 无条件转移指令的数据通路 (如图 6.22)**
![[image-254.png]]
`j` 是 J-型指令。无条件将目标地址设置到 PC。
*   跳转目标地址计算: `PC<31:2> ← PC<31:28> || target<25:0>`
*   图 6.22 在图 6.21 基础上增加无条件转移功能的完整取指令部件。
*   下地址逻辑增加跳转目标地址计算功能，由控制信号 `Jump` 选择作为下条指令的 PC 值。
*   **注意:** 取指令阶段开始时，`Branch`、`Jump` 和 `Zero` 信号是上条指令的旧值。但这些旧值确定的地址只送到 PC 输入端，不会写入 PC，不影响取当前指令。只要在下个时钟到来前能产生正确的下条指令地址即可。

**图 6.23: 取指令部件的外部结构**
![[image-255.png]]
*   **输出:** 指令 (`Instruction<31:0>`)
*   **输入:** `Zero` 标志, 控制信号 `Branch`, `Jump`。
*   `imm16` 和 `target<25:0>` 直接来自取出的指令。

**8. 综合 11 条指令的完整数据通路 (如图 6.24)**
![[image-256.png]]
*   图中加下划线的为控制信号名称，用虚线表示。
*   指令执行结果在下个时钟到来时开始保存在寄存器堆、数据存储器或 PC 中。

---

### 6.2.3 控制逻辑单元的设计

控制单元主要包含一个指令译码器。
*   **输入:** 指令操作码 `op` (R-型指令还包括功能码 `func`)。
*   **输出:** 控制信号。

**设计过程:**

1.  **根据每条指令功能，分析控制信号取值，列入表中。**
2.  **根据指令和控制信号关系，写出每个控制信号的逻辑表达式。**

**1. 控制信号取值分析**
根据取指令阶段的执行情况：Clk 信号到后，PC 值经锁存延迟 (Clk-to-Q) 作为访存地址送指令存储器，经“取数时间”后指令取出，送控制单元译码，输出控制信号。随后，每条指令在控制信号下完成功能。

*   **(1) R-型指令执行阶段 (如图 6.25)**
	* ![[image-257.png]]
    *   数据路径: `Register File(Rs, Rt) → busA, busB → ALU → Register File(Rd)`
    *   **控制信号取值:**
        *   `Branch = 0`, `Jump = 0` (非转移)
        *   `RegDst = 1` (目的寄存器为 Rd)
        *   `ALUSrc = 0` (ALU B口来自 busB)
        *   `ALUctr = add/sub/subu/slt/sltu` (5 种不同操作)
        *   `MemtoReg = 0` (写回数据来自 ALU)
        *   `RegWr = 1` (结果写回寄存器，不溢出时)
        *   `MemWr = 0` (不写数据存储器)
        *   `ExtOp = x` (无关，因为 `ALUSrc=0`)
    *   **定时 (如图 6.26):** PC+4 和 ALU 输出在下个 Clk 到来时开始写入 PC 和 Rd。
	    * ![[image-258.png]]
*   **(2) I-型运算指令执行阶段 (如图 6.27)**
	* ![[image-259.png]]
    *   数据路径: `Register File(Rs) → busA`, `Extender(imm16) → ALU → Register File(Rt)`
    *   **`ori` 和 `addiu` 控制信号取值:**
        *   `Branch = 0`, `Jump = 0`
        *   `RegDst = 0` (目的寄存器为 Rt)
        *   `ALUSrc = 1` (ALU B口来自 Extender)
        *   `ALUctr = or / addu`
        *   `MemtoReg = 0`
        *   `RegWr = 1`
        *   `MemWr = 0`
        *   `ExtOp = 0 (ori) / 1 (addiu)`

*   **(3) Load/Store 指令执行阶段**
    *   **Load 指令 (如图 6.28):** `Register File(Rs) → busA`, `Extender(imm16) → ALU(addu) → 数据存储器地址`, `数据存储器 → Register File(Rt)`
	    * ![[image-260.png]]
        *   控制信号: `Branch=0`, `Jump=0`, `RegDst=0`, `ALUSrc=1`, `ALUctr=addu`, `MemtoReg=1` (写回数据来自存储器), `RegWr=1`, `MemWr=0`, `ExtOp=1` (符号扩展)。
    *   **Store 指令 (如图 6.29):** `Register File(Rs, Rt) → busA`, `Extender(imm16)`, `busB → ALU(addu) → 数据存储器地址`, `busB → 数据存储器`
	    * ![[image-261.png]]
        *   控制信号: `Branch=0`, `Jump=0`, `RegDst=x`, `ALUSrc=1`, `ALUctr=addu`, `MemtoReg=x`, `RegWr=0` (不写寄存器), `MemWr=1`, `ExtOp=1`。

*   **(4) 分支指令 (`beq`) 执行阶段**
    *   数据路径: `Register File(Rs, Rt) → busA, busB → ALU(subu) → Zero 标志 → 取指令部件`
    *   控制信号: `Branch=1`, `Jump=0`, `RegDst=x`, `ALUSrc=0`, `ALUctr=subu`, `MemtoReg=x`, `RegWr=0`, `MemWr=0`, `ExtOp=x`。

*   **(5) 无条件转移指令 (`j`) 执行阶段**
    *   主要由取指令部件通过 `Jump` 控制下条指令地址。
    *   控制信号: `Branch=0`, `Jump=1`, `RegWr=0`, `MemWr=0`。其他无关。
![[image-262.png]]
**表 6.5: 各指令控制信号取值汇总**
(列出了 11 条指令对应的所有 9 个主要控制信号 (`Branch`, `Jump`, `RegDst`, `ALUSrc`, `ALUctr`, `MemtoReg`, `RegWr`, `MemWr`, `ExtOp`) 的取值。`ALUctr` 针对不同指令有不同编码。)

**2. 控制单元设计**
*   除 `ALUctr` 外，其他都是单值控制信号。
*   R-型指令的 `ALUctr` 由 `func` 字段决定，其余控制信号对所有 R-型指令都相等。
*   可以设计一个 **主控制器** 和一个 **局部 ALU 控制器** (如图 6.30)。
    *   **主控制器:** 输入为 `op` 码，输出各种控制信号和 `ALUop` (非 R-型指令的 ALU 操作类型)，以及一个 `R-type` 信号。
    *   **局部 ALU 控制器:** 输入为 `func` 字段，输出 R-型指令的 `ALUctr`。
    *   通过 `R-type` 信号选择最终的 `ALUctr` 是来自 `ALUop` 还是局部 ALU 控制器。

**ALUop 需要区分的情况 (11 条指令):**
1.  R-型指令: 由局部 ALU 控制器据 `func` 确定 `ALUctr`。
2.  I-型 `ori`: `ALUop = ALUctr = or`。
3.  I-型 `addiu`: `ALUop = ALUctr = addu`。
4.  I-型 `lw/sw`: `ALUop = ALUctr = addu`。
5.  I-型 `beq`: `ALUop = ALUctr = subu`。
6.  J-型 `j`: `ALUop = ALUctr = 任意`。
![[image-263.png]]
**表 6.6: ALUop 的编码分配 (基于表 6.3 的 ALUctr 编码)**
(非 R-型指令的 `ALUop` 与其 `ALUctr` 编码一致，R-型指令用一个未用编码表示)
 
*   **(1) 主控制器的设计 (如图 6.31)**
	* ![[image-264.png]]
    *   根据表 6.5 和表 6.6，写出各控制信号 (如 `Branch`, `RegWr`, `ALUop<2:0>`) 的逻辑表达式 (基于 `op` 码)。
    *   可用 PLA 电路实现，"与"阵列是指令译码器。
 
*   **(2) ALU 局部控制器的设计**
    *   输入为 `func` 字段，输出为 `ALUctr`。
    * ![[image-265.png]]
    *   **表 6.7: func 字段编码分配表 (部分 MIPS 指令)**
    *   根据 `func<3:0>` (因前两位为 `10`) 与 `ALUctr` 的关系，写出 `ALUctr<2:0>` 的逻辑表达式。

---

### 6.2.4 时钟周期的确定

计算机性能由指令数目、时钟周期和 CPI 决定。
*   **单周期处理器:** CPI = 1。
*   **时钟周期:** 取决于最复杂指令 (通常是 `lw`) 所用的指令周期。

**图 6.32: `lw` 指令执行定时**
![[image-266.png]]
`lw` 指令周期包含的时间:
PC 锁存延迟 (Clk-to-Q) + 取指令时间 + 寄存器取数时间 + ALU 延迟 + 存储器取数时间 + 寄存器建立时间 + 时钟扭斜 (Clock Skew)。

单周期处理器的时钟周期通常很长，因为必须适应最慢指令的完整执行路径。