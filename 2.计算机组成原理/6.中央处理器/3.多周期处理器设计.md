好的，这是关于 "6.3 多周期处理器设计" 的学习笔记。

## 6.3 多周期处理器设计

单周期处理器时钟周期由最长指令决定，导致对简单指令而言时钟周期过长，效率低下。例如：
*   R-型和立即数运算指令不需要读内存。
*   Store 指令不需要写寄存器。
*   分支指令不需要访问内存和写寄存器。
*   Jump 指令不需要 ALU 运算、读内存和写寄存器。

多周期处理器旨在解决此问题，提高效率。

---

### *6.3.1 信号竞争问题

在介绍单周期处理器时，存储器被简化为理想情况。实际存储器的写操作不是由时钟边沿触发的组合逻辑电路，其过程为：当“写使能”信号有效，且写入数据和地址已稳定后，经过一个写操作时间，数据被写入。**关键点：地址和数据必须在“写使能”信号有效前先稳定在各自的输入端。**

在单周期数据通路中，如果不能保证地址和数据在“写使能”有效前稳定，就会发生 **竞争 (Race) 问题**，可能导致机器意外出错甚至崩溃。

**多周期处理器解决竞争问题的方法：**
首先确认地址和数据在第 *n* 周期结束时已稳定，然后在下一个周期（第 *n*+1 周期）使“写使能”信号有效，并确保地址和数据在“写使能”信号无效前不改变其值。

---

### *6.3.2 指令执行状态分析

多周期处理器中，每条指令分多个阶段执行，每个阶段占一个时钟周期，称为一个 **状态**。一条指令的执行由多个状态组成。
![[image-267.png]]
**图 6.33: 带控制信号的多周期数据通路示意图**
与单周期相比，增加了控制信号，并对一些部件的功能进行了调整。
*   **需要写使能的部件:** PC, IR, 分支目标寄存器 (BT 寄存器), 寄存器堆 (因为它们只在需要时写入新值)。
*   **不需要写使能的部件 (临时寄存器):** 寄存器 A 和 B (每时钟都可改变值，通过后续多路选择器控制数据通路正确性)。
*   **PC 的来源:** PC+4, 分支目标地址, 无条件跳转目标地址 (由 `PCSource` 信号控制)。
*   分支目标地址保存在专门的 BT 寄存器中。
*   无条件跳转目标地址由 PC 高 4 位和指令低 26 位拼接并在低位添 "00" 得到。
*   对于需要判断溢出的算术运算类指令，当发生溢出时，禁止写结果到寄存器堆。

**指令执行阶段划分 (所有指令共有的前两个阶段):**

**1. 取指令、指令译码/取数阶段**

*   **(1) 取指令状态 (IFetch)**
    *   **功能:** `IR ← M[PC]`, `PC ← PC+4`
    *   **操作:**
        1.  PC 值作为地址读存储器，读出指令送 IR 输入端。
        2.  PC 送 ALU 的 A 口，4 送 ALU 的 B 口，ALU 做加法，结果 PC+4 送 PC 输入端。
    *   **控制信号 (部分):**
        *   `IorD = 0` (内存地址来自 PC，用于取指令)
        *   `ALUSelA = 0` (ALU A口选择 PC)
        *   `ALUSelB = 01` (ALU B口选择常数 4)
        *   `ALUOp = addu` (ALU 执行不判溢出的加法)
        *   `PCSource = 01` (PC 的下一个值来自 ALU 输出)
        *   `PCWr = 1` (允许 PC 写入)
        *   `IRWr = 1` (允许 IR 写入)
        *   `MemWr = 0`, `RegWr = 0`, `BrWr = 0`, `R-type = 0` (其他写使能关闭)

*   **(2) 译码/取数状态 (RFetch/ID)**
    *   **功能:** `CU(译码) ← IR<31:26>`, `A ← R[IR<25:21>]`, `B ← R[IR<20:16>]`
    *   此阶段 ALU 空闲，可利用 ALU "投机地" 计算分支目标地址并送 BT 寄存器：`BT ← PC + (SignExt(imm16)×4)` (这里的 PC 已经是 PC+4 的值)。若当前不是分支指令，此操作无影响；若是，则节省一个时钟周期。
    *   **控制信号 (部分):**
        *   `EXTOp = 1` (立即数符号扩展)
        *   `ALUSelA = 0` (ALU A口选择 PC，此时 PC 内容为原 PC+4)
        *   `ALUSelB = 11` (ALU B口选择符号扩展并左移两位的立即数)
        *   `ALUOp = addu`
        *   `BrWr = 1` (允许分支目标寄存器 BT 写入)
        *   `PCWr = 0`, `PCWrCond = 0`, `IRWr = 0`, `MemWr = 0`, `RegWr = 0`, `R-type = 0`

**2. R-型指令运算阶段**
*   **功能:** `R[IR<15:11>] ← A op B` (A、B 内容已在上一状态读出)
*   需要两个状态完成 (解决写寄存器堆的竞争问题)：
    *   **执行状态 (RExec):** 先送数据和地址。
        *   A、B 内容分别送 ALU 的 A 口和 B 口，进行相应运算。
        *   **控制信号 (部分):**
            *   `ALUSelA = 1` (ALU A口选择寄存器 A 的输出)
            *   `ALUSelB = 00` (ALU B口选择寄存器 B 的输出)
            *   `RegDst = 1` (目的寄存器由指令的 Rd 字段指定)
            *   `R-type = 1` (表示是 R-型指令，`ALUctr` 由 `func` 码确定)
            *   `RegWr = 0`, `PCWr = 0`, `PCWrCond = 0`, `IRWr = 0`, `MemWr = 0`, `BrWr = 0`, `MemtoReg = 0`
    *   **结束状态 (RFinish):** 再使能写信号。
        *   **控制信号 (部分):** 除 `RegWr = 1` 外，其余同 RExec 状态。

**3. I-型指令立即数运算阶段**
*   **功能:** `R[IR<20:16>] ← A op Ext([IR<15:0>])`
*   同样分执行和结束两个状态。
*   **执行状态 (例如 oriExec):**
    *   **控制信号 (部分):**
        *   `ALUSelA = 1`
        *   `ALUSelB = 10` (ALU B口选择扩展后的立即数)
        *   `ALUOp` 由指令类型决定 (如 `ori` 指令为 `or`)
        *   `EXTOp` 由指令类型决定 (如 `ori` 为 0-零扩展，`addiu` 为 1-符号扩展)
        *   `MemtoReg = 0`
        *   `RegDst = 0` (目的寄存器由指令的 Rt 字段指定)
        *   `RegWr = 0`, `PCWr = 0`, ..., `R-type = 0`
*   **结束状态 (例如 oriFinish):** 除 `RegWr = 1` 外，其余同执行状态。

**4. `lw` 指令执行阶段**
*   **功能:** `R[IR<20:16>] ← M[A + SignExt([IR<15:0>])]`
*   需要三个状态：
    *   **访存地址计算状态 (MemAdr):**
        *   ALU 计算有效地址：`A + SignExt(imm16)`
        *   **控制信号 (部分):**
            *   `ALUSelA = 1`
            *   `ALUSelB = 10`
            *   `ALUOp = addu`
            *   `EXTOp = 1` (符号扩展)
            *   `IorD = 1` (内存地址来自 ALU，用于数据访问)
            *   其他写使能均为 0。
    *   **存储器取数状态 (MemFetch):**
        *   从计算出的地址读取数据。
        *   **控制信号 (部分):**
            *   `EXTOp`, `ALUSelA`, `ALUSelB`, `ALUOp`, `IorD`, `R-type` 与上一个状态保持一致 (维持地址信号稳定)。
            *   `MemtoReg = 1` (数据来自存储器)
            *   `RegDst = 0` (目的寄存器为 Rt)
            *   所有写使能均为 0 (确保数据稳定)。
    *   **结果写回寄存器状态 (lwFinish):**
        *   将从内存读出的数据写入目的寄存器。
        *   **控制信号 (部分):** `RegWr = 1`，其余信号与上一个状态保持一致 (维持写回数据和目标寄存器地址稳定)。

**5. `sw` 指令执行阶段**
*   **功能:** `M[A + SignExt([IR<15:0>])] ← B`
*   需要两个状态：
    *   **访存地址计算状态 (MemAdr):** 同 `lw` 指令的 MemAdr 状态。
    *   **存储器存数状态 (swFinish):**
        *   将寄存器 B 的内容写入计算出的内存地址。
        *   **控制信号 (部分):** `MemWr = 1`，其余控制信号保持不变，以确保地址和写入数据的稳定。

**6. 分支指令 (`beq`) 执行阶段**
*   **功能:** `if (A-B==0) then PC ← BT` (BT 中已存 `PC+(SignExt(imm16)×4)`)
*   只需要一个状态 (BrFinish)，因为分支目标地址已在 ID 阶段计算好。
*   **控制信号 (部分):**
    *   `ALUSelA = 1`
    *   `ALUSelB = 00`
    *   `ALUOp = subu` (ALU 执行减法，产生 Zero 标志)
    *   `PCWrCond = 1` (根据 Zero 标志条件写 PC)
    *   `PCSource = 10` (PC 的下一个值来自 BT 寄存器)
    *   其他写使能均为 0。

**7. 无条件跳转指令 (`jump`) 执行阶段**
*   **功能:** `PC ← Target` (Target 为指令中给出的跳转地址拼接 PC 高位得到)
*   只需要一个状态 (JumpFinish)。
*   **控制信号 (部分):**
    *   `PCSource = 00` (PC 的下一个值来自跳转目标地址逻辑)
    *   `PCWr = 1`
    *   其他写使能均为 0。
![[image-268.png]]
**图 6.34: 指令执行状态转换图 (部分指令)**
*   图中每个状态用“状态号: 状态名”标识。
*   圆圈中示意性地给出了该状态下部分控制信号的取值。
*   **CPI (Cycles Per Instruction) 分析:**
    *   R-型、I-型运算、sw 指令: CPI = 4
    *   lw 指令: CPI = 5 (最长)
    *   beq、jump 指令: CPI = 3 (假设分支目标地址在 ID 阶段计算)
*   **优化:** 若需要支持更多 I-型运算指令，可以像 `lw/sw` 一样先分为算术类和逻辑类，再分别像 R-型一样合并执行和完成状态，使 I-型运算指令也只需 4 个状态。

---

### *6.3.3 硬连线路控制器设计

多周期控制器的控制信号在不同周期取值不同，不能简单用真值表描述。通常采用 **有限状态机 (Finite State Machine, FSM)** 或 **微程序** 方式实现。

**有限状态机控制器 (FSM Controller):**
*   用 FSM 描述指令执行过程，当前状态和操作码确定下一状态。
*   每时钟发生一次状态改变，不同状态输出不同控制信号。
* ![[image-269.png|464x312]]
*   **结构 (图 6.35):**
    *   **组合逻辑控制单元:** 通常用 PLA 实现。根据当前状态和指令操作码 (`op`) 产生下一状态 (`Next State`) 和输出控制信号。
    *   **状态寄存器:** 存储当前状态 (`Current State`)。
    ![[image-270.png]]
*   **状态转换表 (表 6.8):** (基于图 6.34 的状态)
    *   假设 12 个状态 (0~11)，状态变量需 4 位 (S3S2S1S0)。
    *   列出当前状态、指令操作码，以及对应的下一状态。
*   **图 6.36: 用 PLA 电路实现的组合逻辑控制单元**
* ![[image-271.png]]
    *   此为 **"摩尔 (Moore)" 型 FSM**：控制信号的输出仅依赖于当前状态。
    *   组合逻辑控制单元分为两部分：
        1.  由操作码和当前状态确定下一状态的电路。
        2.  由当前状态确定控制信号的电路 (图中右下角虚线区域)。
**例 6.1: 多周期与单周期处理器性能比较**
*   **假设指令比例:** Load: 22%; Store: 11%; R-型和 I-型运算: 49%; Branch: 16%; Jump: 2%。
*   **多周期 CPI 计算:** (根据各指令周期数和比例)
    `CPI_multi = (0.22 × 5) + (0.11 × 4) + (0.49 × 4) + (0.16 × 3) + (0.02 × 3) = 1.1 + 0.44 + 1.96 + 0.48 + 0.06 = 4.04`
*   **单周期 CPI:** `CPI_single = 1`
*   **时钟周期关系:** 单周期时钟周期约等于多周期时钟周期的 5 倍 (因为 Load 指令最长，为 5 个多周期时钟)。
*   **性能比较:**
    *   假设单周期时钟宽度为 1 单位，则多周期时钟宽度约为 1/5 单位。
    *   多周期总体时间: `4.04 × (1/5) = 0.808` 单位。
    *   单周期总体时间: `1 × 1 = 1` 单位。
    *   多周期处理器速度大约是单周期处理器的 `1 / 0.808 ≈ 1.23` 倍。

硬连线路控制器速度快，适合简单或规整的指令系统 (如 MIPS)。对于复杂指令系统，其逻辑网络庞大复杂。