好的，这是关于“6.5 异常和中断处理”的学习笔记：

**6.5 异常和中断处理**

**6.5.1 基本概念**

在程序正常执行过程中，CPU可能会遇到一些特殊情况而无法继续执行当前程序，这种打断程序正常执行的情况主要分为内部异常和外部中断。

1.  **内部异常 (Exception)**
    *   **定义:** 指由处理器内部原因引起的意外事件。
    *   **按原因分类:**
        *   **硬故障中断:** 由硬件线路出现异常引起，如电源掉电、存储器线路错等。
        *   **程序性异常 (也称软中断或例外):** 由CPU执行某条指令时，因指令本身的问题而引起的异常事件。例如：
            *   除数为0
            *   运算溢出
            *   断点 (breakpoint)
            *   单步跟踪 (single-step trace)
            *   寻址错 (addressing error)
            *   访问超时 (access timeout)
            *   非法操作码 (illegal opcode)
            *   堆栈溢出 (stack overflow)
            *   缺页 (page fault)
            *   地址越界 (address out of bounds)
            *   数据格式错 (data format error)
    *   **按发生异常的报告方式和返回方式分类:**
        *   **(1) 故障 (Fault / 失效):**
            *   **检测时机:** 在引起故障的指令启动后、执行结束前被检测到。
            *   **断点 (返回地址):** 通常是当前发生故障的指令的地址。
            *   **处理后:**
                *   若可恢复 (如“缺页”、“段不存在”)，则处理后返回原指令继续执行。
                *   若不可恢复 (如“非法操作码”、“保护错”)，则通常终止进程。
                *   对于“除数为0”等，可以返回一个特殊值 (如 ∞ 或 NaN) 后继续执行，或终止进程。
        *   **(2) 自陷 (Trap / 陷阱 / 陷入):**
            *   **性质:** 预先安排的一种“异常”事件，如同预设的“陷阱”。
            *   **机制:** CPU通过特定方式（如执行一条特殊指令或设定特殊控制标志）被设置为某个特定状态，在程序执行过程中，一旦某条指令的执行满足了相应条件，CPU则调出特定的程序进行处理。
            *   **断点 (返回地址):** 通常是自陷指令的下一条指令的地址。(注意：若自陷指令是转移指令，则返回到转移目标指令执行)。
            *   **示例:** Intel 80x86体系结构中，执行STI指令使CPU处于开中断状态；通过PUSHF/PUSHFD和POPF/POPFD指令设置CPU的跟踪标志TF，实现单步跟踪。系统调用指令、条件陷阱指令（如MIPS中的teq, teqi等）也属于自陷。
        *   **(3) 终止 (Abort):**
            *   **原因:** 发生了使机器无法继续执行的严重硬件故障，如电源掉电、线路故障等。
            *   **处理:** 程序将无法继续执行，只好终止，此时调出中断服务程序来重启系统。
            *   **特点:** 这种异常与故障和自陷不同，不是由特定指令产生的，而是随机发生的，因此无法确定发生异常的是哪条指令。

2.  **外部中断 (Interrupt)**
    *   **定义:** 程序执行过程中，若外部设备完成任务或发生某些特殊事件（如打印机缺纸、定时采样计数时间到、键盘缓冲满等），会向CPU发出中断请求，要求CPU对这些情况进行处理。
    *   **特点:**
        *   与当前CPU正在执行的指令无关。
        *   与指令的执行是异步发生的。
        *   由CPU外部的I/O设备发出。
    *   **响应时机:** 通常，每条指令执行完毕后，CPU会主动去查询是否有“中断”请求。
    *   **处理:** 若有中断请求，则将下一条指令的地址作为断点保存，然后转到相应的中断服务程序执行，结束后回到断点继续执行。

**本教材术语区分:**
*   **异常 (Exception):** CPU内部产生的事件。
*   **中断 (Interrupt):** CPU外部的I/O设备引发的事件。
两者在处理过程和基本处理方式上是类似的。

**6.5.2 异常处理过程**

CPU对异常的处理过程可分为以下两个步骤：

1.  **保护断点和程序状态**
    *   **断点 (返回地址):**
        *   不同异常事件的返回地址不同。例如，“故障”异常的断点是发生故障的当前指令的地址；“自陷”异常的断点则是自陷指令后面一条指令的地址。
        *   断点的值由异常类型和发生异常时PC的值决定。例如，在多周期数据通路中，若执行lw/sw指令时发生“缺页”异常，其断点值应是当前PC值减4（因为发现“缺页”时，已在取指令状态执行了PC+4）。
    *   **保存方式:**
        *   **断点 (PC值):** 必须保存起来，通常是压入堆栈，或存入特定的寄存器中（如MIPS处理器用EPC寄存器专门存放断点）。
        *   **程序状态 (PSWR/PSW):** 当前程序的运行状态信息（如各种标志、允许自陷标志等）也必须保存。这些信息通常存放在程序状态字寄存器(PSWR)中，其内容称为程序状态字(PSW)。例如，80x86中的EFLAGS寄存器。PSW也需要被保存到堆栈或特定寄存器中，在异常返回时恢复。
    *   **目的:** 确保在异常处理完毕后，能够正确返回到原被中断的程序继续执行。
    *   **注意:** 如果处理器体系结构中规定PSWR是指令可直接访问的寄存器，则PSW的保存/恢复也可以和现场的保存/恢复一样，由异常处理程序（或中断服务程序）来实现，而无需硬件自动保存。

2.  **识别异常事件并转异常处理**
    *   **目的:** 在调出异常处理程序之前，必须知道发生了什么异常。
    *   **识别方式:**
        *   **内部异常:**
            *   **软件识别:** CPU设置一个异常状态寄存器，用于记录异常原因。操作系统使用一个统一的异常查询程序，按一定优先级顺序查询异常状态寄存器，先查询到的异常先被处理。例如，MIPS采用软件识别，CPU中有一个`cause`寄存器专门用于异常查询。
            *   **硬件向量/直接识别:** 对于像“故障”和“陷阱”之类的内部异常，通常是在执行某条指令时发现的，可以通过对指令执行过程中某些条件的判断来发现是否发生了“异常”，而且一旦发现可以马上进行处理。因此，内部异常也可以不通过专门的查询程序来识别，而在发现“异常”时直接得到异常错误代码，根据不同的错误代码，转到相应的异常处理程序即可。80x86的处理方式就是这样。
        *   **外部中断:** 其识别方式与内部异常不同，通常涉及中断源的判优和识别（详见第九章）。
    *   **禁止新的异常/中断:** 在响应并处理异常的过程中，若又发生了新的异常，则会因要处理新的异常而把原来进程的状态和保存的返回断点破坏掉。因此，应该有一种机制来“禁止”在响应并处理异常时再响应新的异常。通常通过设置“中断/异常允许”状态位（或触发器）来实现。例如，80x86体系结构中，执行指令STI或CLI，使标志寄存器EFLAGS中的IF位被设置为1或清0，使CPU处在开或关中断状态。80x86规定，异常处理过程中，IF必须清0，以禁止响应新的异常或中断。

***6.5.3 带异常处理的处理器设计 (MIPS示例)***

*   **MIPS异常处理机制简化:**
    *   **EPC (Exception Program Counter):** 一个特殊的32位寄存器，用于保存断点信息。
        *   故障时，断点值为正在执行的异常指令的地址 (PC-4 -> EPC)。
        *   自陷时，断点值为异常指令的下一条指令的地址 (PC -> EPC)。
        *   (本教材MIPS示例中，统一将PC-4存入EPC，实际应区分情况)
    *   **`cause`寄存器:** 一个特殊的32位寄存器，用于记录异常原因。
    *   **异常查询程序入口地址:** 固定为 0x8000 0180。
*   **假定处理器能处理的异常类型:**
    *   非法操作码 (Instruction Undefined): `cause` = 0
    *   溢出 (Overflow): `cause` = 1
*   **数据通路修改 (参考图6.41):**
	* ![[image-279.png]]
    *   增加EPC和`cause`寄存器。
    *   为EPC和`cause`寄存器分别增加写使能控制信号：EPCWr 和 CauseWr。
    *   增加控制信号 IntCause，用于选择写入`cause`寄存器的值 (0表示非法操作码，1表示溢出)。
    *   PCSource控制的多路选择器增加一个新的输入端，其值为异常查询程序入口地址0x8000 0180，用PCSource=11来控制选择。
*   **控制器 (有限状态机) 修改 (参考图6.42):**
	* ![[image-383.png]]
    *   增加新的状态来处理异常。
    *   **状态12 (非法操作码异常处理状态):**
        *   **进入条件:** 在状态1（指令译码/取数）时，若检测到op字段是一个未定义的编码。
        *   **操作:**
            1.  将0送`cause`寄存器 (CauseWr=1, IntCause=0)。
            2.  PC-4送EPC (EPCWr=1)。
            3.  将0x8000 0180送PC (PCWr=1, PCSource=11)。
    *   **状态13 (溢出异常处理状态):**
        *   **进入条件:** 当R型指令或I型运算类指令执行后，在ALU输出端的Overflow为1时。
        *   **操作:**
            1.  将1送`cause`寄存器 (CauseWr=1, IntCause=1)。
            2.  PC-4送EPC (EPCWr=1)。
            3.  将0x8000 0180送PC (PCWr=1, PCSource=11)。
*   **关于“缺页(Page Fault)”异常处理的说明:**
    *   **检测时机:** 在每次存储器访问过程中，查询其对应页表项中的“有效位(Valid)”。若不为1，则发生缺页。
    *   **关键:** 必须在发生缺失的存储器操作的时钟周期内捕获到，并在下一个时钟周期转到异常处理，否则会发生错误（例如，对于`lw $1, 0($1)`指令，若未及时捕获缺页并转异常处理，而使`$1`发生了改变，那么重新执行该指令时所读的内存单元地址就会错误）。
    *   **缺页异常处理程序的功能:**
        1.  保存正在运行进程的所有状态（程序可见寄存器、页表地址寄存器、EPC和`cause`寄存器等）。
        2.  确定缺失的是指令还是数据（根据EPC中的地址判断是取指阶段还是取数/存数阶段）。
        3.  完成磁盘读写操作（查找页表项得到磁盘地址，启动磁盘读操作，将所需页面调入内存）。此过程耗时很长，OS会挂起当前进程，调度其他进程运行。
        4.  恢复引起缺页的进程的状态。
        5.  执行“从异常返回”指令，修改机器状态（如CPU从核心态转到用户态），并将EPC中的地址装回到PC中。
    *   **复杂性:** 确保在指令执行的中间某个阶段被中止时，能够正确保存和恢复指令执行过程中的机器状态，以便缺页处理后能从中间阶段继续执行。