指令系统设计是计算机系统结构设计的关键之一。在设计指令系统时，必须遵循以下基本原则：
1.  **完备性或完整性 (Completeness):**
    *   指令的操作类型应尽量完备，应能足够编制任何可计算程序。
    *   如果指令系统太复杂，也会给硬件实现增加困难。因此，较复杂的功能可以通过伪指令实现。
2.  **兼容性 (Compatibility):**
    *   在考虑系列机设计实现时，高档机的指令系统应兼容以前低档机的指令系统，这给软件资源重复利用带来方便。
3.  **均匀性 (Uniformity):**
    *   运算指令应能对多种类型的数据进行处理，包括三种整数（字节、字、双字）和两种浮点数（单精度和双精度浮点数）类型。
4.  **可扩充性 (Extensibility):**
    *   操作码字段要预留一定的编码空间，以便需要时进行扩充。
### 5.2.1 基本设计问题
在设计一个指令系统时，需要考虑以下一些基本问题：
1.  **操作码的个数、种类、复杂度如何选择?**
    *   例如，若指令系统中共包含4条指令：取数指令 (Load)、存数指令 (Store)、自增指令 (INC)、分支指令 (BRN)，则用这4条指令足以编制任何可计算程序。虽然这4条指令是完备的，但会导致大多数程序变得很长，既占空间又费时间。
2.  **运算指令能对哪几种数据类型进行操作?**
    *   高级语言源程序中需要对 int、short 和 byte 等类型的整型数据以及 float、double 等浮点类型数据，甚至是位串、字符串等进行操作，所以，指令设计时也需要考虑能对这些数据类型进行操作。
3.  **采用什么样的指令格式?**
    *   规整型指令采用定长指令字和定长操作码，使得取指令、指令译码、指令地址计算等变得简单，从而能减少时间开销，但是，规整型指令在空间上会增加开销。因此，应根据设计目标选择采用规整型还是紧凑型指令格式。
4.  **通用寄存器的个数、功能、长度等如何规定?**
    *   用户进程的指令中能用的寄存器是用户可见寄存器，也称为通用寄存器。
    *   **个数：** 通用寄存器多，则编译器可以尽量多地把高级语言源程序中的变量分配到通用寄存器中，因而减少指令执行时访问内存的次数，加快程序运行。但是，通用寄存器多会使寄存器存取延迟变长，因而影响指令执行速度。此外，还可能使寄存器编码变长，从而使指令长度变长，通用寄存器多还会增大CPU成本，占用更多硅片面积。
    *   **功能分配：** 例如，要考虑是否要有专门的栈指针寄存器、栈帧指针寄存器、过程调用的参数寄存器、过程调用的返回参数寄存器、过程调用的返回地址寄存器；是否要有记录指令执行状态的标志寄存器等。
    *   **长度：** 还要考虑每个寄存器的长度以及寄存器的设计如何满足多种不同长度的数据类型。例如，Intel 体系结构 IA-32 中，用寄存器扩展的方式提供了存放8位、16位、32位等多种长度操作数的寄存器；而 MIPS 等体系结构中采用的是固定寄存器宽度的设计方案，通过提供不同的指令来区分操作数的长度。
5.  **如何设计寻址方式的种类、寻址方式字段的编码以及各种寻址方式下有效地址如何计算?**
    *   寻址方式字段可以和操作码一起编码，由操作码确定每个操作数的寻址方式（如 MIPS 体系结构）。
    *   寻址方式字段也可单独编码，例如，IA-32 指令中每个操作数都有各自专门的寻址方式字段。
6.  **下条指令的地址如何确定?**
    *   几乎所有指令系统都通过一个专门的寄存器来存放下条指令的地址，这个寄存器被称为程序计数器 (Program Counter, PC) 或指令指针 (Instruction Pointer, IP)。
    *   顺序执行时，指令中无须明显地给出下条指令地址，默认由 PC 指出。通过将当前 PC 的值加上本条指令的长度即可得到下条指令地址。
    *   转移指令等可能改变程序执行顺序，此时，这些指令中必须有相应的地址码和寻址方式来给出下条指令地址或下条指令地址的计算方式。

当然，指令系统的设计所涉及的远远不限于上述所列问题，在具体设计过程中，还需要考虑很多细节问题。
### 5.2.2 操作数类型
操作数是指令处理的对象，根据高级语言程序所用的类型来看，指令涉及到的基本操作数类型应该包括以下几类：
1.  **地址 (Address):** 无符号整数，用来表示主(虚)存地址。
2.  **数值数据 (Numerical Data):** 带符号整数和浮点数。带符号整数一般用二进制补码表示，浮点数大多用 IEEE 754 标准表示。有些指令系统也提供十进制数运算指令，一般用 NBCD 码 (8421码) 表示十进制数。
3.  **位、位串、字符和字符串 (Bits, Bit Strings, Characters, Character Strings):** 位和位串数据一般用来表示一些标志、控制和状态等信息。字符和字符串数据用来表示文本、流式文件基本信息等。
4.  **逻辑 (布尔) 数据 (Logical (Boolean) Data):** 表示逻辑值 (0—假/1—真)。
例如，Pentium 处理器提供的基本类型有字节、字(16位)、双字(32位)、四字(64位)。
*   对于整数，有16位、32位、64位三种补码表示的整数和18位压缩BCD码表示的十进制整数。
*   对于序数(即地址、指针等)，有字节、字或双字长的无符号整数。
*   对于浮点数，有用IEEE 754表示的32位单精度浮点数、64位双精度浮点数和80位扩展精度浮点数。
*   另外，还提供了专门的近指针类型数据，用于表示不分段存储器的地址，或用来表示段内偏移的32位有效地址，以进行分段存储器的段内访问。
有关以上各类数据的表示、存放和运算已在第2章和第3章中详细介绍。
### 5.2.3 寻址方式
指令不仅要规定所执行的操作，还要给出操作数或操作数地址。操作数可能是：
*   一个常数
*   一个简单变量
*   数组和结构中的某个元素
*   栈(stack)中的元素
*   外设 I/O接口中的状态字或控制字等。
从指令的角度来看，操作数存放位置可以是CPU中的通用寄存器、存储单元和I/O端口。通常把指令中给出的操作数所在存储单元的地址称为**有效地址**。存储单元地址可能是主存物理地址，也可能是虚拟地址。
*   如果不采用虚拟存储机制，有效地址就是主存物理地址。
*   若采用虚拟存储机制，则有效地址就是虚拟地址。
指令给出操作数或操作数地址的方式称为**寻址方式**。
*   地址字段长度直接影响指令长度，因而指令地址码要尽量短。
*   操作数的存放位置又必须灵活，存放空间也应尽量大。
*   因此，指令系统应能提供灵活的寻址方式，并使用尽量短的地址码访问尽可能大的寻址空间。
*   此外，为加快指令执行速度，有效地址计算过程也应尽量简单。
常用的寻址方式有以下几种：
1.  **立即寻址 (Immediate Addressing):**
    *   指令中直接给出操作数本身，这种操作数称为立即数。
2.  **直接寻址 (Direct Addressing):**
    *   指令中直接给出操作数的有效地址，这种地址称为直接地址或绝对地址。
    *   格式：`OP | 操作数地址`
3.  **间接寻址 (Indirect Addressing):**
    *   指令中给出存放操作数有效地址的地址（即操作数地址的地址）。
    *   可以有单级间接或多重间接。格式中的 `@` 是间接寻址标志。
    *   格式：`OP | @间接地址`
    *   (图5.1 单级间接寻址：指令中的地址 -> 主存单元 -> 有效地址 -> 主存单元 -> 操作数)
	    * ![[image-201.png]] 
4.  **寄存器寻址 (Register Addressing):**
    *   指令中给出操作数所在的寄存器编号，操作数在寄存器中。
    *   格式 (单操作数或隐含另一操作数)：`OP | 寄存器号`
    *   格式 (双操作数)：`OP | 寄存器号1 | 寄存器号2`
    *   优点：
        *   寄存器数量远小于内存单元数，所以寄存器编号比存储器地址短，因而指令较短。
        *   操作数已在CPU中，不用访存，因而指令执行速度快。
5.  **寄存器间接寻址 (Register Indirect Addressing):**
    *   操作数的有效地址在指令指定的某个寄存器中。
    *   如 8086 指令 `MOV AX, [BX]` 中，寄存器 BX 内容为有效地址。
    *   指令也短（只需给出寄存器编号），但由于要访存，执行时间比寄存器寻址长。
6.  **变址寻址 (Indexed Addressing):**
    *   主要用于对线性表之类的数组元素进行方便的访问。
    *   指令中的地址码字段 A 给出一个基准地址（如数组起始地址）。
    *   数组元素相对于基准地址的偏移量在指令中明显或隐含地由变址寄存器 I 给出。
    *   有效地址 EA = (I) + A，其中 (I) 表示变址寄存器 I 的内容。
    *   如果任何通用寄存器都可作为变址寄存器，则需在指令中明确编号并标明用途；若有专门变址寄存器，则无需指明。
    *   指令中的地址码字段 A 称为形式地址，这里的形式地址是基准地址 A。变址寄存器中的偏移量应为无符号数。
    *   例如，8086 指令 `MOV AL, [SI + 1000H]` 中 SI 为变址器，1000H 为形式地址。
    *   **自动变址：** (图5.2 数组元素的变址寻址) 变址器 I 每次自动加(减)数组元素的长度。访问方向低到高则加，高到低则减。可用于建立软堆栈。
	    * ![[image-202.png]]
    *   **变址与间址结合：**
        *   先变址后间址 (前变址)：EA = ((I) + A)
        *   先间址后变址 (后变址)：EA = (I) + (A)
7.  **相对寻址 (Relative Addressing):**
    *   如果某指令的操作数的有效地址或转移目标地址位于该指令所在位置的前、后某个固定位置上，则可用相对寻址。
    *   指令中的地址码字段 A 给出一个偏移量，基准地址隐含由 PC 给出。
    *   有效地址 EA = (PC) + A。这里的偏移量 A 是形式地址，可以是带符号整数。
    *   可用来实现公共子程序的浮动或实现相对转移。
8.  **基址寻址 (Base Addressing):**
    *   指令中的地址码字段 A 给出一个偏移量，基准地址可以明显或隐含地由基址寄存器 B 给出。
    *   有效地址 EA = (B) + A。
    *   与变址寻址类似，但实际功能和用法不同：
        *   变址寻址主要解决数组元素的循环访问问题，指令中给出的形式地址是数组的首地址。
        *   基址寻址可用于程序的重定位。在多道程序系统中，每个用户进程在各自独立的虚拟地址空间中编写，但装入到统一的主存空间运行，需重定位。通常给定一个基地址，进程代码和数据装入到该基地址开始的区域。访问都用指令中的形式地址和基地址相加。(图5.3 基址寻址过程)
	        * ![[image-203.png]]
    *   基址寄存器的内容要求能对整个地址空间进行寻址，指令中给出的形式地址实际上指出了相对于基地址的偏移量。
    *   变址、基址和相对三种寻址方式统称为**偏移寻址 (Displacement Addressing)**。
9.  **其他寻址方式 (Other Addressing Modes):**
    *   **隐含地址码方式：** 指令中不明显给出操作数地址或变址/基址寄存器编号，而是由操作码隐含指出。如单地址指令中另一操作数隐含在累加器；堆栈操作指令的操作数隐含为栈顶元素。
    *   **位寻址 (Bit Addressing):** 对寄存器或主(虚)存中单独一位进行操作（如置位/复位/测试）时使用。需给出位指针。
    *   **字节寻址 (Byte Addressing):** 操作数为一个字节时，指令必须对字节进行定位。字节编址方式时，指令需指出访问的是字节、半字、字还是双字；字编址方式时，需指出是否为字节访问及是哪个字节。现代计算机一般采用字节编址方式。
    *   **块寻址 (Block Addressing):** 对一个信息块进行操作时，指令必须对块进行定位。如 VAX 11/780 指令系统中有块操作指令。可采用“首址+块长度”、“首址+末址”或“首址+末端标志”的方式来指定一个块。
### 5.2.4 操作类型
指令系统的完备性要求在设计指令系统时必须考虑指令系统应提供哪些操作类型。对大多数指令系统考察后得知，指令操作类型按功能分为以下几种：
1.  **算术和逻辑运算指令 (Arithmetic and Logic Instructions):**
    *   加(ADD)、减(SUB)、比较(CMP)、乘(MUL)、除(DIV)
    *   与(AND)、或(OR)、取反(NOT)、变补(NEG)、异或(XOR)
    *   加1(INC)、减1(DEC)
    *   带进位的加(ADC)、带借位的减(SBB) (方便多字长运算)
    *   有的计算机还专门设置了十进制数的运算指令。
2.  **移位指令 (Shift Instructions):**
    *   算术移位、逻辑移位、循环移位、半字交换等。
    *   有的机器默认一条指令只移一位，移多位需多条指令。
    *   有的机器可在指令中规定移动的位数，可用一条指令实现。通常用桶形移位器实现一次移动多位。
    *   **算术左移：** 操作数的各位依次向左移，低位补零。有些机器将原操作数的最高位移入进位标志(CF)位。
    *   **算术右移：** 各位依次向右移，高位补符号。有些机器将最低位移入进位标志位。
    *   **逻辑左移：** 操作同算术左移，多数机器不再专门设置。
    *   **逻辑右移：** 各位依次向右移，高位补零。有些机器将原操作数最低位移入进位标志位。
    *   **小循环左移：** 最高位移入进位标志位，同时也移入最低位。
    *   **小循环右移：** 最低位移入进位标志位，同时也移入最高位。
    *   **大循环左移：** 最高位移入进位标志位，而进位标志位移入最低位。
    *   **大循环右移：** 最低位移入进位标志位，而进位标志位移入最高位。
    *   **半字交换：** 寄存器的前半部分和后半部分内容进行交换。
3.  **传送指令 (Data Transfer Instructions):**
    *   寄存器间传送 (MOV)
    *   取数 (LOAD: 内存 -> CPU 寄存器)
    *   存数 (STORE: CPU 寄存器 -> 内存)
4.  **串指令 (String Instructions):**
    *   对字符串进行操作的指令。如串传送、比较、检索、传送转换等指令。
5.  **顺序控制指令 (Program Control Instructions):**
    *   用来控制程序执行的顺序。
    *   条件转移 (BRANCH)、无条件转移 (JMP)、跳步 (SKIP)、调用 (CALL)、返回 (RET) 等。
    *   功能通过将转移目标地址送到 PC 中来实现。
    *   转移目标地址可用直接寻址（绝对转移）或相对寻址（相对转移）给出。有的机器还可用寄存器寻址或寄存器间接寻址。
    *   **无条件转移：** 任何情况下都执行转移。
    *   **条件转移 (分支指令)：** 特定条件满足时才执行转移。转移条件一般是某个标志位的值，或由多个标志位组合而成（如 CF=1, CF=0 或 CF=1 且 ZF=1 等）。
    *   **跳步：** 转移的一种特例，使 PC 再增加一个定值（一般是指令字所占用的存储字个数）。注意取指令时 PC 已增量，跳步实际上是跳过下条指令。
    *   **调用指令 (转子指令)：** 执行时必须保存下条指令的地址（返回地址），用于子程序调用。
    *   **返回指令：** 子程序执行完毕时，将事先保存的返回地址送到 PC。
6.  **CPU 控制指令 (CPU Control Instructions):**
    *   停机、开中断、关中断、系统模式切换以及进入特殊处理程序等指令。
    *   多数机器将这类指令划为“特权”指令 (管态指令)，只能用于内核进程中，用户进程一般不能使用。
7.  **输入、输出指令 (I/O Instructions):**
    *   用于完成 CPU 与外部设备交换数据或传送控制命令及状态信息。
    *   寻址方式一般较少，常见的只有寄存器寻址、直接寻址和寄存器间接寻址等。
    *   当外设中的 I/O 地址空间和主存地址空间统一编址时，可以不设置这类指令，而用访存指令完成 I/O 操作。
### 5.2.5 操作码编码
指令的操作码字段可以是固定长度，也可以是可变长度。选择定长还是可变长是时间和空间之间的开销权衡问题。
*   希望降低空间开销时，代码长度更重要，应采用紧凑的变长操作码和变长指令字。
*   希望降低时间开销以取得更好性能时，应采用定长操作码和定长指令字。
1.  **定长操作码编码 (Fixed-Length Opcode Encoding):**
    *   译码方便，指令执行速度快，但有信息冗余。
    *   例如，IBM 360/370 采用8位定长操作码，最多可有256条指令，但指令系统中只提供了183条，有73种为冗余编码。
    *   (图5.4 IBM 360/370 指令格式) 有 RR, RX, RS, SI, SS 型。RR型为半字长(16位)，SS型为一字半长(48位)，其余为单字长(32位)。操作码的第0和第1位组成4种不同编码，代表4种不同指令类型 (00: RR, 01: RX, 10: RS/SI, 11: SS)。
	    * ![[image-204.png]]  
2.  **扩展操作码编码 (Extended Opcode Encoding):**
    *   将操作码的编码长度分成几种固定长度的格式。可采用等长扩展法（如4-8-12、3-6-9）或不等长扩展法。
    *   操作码长度不固定，是可变的。被大多数非规整型指令集采用。
    *   PDP-11 是典型的变长操作码计算机。(图5.5 PDP-11 指令格式) 其操作码长度依次为4-7-8-10-13-16位。
	    * ![[image-205.png]]
    *   **例5.1：** 某指令系统指令字16位，每个地址码6位。若二地址指令15条，一地址指令34条，则剩下的零地址指令最多有多少条？
        *   **解：** 扩展编码思想是操作码按短到长进行。二地址指令操作码最短，零地址最长。
        *   **二地址指令：** 地址码占12位，操作码只有4位。最多16种编码。用去15种 (0000~1110)，剩一种编码 `1111` 未使用 (作为扩展标志)。
        *   **一地址指令：** 地址码占6位，操作码有10位。最高4位为 `1111`，还剩6位。这6位和前面的 `1111` 一起，总共10位操作码字段。最多可有 2^6 = 64 种编码。
            *   用其中的34种编码，例如 `11110 00000` ~ `11110 11111` (32条) 和 `11111 00000` ~ `11111 00001` (2条) 分别表示34条一地址指令。
            *   此时，以 `11110` 开头的10位操作码用完。以 `11111` 开头的10位操作码中，`11111 00000` 和 `11111 00001` 已用。
        *   **零地址指令：** 共有16位操作码。其高5位只能是 `11111`。
            *   接下来的5位（第6到第10位）不能是 `00000` 和 `00001`（因为这两组已被一地址指令的扩展使用）。
            *   所以这5位可以是 `00010` 到 `11111`，共 32 - 2 = 30 种组合。
            *   剩下的低6位（第11到第16位）可以是任意组合 (2^6 种)。
            *   因此，零地址指令最多有 30 × 2^6 种编码可用。

### *5.2.6 条件码的生成与使用

条件转移指令（也称分支指令）通常根据程序当前生成的**条件码 (Condition Codes, CC)** 进行转移，条件码也称为**状态位 (Status)** 或**标志位 (Flags)**。
常用的标志有4种：
1.  **符号标志 NF (Negative)** (有些系统也用 SF (Sign) 表示): NF=1，表示结果为负数。
2.  **溢出标志 VF (Overflow)** (有些系统也用 OF 表示): VF=1，表示结果溢出。
3.  **进(借)位标志 CF (Carry):** CF=1，表示结果产生了进(借)位。
4.  **零标志 ZF (Zero):** ZF=1，表示结果为0。
可通过执行算术指令或显式地由比较和测试指令来设置标志位。例如：
`sub r1, r2, r3;` (r2和r3相减，结果存在r1中，并生成各种标志位)
`bz label;` (判断是否 ZF=1，若是，则转移到 label 处执行)
生成的标志位可由：
*   **专门的条件码寄存器** (或状态寄存器、标志寄存器、程序状态字寄存器 PSW) 来存放。例如，8086/8088处理器中通过一个专门的16位标志寄存器 flags 来记录标志信息及人为设置的控制信息（也称自陷允许标志），80386以后的标志寄存器又逐步扩展为32位。
*   **指定的通用寄存器** 来存放。例如：
    `cmp r1, r2, r3;` (比较r2和r3，标志位存储在r1中)
    `bgt r1, label;` (根据r1中标志位判断是否大于，以转移到label处)
*   有些指令系统可以用一条 **“计算并转移”** 指令来实现上述两条指令的功能：
    `bgt r1, r2, label;` (根据r1和r2比较的结果，直接决定是否转移)
由此可见，处理条件码生成的方式有多种，实现条件转移的方式也可以各不相同。不管是否保存条件码，也不管将条件码保存在特殊的标志寄存器中还是通用寄存器中，处理器中的运算电路必须能够产生这些基本条件码。

(注①：程序状态字寄存器(PSW)用来存放条件码CC和自陷允许标志(Trap Enable Flag)等状态信息。不同计算机对程序状态的描述以及程序状态存放位置可能不一样。但在概念上应该有一个程序状态字。)
### 5.2.7 指令系统设计风格

1.  **按操作数位置指定风格来分：**

    *   **(1) 累加器 (Accumulator) 型指令系统：**
        *   总是把其中一个操作数隐含在累加器 (一般用 AC 表示) 中，指令执行的结果也总是送到累加器中。
        *   指令字短，但每次运算都要通过累加器，在复杂表达式运算时，程序中会多出许多移入/移出累加器的指令，从而使程序变长，影响程序执行效率。
        *   只在早期机器中使用过，现在一般不采用。
    *   **(2) 堆栈 (Stack) 型指令系统：**
        *   Java 虚拟机采用的是堆栈型指令系统。
        *   堆栈是一种采用后进先出 (LIFO) 或先进后出 (FILO) 存取方式的特定的存储区。
        *   规定指令的操作数总是来自堆栈的栈顶。往堆栈里存数叫入(进)栈或压栈，从堆栈里取数叫出栈或弹出。
        *   可用移位寄存器实现堆栈 (硬件实现，栈顶固定方式堆栈)；也可在内存中开辟堆栈区，栈底固定，栈顶动态变化。CPU 中有专门的栈指针 SP 指示栈顶位置。
        *   有从高地址向低地址增长的“自顶向下”和从低地址向高地址增长的“自底向上”两种形式的内存堆栈区。一般机器采用“自顶向下”形式。
        *   指令都是零地址或一地址指令，因此指令字很短。
        *   但由于指令所用操作数只能来自栈顶，对表达式编译时，生成的指令顺序及操作数在堆栈中的排列都有严格顺序规定，不灵活，带来指令条数增加。
        *   很少被通用计算机使用。
    *   **(3) 通用寄存器 (General Purpose Register, GPR) 型指令系统：**
        *   特点是使用通用寄存器而不是累加器来存放运算过程中所用的临时数据。
        *   指令的操作数可以是立即数 (I)，或来自通用寄存器 (R)，或来自存储单元 (S)。
        *   指令类型可以是 RR 型、RS 型、SI 型、SS 型等。
        *   典型代表是 IA-32，此外还有 Motorola 68xxx、VAX 11/780 等。
    *   **(4) Load/Store 型指令系统：**
        *   也使用通用寄存器而不是累加器来存放运算过程中所用的临时数据，因此也是一种通用寄存器型指令系统。
        *   显著特点是只有取数 (Load) 指令和存数 (Store) 指令才可以访问存储器，运算类指令不能访存，也就是说运算类指令只能是 RR 型或 RI 型。
        *   指令比较规整，体现在每条指令的指令字长度和指令执行时间等能够比较一致。
        *   目前，通用寄存器型指令系统占主导地位。主要因为：
            *   ① 通用寄存器和处理器集成在一起，作为 ALU 的操作数来源，两者可以靠得很近，可缩短传输延迟。
            *   ② 寄存器位于存储器层次化结构的顶端，速度快且容易使用。
            *   寄存器个数不能太多（成本高、延长存取时间使时钟周期变长），也不能太少（编译器只能把许多变量分配到内存单元，影响性能）。
2.  **按指令格式的复杂度来分：**
    *   **(1) CISC (Complex Instruction Set Computer) 风格指令系统：**
        *   随着 VLSI 技术发展，硬件成本不断下降，软件成本不断上升。人们在设计指令系统时增加了越来越多功能强大的复杂命令，以使机器指令的功能接近高级语言语句的功能，给软件提供较好的支持。
        *   例如，VAX 11/780 指令系统包含了16种寻址方式，9种数据格式，303条指令，一条指令包含1~2个字节的操作码和后续N个操作数说明符，一个操作数说明符长度可达1~10个字节。
        *   **CISC 指令系统设计的主要特点：**
            *   ① **指令系统复杂：** 指令多、寻址方式多、指令格式多。
            *   ② **指令周期长：** 绝大多数指令需要多个时钟周期才能完成。
            *   ③ **指令周期差距大：** 各种指令都能访问存储器，使得简单指令和复杂指令所用的时钟周期数相差很大，不利于指令流水线的实现。
            *   ④ **采用微程序控制：** 有些指令非常复杂，以至于无法用组合逻辑控制器来实现，而微程序控制器用软件设计思想实现硬件，可以实现对复杂指令的控制。
            *   ⑤ **难以进行编译优化：** 由于编译器可选指令序列增多，使得目标代码组合增加，从而增加了目标代码优化的难度。
        *   复杂的指令系统使得计算机的结构也越来越复杂，不仅增加了研制周期和成本，而且难以保证其正确性，甚至降低了系统性能。
        *   研究表明，各种指令的使用频率相当悬殊，最常用的是只占指令系统20%的一些简单指令，它们占程序代码的80%以上，而需要大量硬件支持的复杂指令在程序中的出现频率却很低。在微程序控制的计算机中，占程序中指令总数20%的最复杂的指令占用了微程序控制存储器容量的80%。
        *   1975年，IBM公司John Cocke领导的研究小组提出了**精简指令集计算机 (Reduced Instruction Set Computer, RISC)** 的概念。
    *   **(2) RISC (Reduced Instruction Set Computer) 风格指令系统：**
        *   RISC 的着眼点不是简单地放在简化指令系统上，而是通过简化指令使计算机结构更加简单合理，从而提高机器的性能。
        *   **RISC 指令系统的主要特点 (与CISC相比)：**
            *   ① **指令数目少：** 只包含频度高的简单指令。
            *   ② **指令格式规整：** 寻址方式少、指令格式少、指令长度一致。
            *   ③ **采用 Load/Store 型指令设计风格。**
            *   ④ **采用流水线方式执行指令：** 规整的指令格式有利于采用流水线方式执行，除 Load/Store 指令外，其他指令都只需一个或小于一个的时钟周期就可完成，指令周期短。
            *   ⑤ **采用大量通用寄存器：** 编译器可将变量分配到寄存器中，以减少访存次数。
            *   ⑥ **采用组合逻辑电路控制：** 指令少而规整使得控制器的实现变得简单，可以不用或少用微程序控制。
            *   ⑦ **采用优化的编译系统：** 指令数少有利于编译器的优化。
        *   采用 RISC 技术后，由于指令系统简单，CPU 的控制逻辑大大简化，芯片上可设置更多的通用寄存器，指令系统也可以采用速度较快的硬连线逻辑来实现，且更适合于采用指令流水技术，这些都可以使指令的执行速度进一步提高。
        *   20世纪70年代中期，IBM、斯坦福大学、加州大学伯克利分校等机构开始研究RISC技术，成果有IBM 801、斯坦福大学的MIPS、伯克利大学的RISC I。到80年代中期，PowerPC、MIPS、Sun SPARC、Compaq Alpha等高性能RISC芯片及计算机相继出现。
        *   **RISC 与 CISC 之争：** 虽然 RISC 在性能上有优势，但最终 RISC 机并没有在市场上占优势，反而 Intel 一直保持处理器市场的较大份额。原因：
            *   软件的向后兼容性，用户在 Intel 系列机上已有大量软件投资。
            *   RISC 系统也日趋复杂，而 CISC 由于采用了部分 RISC 技术（如 Intel Pentium 4 中将简单指令直接转换为类 RISC 指令，复杂指令用微码实现），使其性能更加提高。这种混合方案能在保证软件兼容的前提下达到具有较强竞争力的整体性能。