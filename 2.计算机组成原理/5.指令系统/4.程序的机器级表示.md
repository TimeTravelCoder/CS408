不管用什么高级语言编写的源程序最终都必须翻译（汇编、解释或编译）成以指令形式表示的机器语言，才能在计算机上运行。本节简单介绍高级语言源程序转换为机器代码过程中涉及的一些基本问题。为方便起见，本节选择具体语言进行说明，高级语言和机器语言分别选用 C 语言和 MIPS 指令系统。其他情况下，其基本原理不变。
### *5.4.1 MIPS 汇编语言和机器语言
机器语言程序是一个由若干条指令组成的序列。从前面对指令格式的介绍可以知道，每条指令由若干字段组成，每个字段都是一串由 0、1 组成的二进制数字序列。所以，程序员要读懂一个机器语言程序很费劲，也很难用机器语言直接编写程序。

为了能直观地表示机器语言程序，引入了一种与机器语言一一对应的符号化表示语言，称为**汇编语言 (Assembly Language)**。汇编语言中，用容易记忆的英文单词或缩写来表示指令操作码的含义，用标号、变量名称、寄存器名称、常数等表示操作数或地址码。这些英文单词或缩写、标号、变量名称等都被称为**助记符 (Mnemonics)**。以下简要介绍 MIPS 指令系统和 MIPS 汇编语言。

**1. MIPS 指令中数据的表示**

*   **寄存器数据 (Register Data):**
    *   MIPS 提供了 32 个 32 位通用寄存器，寄存器编号占 5 位。
    *   **(表5.3 MIPS 通用寄存器)**
      ![[image-211.png]]
    *   寄存器的汇编表示以 `$` 开始，可以使用名称 (如 `$s0`)，也可以使用编号 (如 `$16`)。
    *   MIPS 还提供了 32 个 32 位的单精度浮点寄存器，用汇编符号 `f0`~`f31` 表示。它们可配对成 16 个 64 位浮点寄存器，用来表示 64 位双精度浮点数。
    *   另外，MIPS 中提供了两个乘商寄存器 **Hi** 和 **Lo**，它们是专用寄存器，无须程序员在指令中明显给出。用 32 位的 Hi 和 Lo 可实现 64 位寄存器。在执行乘法运算时，Hi 和 Lo 联合用来存放 64 位乘积；而在执行除法运算时，最终的余数存放在 Hi 中，商在 Lo 中。
    *   MIPS 中用程序计数器 **PC** 指出下条指令的地址，它也是专用寄存器。
*   **存储器数据 (Memory Data):**
    *   MIPS 的存储器按字节编址。
    *   对于存储器数据，其操作数地址为 32 位，通过一个 32 位寄存器的内容加 16 位偏移量得到。
    *   16 位偏移量是带符号数，故可访问的地址空间大小为 2<sup>32</sup> 字节。
    *   采用**大端方式 (Big Endian)** 存放数据。
    *   数据要求按**字边界对齐 (Word Alignment)**。
    *   只能通过 Load/Store 指令访问存储器数据。
*   **立即数操作数 (Immediate Operand):**
    *   指令中给出的位数为 16 位。
    *   指令执行时，需要将其进行符号扩展或 0 扩展，变成 32 位操作数后才能参加运算。
**2. MIPS 指令格式和寻址方式**
MIPS 是典型的 RISC 处理器，采用 32 位定长指令字，操作码字段也是固定长度，没有专门的寻址方式字段，由指令格式确定各操作数的寻址方式。
指令格式只有三种，如图 5.9 所示。
**(图5.9 MIPS 指令格式)**
*   **(a) R-型指令 (R-type Instruction):**
    *   `OP (6) | rs (5) | rt (5) | rd (5) | shamt (5) | func (6)`![[image-213.png]]
    *   是 RR 型指令 (寄存器-寄存器类型)。
    *   操作码 OP 为 "000000"。
    *   操作类型由 `func` (function code) 字段指定。
    *   若是双目运算类指令，则 `rs` 和 `rt` 的内容分别作为第一和第二源操作数，结果送 `rd`。
    *   若是移位指令，则对 `rt` 的内容进行移位，结果送 `rd`，所移位数由 `shamt` (shift amount) 字段给出。因为一条指令需要左移或右移若干位，所以 MIPS 中移位指令多用桶形移位器实现以提高速度。
    *   R-型指令的寻址方式只有一种，就是**寄存器寻址**。

*   **(b) I-型指令 (I-type Instruction):**
    *   `OP (6) | rs (5) | rt (5) | 立即数 (16)`
    * ![[image-216.png]]
    *   是立即数型指令。
    *   若是双目运算类指令，则将 `rs` 的内容和立即数分别作为第一和第二源操作数，结果送 `rt`。
    *   若是 Load/Store 指令，则将 `rs` 的内容和立即数符号扩展后的内容相加作为存储单元地址。Load 指令将内存单元内容送 `rt`；Store 指令将 `rt` 内容送内存单元。
    *   若是条件转移 (分支) 指令，则对 `rs` 和 `rt` 内容进行指定的运算，根据运算的结果，决定是否转到转移目标地址处执行。转移目标地址通过相对寻址方式得到，即将 PC 的内容和立即数符号扩展后的内容相加得到。
    *   由此可知，I-型指令的寻址方式有 4 种：**寄存器寻址、立即数寻址、相对寻址、基址或变址寻址**。

*   **(c) J-型指令 (J-type Instruction):**
    *   `OP (6) | 直接地址 (26)`
    * ![[image-218.png]]
    *   主要是无条件跳转指令。
    *   指令中给出的是 26 位直接地址。只要将当前 PC 的高 4 位拼上 26 位直接地址，最后添两个 "0" 就可以得到 32 位的跳转目标地址。
    *   J-型指令的寻址方式只有一种，就是**变通的直接寻址**。
*   **例5.2 为什么 J-型指令中的跳转目标地址最后两位要添 "0"，如何实现该功能？**
    *   答：因为 MIPS 机器采用 32 位定长指令字，占 4 个字节，其存储单元采用字节编址，所以一条指令占 4 个存储单元。因而，指令地址总是 4 的倍数，最后两位总是 "00"，无须在指令中明显给出。只要在实现指令功能的数据通路中具有添加 "00" 的电路即可。
**3. MIPS 汇编语言**
**(表5.4 MIPS 汇编语言示例列表)** 
![[image-219.png]]
**(表5.5 MIPS 机器代码示例列表)** 
![[image-220.png]]
分别是 MIPS 汇编语言和机器代码示例列表。表 5.4 中列出了常用的 5 类指令：算术运算、存储访问、逻辑运算、条件分支、无条件转移。每类中给出最具代表性的指令的名称、汇编形式示例、含义和文字说明。表 5.5 中给出了常用指令的机器代码示例，分别包括操作码汇编助记符、指令格式类型、指令各字段的十进制值和对应的汇编表示。
从这两个表中可明显看出机器代码和汇编表示的一一对应关系。根据指令代码和汇编表示之间的对应表（称为**指令解码表 (Instruction Decode Table)**），可以很容易地实现两者的转换。
*   从汇编表示转换为机器代码的过程称为“**汇编 (Assemble)**”。
*   从机器代码转换为汇编表示的过程称为“**反汇编 (Disassemble)**”。

*   **例5.3 若从 MIPS 指令机器代码与汇编表示对应表中查出操作码(OP字段) “000000”对应 R-型指令，又从 R-型指令解码表中查到功能码(func字段) “100000”对应 “add”指令。回答以下问题。**
    *   **(1) 汇编表示 “add $t0, $s1, $s2” 对应的 MIPS 指令的机器代码是什么？**
        ![[image-221.png]]

    *   **(2) 假定一条 MIPS 指令的二进制机器代码表示为 `0000 0000 1010 1111 1000 0000 0010 0000`，则该指令对应的 MIPS 汇编表示形式是什么？**
        ![[image-222.png]]
### *5.4.2 选择结构的机器代码表示
过程式程序设计语言提供顺序、选择和循环三种控制结构。选择结构根据判定条件来控制一些语句是否被执行，例如，有 if-then、if-then-else、case (或 switch)、if…goto 等选择语句。对应高级语言中的这些选择语句，在机器语言中提供了各种条件码 (标志位) 的设置功能以及各种分支 (条件转移) 指令和无条件转移指令。编译器通过条件码设置指令和各类转移指令来实现程序中选择结构语句。

*   **例5.4 假定 C 语言赋值语句 “`f = (g + h) - (i + j);`” 中变量 i、j、f、g、h 由编译器分别分配给 MIPS 寄存器 `$t0`~`$t4`。要求给出该语句编译后的 MIPS 机器代码和汇编表示。**
    *   解：只要用三条 R-型指令即可，其中两条 add 指令，一条 sub 指令。所以，三条指令的 OP 字段都为 000000。根据表 5.5 可知，add 指令的 func 字段为 32 = 100000B，sub 指令的 func 字段为 34 = 100010B。从表 5.3 可知，寄存器 `$t0`~`$t4` 对应编号 8~12 (`$t0`=8, `$t1`=9, `$t2`=10, `$t3`=11, `$t4`=12)。
    *   分配：i -> `$t0`(8), j -> `$t1`(9), f -> `$t2`(10), g -> `$t3`(11), h -> `$t4`(12)。
    *   则 g+h 的结果放在临时寄存器 `$t5`(13)，i+j 的结果放在临时寄存器 `$t6`(14)。
    *   汇编及机器码 (#后为注释):
        ```assembly
        # f = (g+h) - (i+j)
        # $t2 = ($t3+$t4) - ($t0+$t1)
        # 假设 $t5 用于存 g+h, $t6 用于存 i+j
        
        # add $t5, $t3, $t4   # $t5 = g + h
        # OP=0, rs=$t3(11), rt=$t4(12), rd=$t5(13), shamt=0, func=32
        000000 01011 01100 01101 00000 100000  
        
        # add $t6, $t0, $t1   # $t6 = i + j
        # OP=0, rs=$t0(8), rt=$t1(9), rd=$t6(14), shamt=0, func=32
        000000 01000 01001 01110 00000 100000  
        
        # sub $t2, $t5, $t6   # $t2 = $t5 - $t6  (f = (g+h) - (i+j))
        # OP=0, rs=$t5(13), rt=$t6(14), rd=$t2(10), shamt=0, func=34
        000000 01101 01110 01010 00000 100010  
        ```

*   **例5.5 以下是一个 C 程序段：`if (i == j) f = g + h; else f = g - h;` 假定 i、j、f、g、h 由编译器分别分配给 MIPS 寄存器 `$s1, $s2, $s3, $s4, $s5`。要求给出编译后的 MIPS 汇编表示。**
    *   解：首先要有一条分支指令能根据 i、j 是否相等进行转移，所以，选用表 5.4 中 `beq` (branch on equal) 或 `bne` (branch on not equal) 指令。此外，还要有一条无条件转移指令，可选用表 5.5 中的 `j` (jump) 指令。
    ```assembly
          bne $s1, $s2, else      # if (i != j) jump to else_label
          add $s3, $s4, $s5       # f = g + h (i == j path)
          j   exit                # jump to exit
    else:
          sub $s3, $s4, $s5       # f = g - h (i != j path)
    exit:
    ```

*   **例5.6 以下是一个 C 程序段：`if (i < j) f = g + h; else f = g - h;` 假定 i、j、f、g、h 由编译器分别分配给 MIPS 寄存器 `$s1, $s2, $s3, $s4, $s5`。要求给出编译后的 MIPS 汇编表示。**
    *   解：首先要有一条比较 i、j 大小的指令，该指令能根据比较结果设置标志位，然后用分支指令根据标志位的值进行转移。所以，应选用表 5.4 中的 `slt` (set on less than) 指令、`beq` 或 `bne` 指令。在比较标志位的值时，需要判断是否为 0，此时，用 0 号寄存器 `$zero` 表示 0。
    ```assembly
          slt $t0, $s1, $s2       # if (i < j) $t0 = 1, else $t0 = 0
          beq $t0, $zero, else    # if ($t0 == 0, i.e., i >= j) jump to else
          add $s3, $s4, $s5       # f = g + h (i < j path)
          j   exit                # jump to exit
    else:
          sub $s3, $s4, $s5       # f = g - h (i >= j path)
    exit:
    ```

### *5.4.3 循环结构的机器代码表示
循环结构是指可重复执行的一组语句，例如，有 while、until、for、loop…、goto loop 等循环语句。分支指令在循环结构中也起重要作用，主要用来判断循环条件是否结束。此外，大多数循环体内需要对数组元素进行处理，因此，需要用到自动变址寻址。如果指令系统不提供自动变址，则编译器需要选用对变址器进行增量的指令来使每次循环按顺序取不同的数组元素。
*   **例5.7 以下是一个 C 程序段：**
    ```c
    while (i != k) {
        x = x + A[i];
        i = i + 1;
    }
    ```
    **假定 x、i、k 由编译器分别分配给 MIPS 寄存器 `$s1, $s2, $s3`，数组 A 的每个元素为一个 32 位字，首地址存放在 `$s5` 中。要求给出编译后的 MIPS 汇编表示。**
    *   解：循环体内有一个数组元素的访问，首先要计算每次循环中数组元素 A[i] 的地址，它应等于 A 的首地址加上偏移量。因为是字数组，所以偏移量等于 i × 4。可以用乘法指令实现，也可以用加法指令 (两次加倍) 或移位指令 (左移两位) 来实现 ×4。从前面第3章介绍的运算算法来看，乘法指令所需的时间最长，所以一般不用乘法指令实现 ×4 操作。从内存取数组元素用指令 `lw` (load word) 实现。
    *   循环开始时，先用分支指令 `beq` 判断循环结束条件，以便在循环结束条件满足时跳出循环体。循环结束后的第一条指令用一个标号 `Exit` 标识；循环最后要有一条无条件转移指令 `j`，以转到循环体的开始，循环体内第一条指令的标号为 `Loop`。
    *   MIPS 没有自动变址寻址，所以用一条显式加法指令 `addi` (add immediate) 实现数组下标增量。
    ```assembly
    Loop:
          beq  $s2, $s3, Exit      # while (i == k) jump to Exit
          
                                   # Calculate address of A[i]
          sll  $t0, $s2, 2         # $t0 = i * 4 (left shift by 2)
          add  $t0, $t0, $s5       # $t0 = address of A[i] (base address + offset)
          
          lw   $t1, 0($t0)         # $t1 = A[i] (load word from memory)
          add  $s1, $s1, $t1       # x = x + A[i]
          
          addi $s2, $s2, 1         # i = i + 1
          j    Loop                  # jump to beginning of loop
    Exit:
    ```

### *5.4.4 过程调用的机器代码表示
子程序 (Procedure/Subroutine/Function) 的使用有助于提高程序的可读性，并有利于代码重用，它是程序员进行模块化编程的重要手段。子程序的使用主要是通过过程或函数调用实现。为叙述方便起见，本教材**将过程 (调用) 和函数 (调用) 统称为过程 (调用) (Procedure Call)**。过程允许程序员使用参数将过程与其他程序和数据分离，调用过程只要传送输入参数给被调用过程，最后再由被调用过程返回结果参数给调用过程即可。引入过程使得每个程序员只需要关注本模块中函数或过程的编写任务。
将整个程序分成若干模块后，编译器对每个模块分别编译。为了彼此统一，并能配合操作系统工作，编译的模块代码之间必须遵循一些调用接口约定 (Calling Convention)。这些约定由编译器强制执行，汇编程序员也必须强制按照这些约定执行，包括寄存器的使用、堆栈建立和参数传递等。

**1. MIPS 中用于过程调用的指令**
*   **调用指令 (Call Instruction):** 是一种无条件转移指令，在 MIPS 中称为**跳转并链接 (jump and link)** 指令，指令名称为 `jal`。
    *   采用 J-型格式。
    *   具有两个功能：
        1.  保存下条指令地址（即 PC+4，返回地址）到 31 号寄存器 (`$ra`)。
        2.  跳转到指定地址处执行。
    *   其汇编形式和指令格式分别参见表 5.4 和表 5.5。例如，指令 “`jal 10000`” 的功能为 `$31 = PC+4; go to 10000`。
*   **返回指令 (Return Instruction):** 也是一种无条件转移指令，在 MIPS 中称为**寄存器跳转 (jump register)** 指令，指令名称为 `jr`。
    *   采用 R-型格式。
    *   其功能为跳转到寄存器指定的地址处执行。
    *   其汇编形式和指令格式分别参见表 5.4 和表 5.5。例如，指令 “`jr $31`” 的功能为转到调用程序的返回地址 (在 `$31` 中保存) 处执行。
    *   `jr` 指令中的寄存器也可以是除 `$31` 以外的其他寄存器，所以，`jr` 指令也可用于 switch 或 case 语句中的跳转执行。
**2. 过程调用时 MIPS 寄存器的使用约定**
假定过程 P 调用过程 Q，则过程调用的执行步骤如下：
1.  P 将入口参数放到 Q 能访问到的地方。
2.  P 将返回地址存到特定的地方，然后将控制转移到 Q。
3.  Q 为 P 保存现场，并为自己的局部变量分配空间。
4.  执行过程 Q。
5.  Q 将返回结果放到 P 能访问到的地方。
6.  Q 取出返回地址，将控制转移到 P。
从上述执行步骤来看，在过程调用中，需要为入口参数、返回地址、调用过程执行时用到的寄存器、被调用过程中的局部变量、过程返回时的结果等数据找到存放空间。如果有足够的寄存器，最好把这些数据都保存在寄存器中，这样，CPU 执行指令时，可以快速地从寄存器取得这些数据进行处理。但是，用户可见寄存器数量有限；并且它们是所有过程共享的资源，给定时刻只能被一个过程使用；此外，对于过程中使用的局部数组和结构等复杂类型数据也不可能保存在寄存器中。因此，除了寄存器外，还需要一个专门的存储结构来保留这些数据，这个存储结构就是**栈 (Stack)**，也称为堆栈。那么，上述数据中哪些存放在寄存器，哪些存放在堆栈中呢？寄存器和栈的使用又有哪些规定呢？
尽管硬件对寄存器的用法几乎没有任何规定，CPU 实现指令功能时完全不用考虑寄存器的功能，但在软件实际使用寄存器时还要遵循一定的惯例，使程序员、编译器和操作系统等都按照统一的约定处理。
假定过程 P 调用过程 Q，则 MIPS 程序中对过程调用时寄存器的使用规定如下 (参见表 5.3)：
*   **(1) `$a0`~`$a3` (Argument Registers):** 用于传递前 4 个非浮点数入口参数。在过程 P 中应先将入口参数送入 `$a0`~`$a3`，然后调用 Q。若入口参数超过 4 个，则其余参数保存到栈中。
*   **(2) `$v0`~`$v1` (Value Registers):** 用于传递从 Q 返回的非浮点数返回参数。在过程 Q 中应先将返回参数送入 `$v0`~`$v1` 再返回 P。
*   **(3) `$ra` (Return Address Register):** 用于存放返回地址。由调用指令 (`jal`) 自动将返回地址送入 `$ra`。
*   **(4) `$s0`~`$s7` (Saved Registers):** 在过程 P 中原来的老值从过程 Q 返回后可被 P 继续使用。因此，若在过程 Q 中使用这些寄存器，则必须先将其保存到栈后才能使用，并在返回 P 前恢复。因此，它们被称为**保存寄存器 (Callee-saved registers)**。
*   **(5) `$t0`~`$t9` (Temporary Registers):** 的值从过程 Q 返回后在 P 中不再需要使用，若需要则由 P 自己保存。因此，在过程 Q 中不需对其保存，可以自由使用。因此，它们被称为**临时寄存器 (Caller-saved registers)**。
*   (6) `$a0`~`$a3` 的值从过程 Q 返回后在 P 中也不再需要使用，若需要则由 P 自己保存。因此，过程 Q 不需要为过程 P 对其进行保存。
**3. MIPS 中的栈和栈帧**
上文提到，过程调用时的一些数据除了可存放到寄存器外，还有一些数据被存放到栈中。MIPS 中有一个专门的栈指针寄存器 **`$sp` (Stack Pointer)**，用来指示栈顶元素。栈中每个元素的长度为 32 位。没有专门的入栈指令 (push) 和出栈指令 (pop)。入栈、出栈操作用 `sw` (store word) / `lw` (load word) 指令实现，因而不能自动进行栈指针调整，需用 `addi` 指令调整 `$sp` 的值。

MIPS 中，栈从高地址向低地址方向“增长”，而取数/存数是从低地址向高地址方向进行 (MIPS 采用大端方式)。
*   每入栈一个字，则 `$sp - 4 -> $sp`。
*   每出栈一个字，则 `$sp + 4 -> $sp`。

*   **例5.8 假定将返回地址 `$ra` 和参数 `$a0` 保存到栈中，写出其指令序列，并画图说明 `$ra` 和 `$a0` 在栈中的位置。**
    *   解：假定栈指针寄存器 `$sp` 指向栈顶。返回地址 `$ra` 和参数 `$a0` 从栈顶处开始存放，其存放位置如图 5.12 所示。
    *   (图5.12 栈中数据的存放： 过程调用前`$sp` -> ... | 过程执行中`$sp` -> `$a0` | (`$sp`+4) -> `$ra` | ... 高地址)
	    * ![[image-223.png]]
    *   在栈中保存信息的指令序列如下：
        ```assembly
        addi $sp, $sp, -8   # Allocate space on stack (decrement $sp)
        sw   $ra, 4($sp)    # Save $ra at $sp+4
        sw   $a0, 0($sp)    # Save $a0 at $sp
        ```

每个过程都有自己的栈区，称为**栈帧 (Stack Frame)**。因此，一个栈由若干栈帧组成。每个栈帧用专门的**帧指针寄存器 (Frame Pointer)** 指定起始位置，MIPS 中的帧指针寄存器是 **`$fp`**。当前栈帧范围在帧指针 `$fp` 和栈指针 `$sp` 指向区域之间。过程执行时，由于不断有数据入栈，所以栈指针会动态移动，而帧指针可以固定不变。对程序来说，用固定的帧指针来访问变量要比用变化的栈指针方便得多，也不易出错。因此，在一个过程内对栈中信息的访问大多通过帧指针进行。但是，如果当前过程的栈帧 (即当前栈帧) 中没有局部变量，则编译器大多不设置和恢复帧指针，以减少时空开销。当需要使用帧指针 `$fp` 时，通常以过程调用时的栈指针 `$sp` 或 `$sp-4` 作为其初始值。这样，`$fp` 总是指向当前栈帧前一个字或当前栈帧第一个字的起始位置。
假定过程 P 调用过程 Q：
*   则在调用过程 P 中入栈保存的信息称为**调用者保存信息 (Caller-saved information)**，存放在过程 P 的栈帧中。
*   在被调用过程 Q 中入栈保存的信息称为**被调用者保存信息 (Callee-saved information)**，存放在 Q 的栈帧中。
*   (图5.13 过程调用时 MIPS 中的栈和栈帧的变化)
	* ![[image-224.png]]
    *   **(a) 过程调用前：** P 的栈帧包含其临时寄存器 `$t0`~`$t9` (必要时)、参数寄存器 `$a0`~`$a3` (必要时)、其余输入参数 (>4个时)。
    *   **(b) 过程调用中 (在 Q 内)：** Q 的栈帧 (当前栈帧) 位于 `$fp` 和 `$sp` 之间。
        *   如果 Q 是嵌套调用 (会调用其他过程)，则保存 `$ra` (返回地址)。
        *   如果 Q 用到了 `$s0`~`$s7` (保存寄存器)，则保存它们。
        *   如果 Q 有局部数组和结构等，则为其分配空间。
        *   如果 `$fp` 有被破坏的情况 (如嵌套调用)，则保存旧 `$fp`。
        *   如果是递归调用，则所有输入参数都需要入栈保存。
    *   **(c) 过程调用后 (返回 P)：** 栈的状态恢复到调用 Q 之前的状态。被调用过程 Q 在返回前，必须释放局部变量占用的栈区，并恢复保存的各个寄存器，最后可根据 `$fp` 的值恢复进入被调用过程时的栈指针 `$sp`。
**4. MIPS 过程调用协议 (Procedure Calling Convention)**
在程序执行过程中，每调用一次过程，都会在栈中生成一个对应的新栈帧；而在执行返回指令前对应的栈帧在栈中都已被释放。栈帧的生成和释放方式可以有多种方式，但不管采用什么方式，调用程序和被调用程序都必须遵循一定的步骤。
以下步骤是大多数 MIPS 系统采用的过程调用协议：
*   **(1) 调用程序 P 在过程调用前的执行步骤：**
    *   ① 将前 4 个参数送到 `$a0`~`$a3`，其他参数压入当前栈帧。
    *   ② 若 P 在返回后还要用到 `$a0`~`$a3` 和 `$t0`~`$t9` 中某些寄存器，则需将这些寄存器压到当前栈帧中。
    *   ③ 执行 `jal` 指令，以将返回地址保存到 `$ra` 中，并将控制转移到被调用程序。
*   **(2) 被调用程序 Q 中的执行步骤：**
    *   由三段组成：**开始段 (Prologue)**、**本体段 (Procedure Body)** (过程体) 和 **结尾段 (Epilogue)**。本体段进行具体处理。
    *   **开始段**主要进行栈帧生成、寄存器保存和局部变量空间申请。其处理步骤如下：
        *   ① 通过调整栈指针 `$sp` 来申请栈帧 (即将 `$sp` 的值减去栈帧大小)。
        *   ② 若 Q 中用到 `$s0`~`$s7` 中的某些寄存器，则需将这些寄存器压入当前栈帧。
        *   ③ 若 Q 需调用其他过程 (即 Q 不是叶子过程)，则将 `$ra` 和帧指针 `$fp` 压入当前栈帧。
        *   ④ 若 Q 中的局部变量发生寄存器溢出 (即寄存器不够分配)，则局部变量在 Q 的栈帧中分配空间；若有像数组和结构之类的复杂类型局部变量，则在当前栈帧中分配空间。
        *   ⑤ 设置帧指针 `$fp`，其值为当前栈指针 `$sp` 加栈帧大小再减 4。(或者 `$fp = $sp + stack_frame_size - 4`，或者 `$fp` 指向 `$sp` 调整前的位置)。
        *   由此可见，栈帧大小应至少等于上述 ②、③、④ 三个步骤中用到的存储单元的总和。
    *   **结尾段**主要进行寄存器恢复、栈帧释放，并返回到调用程序。其处理步骤如下：
        *   ① 若保存了 `$s0`~`$s7` 中某些寄存器值，则将这些值从当前栈帧中恢复到寄存器。
        *   ② 若保存了返回地址和帧指针，则将它们分别恢复到寄存器 `$ra` 和 `$fp` 中。
        *   ③ 调整栈指针 `$sp` 以释放栈帧 (即将 `$sp` 的值加上栈帧大小，或将 `$fp` 的值送 `$sp`)。
        *   ④ 用返回指令 “`jr $ra`” 将控制权返还给调用程序。
*   **例5.9 写出以下 C 语言过程对应的 MIPS 汇编表示。**
    ```c
    void swap (int v[], int k) {
        int temp;
        temp = v[k];
        v[k] = v[k+1];
        v[k+1] = temp;
    }
    ```
    *   解：`swap` 子程序不是主程序 (main 函数)，因此是一个被调用过程。但它不再调用其他过程，所以是个**叶子过程 (Leaf Procedure)**。
    *   按照调用协议，调用 `swap` 过程的程序已将参数 `v` (数组指针) 和 `k` 分别放在参数寄存器 `$a0` 和 `$a1` 中。参数 `v` 是一个数组的指针。
    *   假定在 `swap` 过程体中先使用临时寄存器 `$t0`~`$t9`，不够时再使用保存寄存器 `$s0`~`$s7`。局部变量 `temp` 分配在寄存器 `$t0` 中。如果临时寄存器够用的话，则不需要在栈帧中保存调用程序的现场，即不需将 `$s0`~`$s7` 的值保存在栈帧中。
    *   按照上述 MIPS 过程调用协议，开始段无须保存任何寄存器的值，也无须进行局部变量分配 (因为是叶子过程，且假设寄存器够用)，故无须保存返回地址和帧指针。由此可见 `swap` 对应的栈帧为空。结尾段直接返回即可。
    ```assembly
    swap:
        # No prologue needed for leaf procedure with no stack usage
        
        sll  $t1, $a1, 2        # $t1 = k * 4 (offset for v[k])
        add  $t1, $t1, $a0    # $t1 = address of v[k]
        
        lw   $t0, 0($t1)        # temp = v[k]  ($t0 = temp)
        lw   $t2, 4($t1)        # $t2 = v[k+1]
        
        sw   $t2, 0($t1)        # v[k] = v[k+1]
        sw   $t0, 4($t1)        # v[k+1] = temp
        
        jr   $ra                # return to caller
    ```

*   **例5.10 以下是三个 C 语言过程，假定过程 `set_array` 第一个被调用，全局变量 `i` 分配到寄存器 `$s0` 中。要求写出每个过程对应的 MIPS 汇编表示，并画出每个过程调用前、后栈中的状态以及帧指针和栈指针的位置。**
    ```c
    int i; // global variable, assumed $s0
    
    void set_array (int num) {
        int array[10];
        for (i = 0; i < 10; i++) {
            array[i] = compare(num, i);
        }
    }
    
    int compare (int a, int b) {
        if (sub(a, b) >= 0)
            return 1;
        else
            return 0;
    }
    
    int sub (int a, int b) {
        return a - b;
    }
    ```
    *   解：程序由三个过程组成，全局静态变量有一个 `i`，假定分配给 `$s0`。为了尽量减少指令条数，并减少访问内存次数。在每个过程的过程体中一般先使用临时寄存器 `$t0`~`$t9`，临时寄存器不够或者某个值在调用过程返回后还需要用，就使用保存寄存器 `$s0`~`$s7`。MIPS 指令系统中没有寄存器传送指令，为了提高汇编表示的可读性，引入一条伪指令 `move` 来表示寄存器传送，汇编器将其转换为具有相同功能的机器指令。伪指令 “`move $t0, $s0`” 对应的机器指令为 “`add $t0, $zero, $s0`”。

    *   **(1) 过程 `set_array`：**
        *   入口参数为 `num` (在 `$a0` 中)。没有返回参数。有一个局部数组 `array[10]`。被调用过程为 `compare`。
        *   因此，其栈帧中除了保留所用的保存寄存器外，必须保留返回地址 (因为调用了 `compare`)，是否保存 `$fp` 要看具体情况 (如果确保后面都不用到 `$fp`，则可以不保存，但为了保证 `$fp` 的值不被后面的过程覆盖，通常情况下，应该保存 `$fp` 的值)，并给局部数组预留 4×10=40 个字节的空间。
        *   从过程体来看，从 `compare` 返回后还需要用到数组基地址，故将其分配给 `$s1`。因此要用到的保存寄存器有两个：`$s0` (全局变量 `i`) 和 `$s1`。其中 `$s0` 中 `i` 是一个全局变量，所以只有 `$s1` 需要保存在栈中。另外加上返回地址、帧指针和局部数组，其栈帧空间最少为 4×3 + 40 = 52B。
        ```assembly
        set_array:
            # Prologue
            addi $sp, $sp, -52      # Allocate stack frame (52 bytes)
            sw   $ra, 48($sp)       # Save return address
            sw   $fp, 44($sp)       # Save old frame pointer
            sw   $s1, 40($sp)       # Save $s1 (array base pointer)
            # $s0 is global, not saved here unless modified by compare/sub AND used after
            addi $fp, $sp, 48       # Set new frame pointer (pointing to $ra or base of local vars)
                                    # Or: addi $fp, $sp, 52 (if fp points to top of frame)
                                    # Conventionally, $fp points to a fixed location in the frame.
                                    # Here, let's assume $fp points to where $ra was saved, or slightly above.
                                    # A common convention is $fp points where old $fp is saved.
                                    # Let's use $fp = $sp + (frame_size - 4), so $fp = $sp + 48 (points to $ra)
            
            move $s1, $sp           # $s1 = base address of array[10] (array is on stack, $sp is its base)
            move $t0, $a0           # $t0 = num (argument to compare)
            
            move $s0, $zero         # i = 0 (global $s0)
        for_loop:
            slti $t1, $s0, 10       # $t1 = (i < 10)
            beq  $t1, $zero, exit_set_array # if (i >= 10) exit loop
            
            move $a0, $t0           # Arg1 for compare = num
            move $a1, $s0           # Arg2 for compare = i
            jal  compare            # Call compare(num, i)
                                    # Result of compare is in $v0
            
            sll  $t1, $s0, 2         # $t1 = i * 4 (offset for array[i])
            add  $t1, $s1, $t1       # $t1 = address of array[i] ($s1 is base of array)
            sw   $v0, 0($t1)         # array[i] = result of compare
            
            addi $s0, $s0, 1         # i = i + 1
            j    for_loop
            
        exit_set_array:
            # Epilogue
            lw   $s1, 40($sp)       # Restore $s1
            lw   $fp, 44($sp)       # Restore old frame pointer
            lw   $ra, 48($sp)       # Restore return address
            addi $sp, $sp, 52      # Deallocate stack frame
            jr   $ra                # Return to caller
        ```

    *   **(2) 过程 `compare`：**
        *   入口参数为 `a` (在 `$a0`) 和 `b` (在 `$a1`)。有一个返回参数 (在 `$v0`)。没有局部变量。被调用过程为 `sub`。
        *   所以其栈帧中除了保留所用的保存寄存器外，还必须保留返回地址和旧 `$fp` 的值。
        *   因为 `compare` 过程的参数和 `sub` 过程的入口参数一样，所以在调用 `sub` 前没有对 `$a0` 和 `$a1` 寄存器送参数。
        *   No saved registers ($s0-$s7) are modified by `compare` itself (assuming `sub` doesn't modify them unexpectedly or that `compare` doesn't need their original values after `sub` call).
        *   Stack frame size: 4 bytes for $ra + 4 bytes for $fp = 8 bytes.
        ```assembly
        compare:
            # Prologue
            addi $sp, $sp, -8       # Allocate stack frame (8 bytes)
            sw   $ra, 4($sp)        # Save return address
            sw   $fp, 0($sp)        # Save old frame pointer
            addi $fp, $sp, 4        # Set new frame pointer (points to $ra)
            
            # Parameters $a0, $a1 are already set for sub
            jal  sub                # Call sub(a, b)
                                    # Result of sub is in $v0
                                    
            slt  $t1, $v0, $zero    # $t1 = (sub_result < 0)
            beq  $t1, $zero, else_compare # if (sub_result >= 0) jump to else_compare
            
            # if (sub_result < 0)
            move $v0, $zero         # return 0
            j    exit_compare
            
        else_compare:
            # if (sub_result >= 0)
            ori  $v0, $zero, 1      # return 1
            
        exit_compare:
            # Epilogue
            lw   $fp, 0($sp)        # Restore old frame pointer
            lw   $ra, 4($sp)        # Restore return address
            addi $sp, $sp, 8       # Deallocate stack frame
            jr   $ra                # Return to caller
        ```

    *   **(3) 过程 `sub`：**
        *   入口参数为 `a` (在 `$a0`) 和 `b` (在 `$a1`)。有一个返回参数 (在 `$v0`)。没有局部变量。是叶子过程，且过程体中没有用到任何保存寄存器。
        *   所以栈帧中不需要保留任何信息 (如果保留返回地址和 `$fp` 也不会错，但需要额外的指令来执行保存和恢复操作，增加了程序的执行时间，因此，一般不对叶过程的返回地址进行保存)。
        ```assembly
        sub:
            # No prologue needed for leaf procedure that doesn't use stack/saved registers
            sub  $v0, $a0, $a1      # return a - b
            jr   $ra                # Return to caller
        ```

    *   **(图5.14 例5.10 的堆栈中栈指针、帧指针的变化以及所保存的信息)**
        *   **(a) 初始状态:** `$sp` 指向某个位置。
        *   **(b) `set_array` 的栈帧:** `$sp` 下移52。`$fp_set_array` 指向旧 `$fp` (或 `$ra`) 位置。保存了 `$ra_caller`, 旧`$fp_caller`, `$s1`。局部数组 `array[10]` 在栈帧底部。
        *   **(c) `compare` 的栈帧 (当 `set_array` 调用 `compare` 时):** `$sp` 再下移8。`$fp_compare` 指向旧 `$fp_set_array` (或 `$ra_set_array`)。保存了 `$ra_set_array`, 旧`$fp_set_array`。
        *   **(d) `sub` 的栈帧为空 (当 `compare` 调用 `sub` 时):** `$sp` 和 `$fp` 可能不发生变化 (因为是叶子过程且不使用栈)。控制直接返回 `compare`。

    *   需要说明的是，本例给出的程序是示意性的，实际上该程序没有任何意义。因为过程 `set_array` 所做的工作就是把比较的结果写到数组 `array` 中，没有任何返回值，但数组 `array` 是局部的，当从 `set_array` 返回后，该过程的栈帧全部被释放，`array` 中的值也全部无效，所以程序没有做任何工作。此外，从上述例子可以看出，如果全部利用栈指针 `$sp` 来访问栈帧是可以实现的，所以，MIPS 中的 30 号寄存器 `$30` 可以作为帧指针 `$fp`，也可以在不想利用它来访问栈帧时把它作为保留寄存器 `$s8` 使用。

