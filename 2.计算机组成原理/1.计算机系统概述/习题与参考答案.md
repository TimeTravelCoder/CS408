

**习题1 (概念解释)**
这部分需要您根据教材1.1至1.6节的内容，准确复述或概括各个概念的定义和核心含义。
1.  **系列机 (Series of Machines / Machine Family)**：指具有相同或相似指令集体系结构 (ISA)，但可能在性能、价格、物理实现等方面有所不同的一组计算机。它们通常能够运行相同的软件。
2.  **兼容性 (Compatibility)**：
    *   **向上兼容**：新一代计算机能够运行为旧一代计算机编写的软件。
    *   **向下兼容**：(较少见) 旧一代计算机能够运行为新一代计算机编写的部分软件 (通常功能受限)。
    *   主要是指软件层面的兼容，即程序在不同机器上的可移植性。
3.  **中央处理器 (CPU)**：计算机的核心部件，负责解释和执行指令，进行算术逻辑运算，控制计算机各部件协调工作。
4.  **算术逻辑单元 (ALU)**：CPU中负责执行算术运算 (加减乘除) 和逻辑运算 (与或非异或) 的部件。
5.  **数据通路 (Datapath)**：CPU内部用于传送和处理数据的路径，包括ALU、寄存器、内部总线等。
6.  **控制器 (Controller)**：CPU中负责对指令进行译码，并根据指令产生控制信号，指挥数据通路和其他部件按正确的顺序执行操作的部件。
7.  **主存 (Main Memory)**：也称内存，计算机中用于存放当前正在运行的程序和数据的存储器，CPU可以直接访问。
8.  **系统软件 (System Software)**：为管理计算机硬件、提供运行环境以及支持应用软件开发和运行而设计的软件，如操作系统、编译程序、数据库管理系统等。
9.  **应用软件 (Application Software)**：为解决特定用户问题或满足特定应用需求而编写的软件，如字处理软件、游戏软件、财务软件等。
10. **高级语言 (High-Level Language)**：面向程序员、更接近自然语言或数学语言的编程语言，独立于具体机器硬件，如C、Java、Python。
11. **汇编语言 (Assembly Language)**：机器语言的符号表示，使用助记符代替二进制指令码，与特定机器的指令集相关。
12. **机器语言 (Machine Language)**：计算机硬件能直接识别和执行的二进制指令码。
13. **源程序 (Source Program)**：用高级语言或汇编语言编写的程序文本。
14. **目标程序 (Object Program / Target Program)**：源程序经过编译或汇编后生成的机器语言程序或中间代码。
15. **编译程序 (Compiler)**：将高级语言源程序一次性全部翻译成等价的机器语言目标程序或汇编语言程序的系统软件。
16. **解释程序 (Interpreter)**：将源程序中的语句按其执行顺序逐条翻译成机器指令并立即执行的系统软件，不生成独立的目标程序。
17. **汇编程序 (Assembler)**：将汇编语言源程序翻译成等价的机器语言目标程序的系统软件。
18. **操作系统 (Operating System)**：管理计算机硬件和软件资源，控制程序执行，改善人机界面，并为应用软件提供支持的一种系统软件。
19. **最终用户 (End User)**：使用应用程序完成特定任务的计算机用户。
20. **系统管理员 (System Administrator)**：负责配置、管理和维护计算机系统软硬件的专业人员。
21. **应用程序员 (Application Programmer)**：使用编程语言开发应用软件的程序员。
22. **系统程序员 (System Programmer)**：设计和开发系统软件 (如操作系统、编译器) 的程序员。
23. **指令系统 (Instruction Set)**：一台计算机硬件能直接识别和执行的所有指令的集合。
24. **指令集体系结构 (ISA)**：计算机系统中对程序员可见的部分，定义了指令格式、数据类型、寻址方式、寄存器组织等，是软硬件之间的接口。
25. **透明性 (Transparency)**：在计算机系统中，某个实际存在的事物或概念对于特定层次的用户来说是不可见的或无需关心的现象。
26. **响应时间 (Response Time)**：从任务提交到任务完成所花费的总时间，也称执行时间或延迟。
27. **吞吐率 (Throughput)**：单位时间内计算机系统完成的任务数量或处理的数据量。
28. **CPU执行时间 (CPU Execution Time)**：CPU实际用于执行一个程序的时间，不包括等待I/O等的时间。
29. **用户CPU时间 (User CPU Time)**：CPU执行用户程序代码所花费的时间。
30. **系统CPU时间 (System CPU Time)**：CPU为执行用户程序而运行操作系统代码所花费的时间。
31. **系统性能 (System Performance)**：通常指整个计算机系统的响应时间或吞吐率。
32. **CPU性能 (CPU Performance)**：通常指CPU执行时间的长短，是衡量CPU处理速度的指标。
33. **时钟周期 (Clock Cycle)**：CPU主时钟的一个周期，是计算机执行操作的最基本时间单位。
34. **主频 (Clock Rate)**：CPU主时钟的频率，等于时钟周期的倒数，通常用Hz表示。
35. **CPI (Cycles Per Instruction)**：执行一条指令平均所需的时钟周期数。
36. **基准测试程序 (Benchmark Program)**：专门用于评估计算机性能的一组标准化程序。
37. **SPEC基准程序集 (SPEC Benchmark Suite)**：由标准性能评估组织(SPEC)制定的一系列用于评估计算机不同方面性能的基准测试程序。
38. **SPEC比值 (SPEC Ratio)**：被测计算机运行SPEC基准程序的时间与参考计算机运行时间的比值，用于衡量相对性能。
39. **MIPS (Million Instructions Per Second)**：每秒执行百万条指令数，用于衡量计算机的指令处理速度。
40. **峰值MIPS (Peak MIPS)**：在理想条件下，计算机所能达到的最大MIPS值。
41. **相对MIPS (Relative MIPS)**：被测计算机MIPS值与某个参考计算机MIPS值的比值。
42. **MFLOPS (Million Floating-point Operations Per Second)**：每秒执行百万次浮点运算数，用于衡量计算机的浮点运算能力。

**习题2 (简单回答)**

* (1) **冯·诺依曼计算机由哪几部分组成？各部分的功能是什么？采用什么工作方式？**
    *  **组成**：运算器、控制器、存储器、输入设备、输出设备。
    *   **功能**：
        *   运算器：执行算术和逻辑运算。
        *   控制器：指挥协调各部件工作，解释和执行指令。
        *   存储器：存放程序和数据。
        *   输入设备：将外部信息输入计算机。
        *   输出设备：将计算机处理结果输出。
    *   **工作方式**：“存储程序”控制方式，即程序和数据预先存入存储器，计算机自动按序执行指令。

* (2) **摩尔定律的主要内容是什么？**
    *   当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。简言之，微处理器的性能每隔大约18个月会翻一番，或者说相同性能的微处理器价格会下降一半。

* (3) **计算机系统的层次结构如何划分？计算机系统的用户可分哪几类？每类用户工作在哪个层次？**
    *   **层次结构划分 (从高到低)**：
        *   应用软件层
        *   系统软件层 (包括高级语言处理程序、操作系统等)
        *   硬件层 (ISA是软硬件界面)
    *   **用户分类及工作层次**：
        *   **最终用户**：工作在应用程序级，使用应用软件。
        *   **应用程序员**：工作在高级语言虚拟机级，使用高级语言和开发工具。
        *   **系统管理员**：工作在操作系统虚拟机级，管理和维护操作系统及系统资源。
        *   **系统程序员**：工作在机器语言机器级 (ISA层面) 或更低，开发系统软件。

* (4) **程序的CPI与哪些因素有关？**
    *   **指令集体系结构 (ISA)**：不同的指令集，指令的复杂度和功能不同，执行所需的周期数也不同。
    *   **计算机的组织结构 (微体系结构)**：如数据通路的设计、流水线的深度和效率、Cache的性能等都会影响指令执行的实际周期数。
    *   **程序本身的特性**：不同程序使用的指令类型和频率不同，导致平均CPI不同。
    *   **编译器优化水平**：编译器生成的指令序列质量会影响CPI。

* (5) **为什么说性能指标MIPS不能很好地反映计算机的性能？**
    *   **指令功能不同**：不同机器的指令集不同，一条MIPS高的机器上的简单指令可能功能远不如MIPS低的机器上的一条复杂指令。比较指令条数没有意义。
    *   **程序依赖性**：MIPS值会随运行的程序不同而变化，不是一个固定的机器参数。
    *   **忽略CPI和时钟周期**：MIPS只关注指令数和时间，没有直接反映CPI和时钟周期的影响，而这两者是决定实际性能的关键因素。
    *   **可能产生误导**：如例1.3所示，优化后实际性能提升，但MIPS值可能下降。

**习题3 (向朋友介绍计算机系统如何工作)**

这是一个开放性问题，关键在于用**简单通俗的语言**。可以从以下几个方面入手：

*   **核心思想——按指令办事**：把计算机比作一个非常听话但没有自己想法的工人，你给它一本详细的操作手册（程序），它就会一步一步地严格按照手册上的指示（指令）来工作。
*   **输入**：告诉计算机需要处理什么信息（数据），比如通过键盘打字、鼠标点击。
*   **存储**：计算机需要地方记住这些信息和操作手册，就像人的大脑或笔记本（内存和硬盘）。
*   **处理**：计算机的核心（CPU）就像一个超级计算器和逻辑判断器，它会根据手册上的指示对输入的信息进行计算、比较、搬运等操作。
*   **输出**：计算机把处理完的结果展示给你，比如显示在屏幕上、打印出来。
*   **自动化**：一旦启动，计算机就能自动连续地执行指令，不需要你每一步都去指挥。
* **可以类比**：比如做菜，菜谱是程序，食材是数据，厨师是CPU，锅碗瓢盆是硬件，做好的菜是输出。

**习题4 (对计算机系统的熟悉程度及想了解的内容)**

这是一个主观题，需要根据您自身的学习情况回答。

*   **最熟悉的部分**：可能是您日常使用最多的部分，比如操作系统（Windows/MacOS）、常用的应用软件（Office、浏览器）、或者如果您有编程经验，可能是某种编程语言。
*   **最不熟悉的部分**：可能是计算机底层的硬件原理，如CPU的内部工作机制、存储器的组织方式、指令是如何被执行的。
*   **最想进一步了解的细节**：例如，CPU是如何做到如此高速运算的？多核CPU是如何协同工作的？虚拟内存是如何实现的？高级语言是如何被精确翻译成机器指令的？

**习题5 (基准测试程序性能比较)**

* (1) **对于P1，哪台机器的速度快？快多少？对于P2呢？**
    *   **P1**:
        *   M1时间: 10000 ms
        *   M2时间: 5000 ms
        *   M2比M1快。 快 (10000 - 5000) / 5000 = 1倍，或者说M2的速度是M1的 10000/5000 = 2倍。
    *   **P2**:
        *   M1时间: 3 ms
        *   M2时间: 6 ms
        *   M1比M2快。 快 (6 - 3) / 3 = 1倍，或者说M1的速度是M2的 6/3 = 2倍。

(2) **在M1上执行P1和P2的速度分别是多少MIPS？在M2上的执行速度又各是多少？从执行速度来看，对于P2，哪台机器的速度快？快多少？**
    *   **M1**:
        *   P1 MIPS = (200 × 10⁶ 指令) / (10000 × 10⁻³ s) / 10⁶ = 200 / 10 = 20 MIPS
        *   P2 MIPS = (300 × 10³ 指令) / (3 × 10⁻³ s) / 10⁶ = 300 / 3 / 1000 = 0.1 MIPS
    *   **M2**:
        *   P1 MIPS = (150 × 10⁶ 指令) / (5000 × 10⁻³ s) / 10⁶ = 150 / 5 = 30 MIPS
        *   P2 MIPS = (420 × 10³ 指令) / (6 × 10⁻³ s) / 10⁶ = 420 / 6 / 1000 = 0.07 MIPS
    *   **对于P2，从MIPS来看**：M1 (0.1 MIPS) 比 M2 (0.07 MIPS) 快。
        *   快 (0.1 - 0.07) / 0.07 ≈ 0.428 倍，或者说M1的MIPS是M2的 0.1/0.07 ≈ 1.428倍。
        *   **注意**：这里MIPS的比较结果与直接比较执行时间的结果（M1是M2的2倍快）不完全一致，再次说明MIPS的局限性。

(3) **假定M1和M2的时钟频率各是800MHz和1.2GHz，则在M1和M2上执行P1时的平均时钟周期数CPI各是多少？**
    *   **M1上P1的CPI**:
        *   CPU时间 = 指令数 × CPI × 时钟周期
        *   CPI = (CPU时间 × 时钟频率) / 指令数
        *   CPI_M1_P1 = (10000 × 10⁻³ s × 800 × 10⁶ Hz) / (200 × 10⁶) = (10 × 800) / 200 = 8000 / 200 = 40
    *   **M2上P1的CPI**:
        *   CPI_M2_P1 = (5000 × 10⁻³ s × 1.2 × 10⁹ Hz) / (150 × 10⁶) = (5 × 1.2 × 1000) / 150 = 6000 / 150 = 40

(4) **如果某个用户需要大量使用程序P1，并且该用户主要关心系统的响应时间而不是吞吐率，那么，该用户需要大批购进机器时，应该选择M1还是M2？为什么？（提示：从性价比上考虑）**
    *   M2执行P1的速度是M1的2倍 (响应时间短一半)。
    *   M1价格: 5000元，M2价格: 8000元。
    *   **性价比分析 (以性能/价格为标准，性能用速度的倒数即执行时间来衡量，则性价比为 1/(执行时间 × 价格)，或者直接比较 性能提升倍数/价格增加倍数)**
        *   M2相对于M1的性能提升是2倍。
        *   M2相对于M1的价格是 8000/5000 = 1.6倍。
        *   因为性能提升的倍数 (2倍) 大于价格增加的倍数 (1.6倍)，所以M2的性价比更高。
        *   **或者计算单位性能的价格**：
            *   M1: 5000元 / (1/10000ms) = 50,000,000 元·ms
            *   M2: 8000元 / (1/5000ms)  = 40,000,000 元·ms
            *   M2单位性能的价格更低。
    *   **结论**：应该选择 **M2**，因为对于P1，M2的性价比更高，且用户关心响应时间，M2的响应时间更短。

(5) **如果另一个用户也需要购进大批机器，但该用户使用P1和P2一样多，主要关心的也是响应时间，那么，应该选择M1还是M2？为什么？**
    * 我们需要比较两台机器在运行P1和P2总时间上的表现。
    *   **M1总时间 (假设各运行一次)**: 10000 ms (P1) + 3 ms (P2) = 10003 ms
    *   **M2总时间 (假设各运行一次)**: 5000 ms (P1) + 6 ms (P2) = 5006 ms
    *   M2的总响应时间 (5006 ms) 远小于M1的总响应时间 (10003 ms)。
    *   **性价比分析**：
        *   M2相对于M1的平均性能提升约为 10003 / 5006 ≈ 2倍。
        *   价格仍然是M2是M1的1.6倍。
        *   性能提升倍数 (约2倍) 仍然大于价格增加倍数 (1.6倍)。
    *   **结论**：应该选择 **M2**，因为综合来看，M2的总响应时间更短，且性价比依然更高。

**习题6 (峰值MIPS和程序CPI)**
(1) **M1和M2的峰值MIPS各是多少？**
    *   峰值MIPS发生在CPI最小时。对于M1和M2，最小CPI都是1 (指令A)。
    *   M1时钟频率: 1 GHz， M2时钟频率: 1.5 GHz。
    *   峰值MIPS = 时钟频率 / 最小CPI (单位是百万)
    *   M1峰值MIPS = (1 × 10⁹ Hz) / 1 / 10⁶ = 1000 MIPS
    *   M2峰值MIPS = (1.5 × 10⁹ Hz) / 1 / 10⁶ = 1500 MIPS

(2) **假定某程序P的指令序列中，5类指令具有完全相同的指令条数，则程序P在M1和M2上运行时，哪台机器更快？快多少？在M1和M2上执行程序P时的CPI各是多少？**
    *   设每类指令条数为 N。
    *   **M1上执行P的CPI_M1**:
        *   总时钟周期数 = N(1) + N(2) + N(2) + N(3) + N(4) = N(1+2+2+3+4) = 12N
        *   总指令数 = 5N
        *   CPI_M1 = (12N) / (5N) = 12/5 = 2.4
	    **M2上执行P的CPI_M2**:
        总时钟周期数 = N(2) + N(2) + N(4) + N(5) + N(6) = N(2+2+4+5+6) = 19N
        *   总指令数 = 5N
        *   CPI_M2 = (19N) / (5N) = 19/5 = 3.8
    *   **执行时间比较**:
        *   T_M1 = (总指令数 × CPI_M1) / 时钟频率_M1 = (5N × 2.4) / (1 × 10⁹) = 12N × 10⁻⁹ s
        *   T_M2 = (总指令数 × CPI_M2) / 时钟频率_M2 = (5N × 3.8) / (1.5 × 10⁹) = 19N / (1.5 × 10⁹) ≈ 12.67N × 10⁻⁹ s
    *   因为 T_M1 < T_M2，所以 **M1 更快**。
    *   快多少 (倍数) = T_M2 / T_M1 ≈ (12.67N × 10⁻⁹) / (12N × 10⁻⁹) ≈ 1.056 倍。
        *   或者说快 (12.67-12)/12 ≈ 5.6%。
    *   **CPI已算出**: CPI_M1 = 2.4， CPI_M2 = 3.8。

**习题7 (不同设计机器性能比较)**
    *   T = 指令数 × CPI × 时钟周期
    *   T_M1 = I × 4 × 0.8 ns = 3.2 × I ns
    *   T_M2 = I × 2 × 1.2 ns = 2.4 × I ns
    *   因为 T_M2 < T_M1，所以 **M2 的执行速度更快**。
    *   快多少 (倍数) = T_M1 / T_M2 = (3.2 × I ns) / (2.4 × I ns) = 3.2 / 2.4 = 4/3 ≈ 1.333 倍。

**习题8 (执行时间与CPU占用率)**
    *   **P在M上的执行时间是多少？**
        *   CPU执行时间 = 指令条数 × CPI × 时钟周期
        *   时钟周期 = 1 / 时钟频率 = 1 / (4 × 10⁹ Hz) = 0.25 × 10⁻⁹ s = 0.25 ns
        *   执行时间 = (8 × 10⁹) × 1.25 × (0.25 × 10⁻⁹ s) = 8 × 1.25 × 0.25 s = 10 × 0.25 s = 2.5 s
    *   **若在机器M上从程序P开始启动到执行结束所需的时间是4s，则P占用的CPU时间的百分比是多少？**
        *   CPU时间百分比 = (CPU执行时间 / 总时间) × 100%
        *   百分比 = (2.5 s / 4 s) × 100% = 0.625 × 100% = 62.5%

**习题9 (编译器生成指令序列性能比较)**
*   **S1**:
    *   指令条数_S1 = 5 + 2 + 2 + 1 = 10 条
    *   时钟周期数_S1 = 5(1) + 2(2) + 2(3) + 1(4) = 5 + 4 + 6 + 4 = 19 周期
    *   CPI_S1 = 19 / 10 = 1.9
    *   执行时间_S1 = 时钟周期数_S1 × 时钟周期 = 19 × (1 / (500 × 10⁶ Hz)) = 19 / (500 × 10⁶) s = 38 × 10⁻⁹ s = 38 ns
*   **S2**:
    *   指令条数_S2 = 1 + 1 + 1 + 5 = 8 条
    *   时钟周期数_S2 = 1(1) + 1(2) + 1(3) + 5(4) = 1 + 2 + 3 + 20 = 26 周期
    *   CPI_S2 = 26 / 8 = 3.25
    *   执行时间_S2 = 时钟周期数_S2 × 时钟周期 = 26 × (1 / (500 × 10⁶ Hz)) = 26 / (500 × 10⁶) s = 52 × 10⁻⁹ s = 52 ns

**回答：**
*   S1有多少条指令？ **10条** CPI为多少？ **1.9** 所含的时钟周期数各为多少？ **19周期** 执行时间各为多少？ **38 ns**
*   S2有多少条指令？ **8条** CPI为多少？ **3.25** 所含的时钟周期数各为多少？ **26周期** 执行时间各为多少？ **52 ns**

**习题10 (优化指令性能计算)**
*   设P中原有M条“乘4”指令，优化后变为M条“左移两位”指令。
*   P的执行时间 T_P = 12 s。
*   P'的执行时间 T_P'。
*   T_P = 1.2 × T_P'  => T_P' = T_P / 1.2 = 12 s / 1.2 = 10 s。
*   优化的时间节省 = T_P - T_P' = 12 s - 10 s = 2 s。
*   这个时间节省是由于M条指令的CPI变化和可能的其他指令的执行时间变化（虽然题目没说其他指令变化，但总执行时间变化了）。
*   更精确地，时间节省 = M × (CPI_乘4 - CPI_左移) × 时钟周期
*   时钟周期 = 1 / (1.2 × 10⁹ Hz)
*   2 s = M × (5 - 2) × [1 / (1.2 × 10⁹ Hz)]
*   2 s = M × 3 / (1.2 × 10⁹ Hz)
*   M = (2 s × 1.2 × 10⁹ Hz) / 3 = (2.4 × 10⁹) / 3 = 0.8 × 10⁹ = 800 × 10⁶
*   所以，P中有 **800万** 条乘法指令被替换成了左移指令。
