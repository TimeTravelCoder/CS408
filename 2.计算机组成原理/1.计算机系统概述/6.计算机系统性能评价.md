好的，这是针对 "1.6 计算机系统性能评价" 这一节的详细学习笔记：

---

**1.6 计算机系统性能评价**

一个完整的计算机系统由硬件和软件构成，硬件性能的好坏对整个计算机系统的性能起着至关重要的作用。然而，硬件的性能检测和评价比较困难，因为硬件的性能只能通过运行软件才能反映出来。在相同硬件上运行不同类型的软件，或者用同样的软件处理不同的数据集进行测试，所测到的性能都可能不同。因此，必须有一套综合的测试和评价硬件性能的方法。

**1.6.1 计算机性能的定义**

考量一个计算机系统性能的两个基本指标是：

1.  **吞吐率 (Throughput)**：
    *   定义：表示在单位时间内所完成的工作量。
    *   也称：在有些场合下，吞吐率也称为**带宽 (Bandwidth)**。
2.  **响应时间 (Response Time)**：
    *   定义：指从作业提交开始到作业完成所花的时间。
    *   也称：响应时间也称为**执行时间 (Execution Time)** 或 **等待时间 (Latency)**。
    *   **一个程序的响应时间构成**：
        *   程序包含的指令在CPU上执行所花的时间。
        *   磁盘访问时间。
        *   存储器访问时间。
        *   输入输出操作所需时间。
        *   操作系统运行这个程序所花的额外开销等。
*   **不同应用场合的关注点**：
    *   **多媒体应用场合** (如音/视频播放)：用户希望播放流畅，即单位时间内传输的数据量要大，因而关心的是**系统吞吐率是否高**。
    *   **事务处理应用场合** (如银行、证券)：用户希望业务处理速度快，不需长时间等待，因而更关心**响应时间是否短**。
    *   **某些特定应用场合** (如ATM、文件服务、Web服务等)：用户则**同时关心吞吐率和响应时间**。
**1.6.2 计算机性能的测试**
*   **基本衡量标准**：如果不考虑应用背景而直接比较计算机性能，则大都用**执行时间**来衡量。
*   **性能比较原则**：从执行时间来考虑，完成同样工作量所需时间最短的那台计算机性能是最好的。
*   **CPU时间 (CPU Time)**：
    *   **用户感觉到的执行时间并非真正的CPU执行时间**：因为操作系统在对处理器进行调度时，一段时间内往往会让多个程序 (更准确地说是进程) 轮流使用处理器。因此，在某个用户程序执行过程中，可能同时还会有其他用户程序和操作系统程序在执行。
    *   **CPU时间的构成**：通常把用户感觉到的执行时间分成两部分：
        *   **CPU时间**：指CPU真正用在程序执行上的时间。
        *   **其他时间**：指等待I/O操作完成的时间或CPU用在其他用户程序执行上的时间。
    *   **CPU时间的进一步划分**：
        *   **(1) 用户CPU时间 (User CPU Time)**：指用来运行用户程序代码的时间。
        *   **(2) 系统CPU时间 (System CPU Time)**：指为了执行用户程序而需要运行操作系统程序的时间。
*   **性能评价关注点**：计算机系统的性能评价主要考虑**CPU性能**。
    *   **系统性能 vs. CPU性能**：两者不等价，有区别。
        *   **系统性能**：指系统的响应时间，它与CPU外的其他部分也有关系。
        *   **CPU性能**：指用户CPU时间，它只包含在CPU上运行用户程序代码的时间。

*   **计算CPU时间的要素和指标**：
    1.  **时钟周期 (Clock Cycle / Tick / Clock Tick / Clock)**：
        *   定义：计算机执行指令的过程被分成若干步骤和相应的动作来完成，每一步动作都要有相应的控制信号进行控制，这些控制信号何时发出、作用时间多长，都要有相应的定时信号进行同步。因此，CPU必须能够产生同步的时钟定时信号，也就是CPU的主脉冲信号，其宽度称为时钟周期。
    2.  **时钟频率 (Clock Rate / 主频)**：
        *   定义：CPU的主频就是CPU中的主脉冲信号的时钟频率，是CPU时钟周期的倒数。
    3.  **CPI (Cycles Per Instruction)**：
        *   定义：表示执行指令所需的时钟周期数。
        *   **针对特定指令**：其CPI指执行该条指令所花的时钟周期数，此时CPI是一个确定的值。
        *   **针对一个程序或一台机器**：其CPI指该程序或该机器指令集中的所有指令执行所用的平均时钟周期数，此时CPI是一个平均值。
*   **CPU执行时间的计算公式**：
    *   已知上述参数或指标，可以通过以下公式来计算用户程序的CPU时间：
        `CPU执行时间 = 程序所含时钟周期数 ÷ 时钟频率`
        `CPU执行时间 = 程序所含时钟周期数 × 时钟周期`
    *   上述公式中，程序所含时钟周期数可由程序所含指令条数和相应的CPI求得。
    *   **如果已知程序总的指令条数和综合CPI**：
        `程序总时钟周期数 = 程序所含指令条数 × CPI`
    *   **如果已知程序中共有n种不同类型的指令，第 i 种指令的条数为 Cᵢ，CPI为 CPIᵢ**：
        `程序总时钟周期数 = Σ (CPIᵢ × Cᵢ)` (从 i=1 到 n 求和)
    *   **程序的综合CPI的计算公式 (其中 Fᵢ 表示第 i 种指令在程序中所占的比例)**：
        `CPI = Σ (CPIᵢ × Fᵢ)` (从 i=1 到 n 求和)
        `CPI = 程序总时钟周期数 ÷ 程序所含指令条数`
    *   **最终CPU执行时间计算公式**：
        `CPU执行时间 = CPI × 程序总指令条数 × 时钟周期`
        `CPU执行时间 = CPI × 程序总指令条数 ÷ 时钟频率`
*   **性能比较**：
    *   有了CPU执行时间，就可以评判两台计算机性能的好坏。
    *   计算机的性能可以看成是CPU时间的倒数。
    *   若计算机M1和M2的性能之比为n，则说明“M1的速度是M2的速度的n倍”，也就是说，“在M2上执行程序的时间是在M1上执行时间的n倍”。
*   **CPU时间度量公式中各因素的相互制约关系**：
    *   时钟周期、指令条数、CPI三个因素是相互制约的。
    *   例如，更改指令集可以减少程序所含指令的条数，但是，同时可能引起CPU结构的调整，从而可能会增加时钟周期的宽度 (即降低时钟频率)。
    *   对于解决同一个问题的不同程序，即使是在同一台计算机上，指令条数最少的程序也不一定执行得最快。
    *   有关时钟周期、指令条数和CPI的相互制约关系，在学完后面有关指令系统设计、数据通路设计等章节后，会有更深刻的认识和理解。
*   **示例分析**：
    *   **例1.1**：
        *   问题：程序P在机器M1上运行需10秒，M1时钟频率2GHz。设计新机器M2 (与M1有相同ISA)，采用新技术使M2时钟频率增加，但CPI也增加。若程序P在M2上的时钟周期数是M1上的1.5倍，M2时钟频率至少多少才能使P在M2上运行时间缩短为6秒？
        *   解：
            *   P在M1上的时钟周期数 = CPU执行时间 × 时钟频率 = 10s × 2GHz = 20G。
            *   P在M2上的时钟周期数 = 1.5 × 20G = 30G。
            *   M2的时钟频率至少应为 = 程序所含时钟周期数 ÷ CPU执行时间 = 30G / 6s = 5GHz。
        *   结论：M2的时钟频率是M1的2.5倍，但M2的速度却只是M1的1.67倍 (10s/6s)。说明时钟频率提高可能导致其他性能指标降低 (如CPI增加)，最终执行速度并非同比例提高。
    *   **例1.2**：
        *   问题：计算机M的指令集中包含A,B,C三类指令，CPI分别为1,2,4。程序P在M上编译成两个不同目标代码P1和P2。P1含A,B,C指令条数分别为8,2,2。P2含A,B,C指令条数分别为2,5,3。问：哪个代码序列指令条数少？哪个执行速度快？它们的CPI分别是多少？
        *   解：
            *   P1指令条数 = 8+2+2 = 12。 P2指令条数 = 2+5+3 = 10。 P2指令条数少。
            *   P1时钟周期数 = 8×1 + 2×2 + 2×4 = 20。
            *   P2时钟周期数 = 2×1 + 5×2 + 3×4 = 24。
            *   因为在同一台机器上运行，时钟周期一样，故时钟周期数少的代码序列执行时间短、速度快。显然P1比P2快。
            *   P1的CPI = 20/12 = 1.67。 P2的CPI = 24/10 = 2.4。
        *   结论：指令条数少的代码序列执行时间并不一定更短。评价计算机性能时，仅考虑单个因素是不全面的，必须三个因素 (指令数、CPI、时钟周期) 同时考虑。

**1.6.3 用指令执行速度进行性能评估**
*   **MIPS (Million Instructions Per Second)**：
    *   定义：最早用来衡量计算机性能的指标是每秒钟完成单个运算 (如加法运算) 指令的条数。当时大多数指令的执行时间是相同的，并且加法指令能反映乘、除等运算性能，其他指令的时间大体与加法指令相当，故加法指令的速度有一定的代表性。
    *   含义：平均每秒钟执行多少百万条指令。
*   **等效指令速度法 / Gibson混合法**：
    *   早期一种类似于MIPS的性能估计方式，也称指令平均执行时间。
    *   随着计算机体系结构的发展，不同指令所需的执行时间差别越来越大。
    *   计算方法：设某类指令 i 在程序中所占比例为 wᵢ，执行时间为 tᵢ，则等效指令的执行时间为 T = w₁ × t₁ + w₂ × t₂ + … + wₙ × tₙ (n为指令种类数)。
    *   如果指令执行时间用时钟周期数来衡量的话，则上式计算的结果就是 CPI。对指令平均执行时间求倒数能够得到 MIPS 值。
*   **峰值MIPS (Peak MIPS)**：
    *   选取一组指令组合，使得得到的平均CPI最小，由此得到的MIPS就是峰值MIPS。
    *   问题：有些制造商经常将峰值MIPS直接当作MIPS，而实际上的性能要比标称的性能差。
*   **相对MIPS (Relative MIPS)**：
    *   根据某个公认的参考机型来定义的相应MIPS值，其值的含义是被测机型相对于参考机型MIPS的多少倍。
*   **MIPS的局限性**：
    *   MIPS反映的是机器执行定点指令的速度。
    *   **不同机器指令集不同，指令功能也不同**：也许在机器M1上某一条指令的功能，在机器M2上要用多条指令来完成，因此，同样的指令条数所完成的功能可能完全不同。
    *   **不同机器的CPI和时钟周期也不同**：因而同一条指令在不同机器上所用的时间也不同。
    *   **结论**：用MIPS来对不同的机器进行性能比较有时是不准确或不客观的。
*   **示例分析 (例1.3)**：
    *   问题：程序P编译后目标代码由A,B,C,D四类指令组成，比例为43%,21%,12%,24%，CPI分别为1,2,2,2。重新编译优化，A类指令减少50%，其他不变。若程序在50MHz计算机上运行，优化前后MIPS各是多少？
    *   解：
        *   优化后各类指令所占比例：A: 27%, B: 27%, C: 15%, D: 31% (基于原指令总数变化后的新总数计算比例)
        *   优化前CPI = 0.43×1 + 0.21×2 + 0.12×2 + 0.24×2 = 1.57
        *   优化后CPI = 0.27×1 + 0.27×2 + 0.15×2 + 0.31×2 = 1.73 (注意：这里教材计算的比例是以原始指令总数为100，A类变为21.5，总数变为78.5，然后按新总数计算的新比例，这个算法更合理。若按我上面直接用百分比计算，分母也变化了，需要重新归一化。)
            *   按教材思路：优化后A类指令比例21.5/(21.5+21+12+24) = 21.5/78.5 ≈ 27%。其余类似。
        *   优化前MIPS = 50M / 1.57 ≈ 31.8 MIPS
        *   优化后MIPS = 50M / 1.73 ≈ 28.9 MIPS
    *   结论：从MIPS数来看，优化后程序执行速度反而变慢了。这显然是错误的，因为优化后只减少了A类指令条数而其他指令数没变，所以程序执行时间一定减少了。从这个例子可以看出，用MIPS数来进行性能估计是不可靠的。
*   **MFLOPS (Million FLOating-point operations Per Second)**：
    *   与定点指令运行速度MIPS相对应的用来表示浮点操作速度的指标。
    *   定义：表示每秒所执行的浮点运算有多少百万次。
    *   衡量基准：它是基于所完成的操作次数而不是指令数来衡量的。
**1.6.4 用基准程序进行性能评估**
*   **基准程序 (Benchmarks)**：
    *   定义：进行计算机性能评测的一种重要工具。基准程序是专门用来进行性能评价的一组程序。
    *   作用：能够很好地反映机器在运行实际负载时的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而评测其性能。
    *   选择原则：最好是用户经常使用的一些实际程序，或是某个应用领域的一些典型的简单程序。
    *   针对性：对于不同的应用场合，应该选择不同的基准程序。例如，对用于软件开发的计算机进行评测时，最好选择包含编译器和文档处理软件的一组基准程序；而如果是对用于CAD处理的计算机进行评测时，最好选择一些典型的图形处理小程序作为一组基准程序。
*   **SPEC (Standard Performance Evaluation Corporation) 测试程序集**：
    *   应用最广泛、也是最全面的性能评测基准程序集。
    *   **提出时间与机构**：1988年，由Sun, MIPS, HP, Apollo, DEC五家公司联合提出了SPEC标准。
    *   **内容**：包括一组标准的测试程序、标准输入和测试报告。这些测试程序是一些实际的程序，包括系统调用、I/O等。
    *   **早期分类**：
        *   整数测试程序集 SPECint
        *   浮点测试程序集 SPECfp
    *   **后续发展**：后来分成了按不同性能测试用的基准程序集，如：
        *   CPU性能测试集 (SPEC CPU2000, CPU2006, CPU2017 等)
        *   Web服务器性能测试集 (SPECweb99, SPECweb2005 等)
*   **综合评价方法**：
    *   如果基准测试程序集中不同的程序在两台机器上测试得出的结论不同，则如何给出最终的评价结论呢？
    *   例如，假定基准测试程序集包含程序P1和P2。P1在M1和M2上运行时间分别是10秒和2秒 (M2是M1的5倍速)。P2在M1和M2上运行时间分别是120秒和600秒 (M1是M2的5倍速)。那么，到底是M1还是M2更快呢？
    *   **方法1：所有程序的执行时间之和来比较**。
    *   **方法2：执行时间的算术平均值或几何平均值**。
        *   根据算术平均值能得到总的平均执行时间。
        *   根据几何平均值则不能得到程序总的执行时间。
    *   **方法3：加权平均**：如果考虑每个程序的使用频度，用加权平均的方式，结果会更准确。
*   **执行时间的归一化**：
    *   可以将执行时间进行归一化来得到被测试的机器相对于参考机器的性能。
    *   `执行时间的归一化值 = 参考机器上的执行时间 ÷ 被测机器上的执行时间`
    *   **SPEC比值 (SPEC Ratio)**：指将测试程序在 Sun SPARCstation 上运行时的执行时间除以该程序在测试机器上的执行时间所得到的比值。比值越大，机器的性能越好。
*   **基准程序的缺陷**：
    *   基准程序的性能可能与某一小段的短代码密切相关。
    *   此时，硬件系统设计人员或编译器开发者可能会针对这些代码片段进行特殊的优化，使得执行这段代码的速度非常快，以至于得到不准确的性能评测结果。
    *   例如，Intel Pentium 处理器运行 SPECint 时用了公司内部使用的特殊编译器，使其性能表现得很高，但用户实际使用的是普通编译器，达不到所标称的性能。
    *   又如，矩阵乘法程序 SPEC matrix 300 有99%的时间运行在一行语句上，有些厂商用特殊编译器优化该语句，使性能达到 VAX 11/780 的 729.8 倍！
