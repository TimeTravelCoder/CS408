在分页基础上建立的请求分页式虚拟存储器系统，是以**页面**为单位进行换入、换出的。而在分段基础上所建立的请求分段式虚拟存储器系统，则是以**分段**为单位进行换入、换出的。
*   **相似性**：它们在实现原理以及所需要的硬件支持上都是十分相似的。
*   **运行启动**：在请求分段系统中，程序运行之前，只需先调入少数几个分段（不必调入所有的分段）便可启动运行。
*   **缺段处理**：当所访问的段不在内存中时，可请求 OS 将所缺的段调入内存。
*   **与请求分页的类比**：像请求分页系统一样，为实现请求分段存储管理方式，同样需要一定的硬件支持和相应的软件。

### 5.5.1 请求分段中的硬件支持
为了实现请求分段式存储管理，应在系统中配置多种硬件机构，以支持快速地完成请求分段功能。与请求分页系统相似，在请求分段系统中所需的硬件支持有：
1.  **请求段表机制**
2.  **缺段中断机构**
3.  **地址变换机构**

**1. 请求段表机制**
在请求分段式管理中所需要的主要数据结构是**请求段表**。该表中除了具有请求分页机制中有的访问字段A、修改位M、存在位P和外存始址四个字段外，还增加了**存取方式字段**和**增补位**。这些字段供程序在调进、调出时参考。

**请求分段的段表项：**
![[image-382.png]]

**段表项中各字段说明：**
*   **段名 (段号)**：分段的唯一标识。
*   **段长**：该段的长度。
*   **段基址**：该段在内存中的起始地址（如果已调入内存）。
*   **(1) 存取方式 (Access Control)**：
    *   由于应用程序中的段是信息的逻辑单位，可根据该信息的属性对它实施保护。
    *   故在段表中增加存取方式字段。
    *   如果该字段为两位，则存取属性可以是：只执行、只读、允许读/写。
*   **(2) 访问字段 A (Access Bit)**：
    *   其含义与请求分页的相应字段相同，用于记录该段被访问的频繁程度。
    *   提供给置换算法选择换出段时参考。
*   **(3) 修改位 M (Modify/Dirty Bit)**：
    *   该字段用于表示该段在进入内存后是否已被修改过。
    *   供置换段时参考，若未修改则无需写回外存。
*   **(4) 存在位 P (Presence Bit)**：
    *   该字段用于指示本段是否已调入内存。
    *   P=1表示在内存，P=0表示不在内存，供程序访问时参考。
*   **(5) 增补位 (Growth Bit / Expansion Bit)**：
    *   这是请求分段式管理中所特有的字段。
    *   用于表示本段在运行过程中是否做过动态增长（例如，数据段在运行中可能会增加数据）。
*   **(6) 外存始址 (External Storage Starting Address)**：
    *   指示本段在外存中的起始地址，即起始盘块号。
    *   供调入该段时参考。

**2. 缺段中断机构 (Segment Fault Interrupt Mechanism)**
*   **调段策略**：在请求分段系统中采用的是**请求调段策略**。
*   **中断产生**：每当发现运行进程所要访问的段尚未调入内存时，便由缺段中断机构产生一**缺段中断信号**。
*   **中断处理**：进入 OS 后，由**缺段中断处理程序**将所需的段调入内存。
*   **与缺页中断的相似性**：
    *   缺段中断机构同样需要在一条指令的执行期间产生和处理中断。
    *   在一条指令执行期间，可能产生多次缺段中断。
*   **与缺页中断的差异性**：
    *   由于分段是信息的逻辑单位，因而**不可能出现一条指令被分割在两个分段中**的情况。
    *   也**不可能出现一组信息被分割在两个分段中**的情况（例如一个完整的数据结构）。
*   **处理过程 (图5-12)**：显示了请求分段系统中的缺段中断处理过程。
	* ![[Pasted image 20250531134510.png]]
    1.  虚段S不在内存，阻塞请求进程。
    2.  检查内存是否有合适的空闲区：
        *   **是**：从外存读入段S。
        *   **否**：检查内存中所有空闲分区之和是否 ≥ S？
            *   **是**：进行空闲区拼接，以形成一个合适的空闲区，然后从外存读入段S。
            *   **否**：执行段置换算法，淘汰一个或几个实段，以形成一个合适的空闲区，然后从外存读入段S。
    3.  修改段表及内存空闲区链。
    4.  唤醒请求进程。
*   **复杂性**：由于段不是定长的，这使对缺段中断的处理要比对缺页中断的处理复杂。调入一个变长的段比调入一个定长的页要困难（需要查找合适的空闲区，可能需要拼接或置换多个段）。

**3. 地址变换机构 (Address Translation Mechanism)**
请求分段系统中的地址变换机构是在分段系统地址变换机构的基础上形成的。
*   **前提**：被访问的段并非全在内存。
*   **变换过程**：在进行地址变换时，若发现所要访问的段不在内存，必须先将所缺的段调入内存，并修改段表，然后才能再利用段表进行地址变换。
*   **增加功能**：为此，在地址变换机构中又增加了某些功能，如缺段中断的请求及处理等。
*   **图示 (图5-13)**：显示了请求分段系统的地址变换过程。
	* ![[Pasted image 20250531134535.png]]

### 5.5.2 分段的共享与保护
本章前面曾介绍过分段存储管理方式的优点是便于实现分段的共享与保护，也扼要地介绍了实现分段共享的方法。本小节将进一步介绍为了实现分段共享，还应配置相应的数据结构——**共享段表**，以及对共享段进行操作的过程。

**1. 共享段表 (Shared Segment Table)**
*   **目的**：为了实现分段共享，可在系统中配置一张**共享段表**。
*   **内容**：所有各共享段都在共享段表中占有一表项。
    *   **共享段信息**：在表项的上面记录了共享段的段号、段长、内存始址、状态(存在)位、外存始址以及**共享进程计数 (count)** 等信息。
    *   **共享进程列表**：接下去就是记录了共享此分段的每个进程的情况，包括进程名、在本进程中的段号、存取控制等。
*   **图示 (图5-14)**：显示了共享段表项的结构。
	* ![[Pasted image 20250531134738.png]]
    *   **共享段信息部分**：| 段名 | 段长 | 内存始址 | 状态 | 外存始址 |
    *   **共享进程计数 count**
    *   **共享此段的进程列表部分**：| 状态 | 进程名 | 进程号 | 段号 (在该进程内) | 存取控制 |
*   **字段说明**：
    *   **(1) 共享进程计数 count**：
        *   **非共享段**：仅为一个进程所需要。当进程不再需要该段时，可立即释放该段，并由系统回收该段所占用的空间。
        *   **共享段**：是为多个进程所需要的。为记录有多少进程正在共享该分段，须设置共享进程计数 count。
        *   当某进程不再需要而释放它时，系统并不立即回收该段所占内存区，而是检查 count 是否为0。若不为0，则表示还有进程需要它；仅当所有共享该段的进程全都不再需要它时，此时 count 为0，才由系统回收该段所占内存区。
    *   **(2) 存取控制字段**：对于一个共享段，应为不同的进程赋予不同的存取权限。例如，对于文件主，通常允许他读和写；而对其它进程，则可能只允许读，甚至只允许执行。
    *   **(3) 段号**：对于一个共享段，在不同的进程中可以具有不同的段号，每个进程可用自己进程的段号去访问该共享段。

**2. 共享段的分配与回收**
*   **(1) 共享段的分配**：
    *   由于共享段是供多个进程所共享的，因此，对共享段的内存分配方法，与非共享段的内存分配方法有所不同。
    *   **第一个请求进程**：对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，再把共享段调入该区，同时将该区的始址填入请求进程的段表的相应项中。还须在共享段表中增加一表项，填写请求使用该共享段的进程名、段号和存取控制等有关数据，把 count 置为1。
    *   **后续请求进程**：当又有其它进程需要调用该共享段时，由于该共享段已被调入内存，故此时无须再为该段分配内存，而只需在调用进程的段表中增加一表项，填写该共享段的物理地址。在共享段表的段表中增加一个表项，填上调用进程的进程名、该共享段在本进程中的段号、存取控制等，再执行 `count = count + 1` 操作，以表明有两个进程共享该段。以后，凡有进程需要访问此共享段的，都按上述方式在共享段表的段表中增加一个表项。
*   **(2) 共享段的回收**：
    *   当共享此段的某进程不再需要该段时，应将该段释放。
    *   **释放操作**：包括撤消在该进程段表中共享段所对应的表项，以及执行 `count = count - 1` 操作。
    *   **判断是否回收内存**：
        *   若结果为0，则须由系统回收该共享段的物理内存，以及取消在共享段表中该段所对应的表项，表明此时已没有进程使用该段。
        *   否则 (减1结果不为0)，只是取消调用者进程在共享段表中的有关记录。

**3. 分段保护**
在分段系统中，由于每个分段在逻辑上是相对独立的，因而比较容易实现信息保护。目前，常采用以下几种措施来确保信息的安全：
*   **(1) 越界检查 (Bounds Checking)**
    *   利用地址变换机构来完成。
    *   在地址变换机构中设置了**段表寄存器**，用于存放段表始址和段表长度信息。
    *   **段号越界**：在进行地址变换时，首先将逻辑地址空间中的段号与段表长度进行比较，如果段号等于或大于段表长度，将发出地址越界中断信号。
    *   **段内地址越界**：此外，还在段表中为每个段设置有段长字段。在进行地址变换时，还要检查段内地址是否等于或大于段长，若大于段长，将产生地址越界中断信号。
    *   **作用**：从而保证了每个进程只能在自己的地址空间内运行。
*   **(2) 存取控制检查 (Access Control Checking)**
    *   是以**段**为基本单位进行的。
    *   为此，在段表的每个表项中都设置了一个“存取控制”字段，用于规定对该段的访问方式。
    *   **常见的访问方式**：
        *   只读 (Read-only)：只允许进程对该段中的程序或数据进行读访问。
        *   只执行 (Execute-only)：只允许进程调用该段去执行，但不准读该段的内容，更不允许对该段执行写操作。
        *   读/写 (Read/Write)：允许进程对该段进行读/写访问。
    *   **共享段的保护**：对于共享段而言，存取控制就显得尤为重要，因而对不同的进程应赋予不同的读写权限。例如，对于一个企业的财务账目，应该只允许会计人员进行读或写，允许领导及有关人员去读，而对于一般人员，则既不准读，更不能写。
    *   **硬件实现**：这里所介绍的存取控制检查是基于硬件实现的，它能较好地保证信息的安全，因为攻击者很难对存取控制字段进行修改。
*   **(3) 环保护机构 (Ring Protection Mechanism)**
    *   这是一种功能较完善的保护机制。
    *   **环的定义**：在该机制中规定，低编号的环具有高优先权。
        *   OS核心处于 **0号环**内。
        *   某些重要的实用程序和操作系统服务占据中间环。
        *   而一般的应用程序，则被安排在外环上。
    *   **访问规则 (图5-15)**：在环系统中，程序的访问和调用应遵循以下规则：
	    * ![[Pasted image 20250531134809.png]]
        *   **(a) 程序间的控制传输 (调用)**：
            *   一个程序可以调用驻留在相同环或较高特权环（内环）中的服务。
            *   不允许调用驻留在较低特权环（外环）中的程序。
        *   **(b) 数据访问**：
            *   一个程序可以访问驻留在相同环或较低特权环（外环）中的数据。
            *   不允许访问驻留在较高特权环（内环）中的数据（除非通过受控的门机制）。
    *   **图示 (图5-15)**：
        *   (a) 程序间的控制传输：外环程序可以调用内环程序，内环程序返回给外环程序。不允许内环程序直接调用外环程序。
        *   (b) 数据访问：内环程序可以访问外环数据，外环程序不能直接访问内环数据。