请求分页系统是建立在**基本分页系统**基础之上的，为了能支持虚拟存储器功能，而增加了**请求调页功能**和**页面置换功能**。
*   **基本单位**：每次调入和换出的基本单位都是长度固定的**页面**。
*   **实现简易性**：这使得请求分页系统在实现上要比请求分段系统简单（后者在换进和换出时是可变长度的段）。
*   **应用广泛性**：因此，请求分页是目前最常用的一种实现虚拟存储器的方式。

### 5.2.1 请求分页中的硬件支持
为了实现请求分页，系统必须提供一定的硬件支持。计算机系统除了要求一定容量的内存和外存外，还需要有：
1.  **请求页表机制**
2.  **缺页中断机构**
3.  **地址变换机构**

**1. 请求页表机制**
请求页表是在纯分页系统的页表基础上发展而来的。其基本作用仍然是将用户地址空间中的逻辑地址映射为内存空间中的物理地址。为了满足页面换进换出的需要，在请求页表中又增加了以下四个字段：
*   **页号 (Page Number)**：逻辑页的编号。
*   **物理块号 (Physical Frame Number)**：该页在内存中对应的物理块号。
*   **状态位 P (Presence/Status Bit)**：
    *   也称为**存在位**。
    *   用于指示该页**是否已调入内存**。
    *   P=1 表示该页已在内存中。
    *   P=0 表示该页当前不在内存中（可能在磁盘上，或从未被访问）。
    *   供程序访问时参考，若为0则产生缺页中断。
*   **访问字段 A (Access Bit)**：
    *   用于记录本页在一段时间内**被访问过的次数**，或者记录本页最近已有多长时间**未被访问**。
    *   供页面置换算法在选择换出页面时参考。当页面被访问时，硬件自动设置此位。
*   **修改位 M (Modify/Dirty Bit)**：
    *   标识该页在调入内存后**是否被修改过**。
    *   由于内存中的每一页都在外存上保留一份副本，因此：
        *   若M=0（未被修改），则在置换该页时，不需再将该页写回到外存上，以减少系统的开销和启动磁盘的次数。
        *   若M=1（已被修改），则必须将该页重写到外存上，以保证外存中所保留的副本始终是最新的。
    *   此位供置换页面时参考。
*   **外存地址 (Disk Address)**：
    *   用于指出该页在**外存上的存放地址**，通常是物理块号。
    *   供调入该页时参考。

**请求页表项的结构示例：**

| 页号  | 物理块号 | 状态位 P | 访问字段 A | 修改位 M |  外存地址 |
| --- | ---- | ----- | ------ | ----- | ----- |


**2. 缺页中断机构 (Page Fault Interrupt Mechanism)**
与一般中断相比，缺页中断有其显著的特点：
*   **(1) 在指令执行期间产生和处理中断信号**：
    *   通常，CPU是在一条指令执行完后才检查是否有中断请求到达。
    *   缺页中断则是在指令执行期间，若发现所要访问的指令或数据不在内存时，便立即产生和处理缺页中断信号，以便能及时将所需页面调入内存。
*   **(2) 一条指令在执行期间可能产生多次缺页中断**：
    *   例如，一条指令 `copy A to B` 可能涉及：
        1.  指令本身可能跨越两个页面。
        2.  源数据 A 可能在另一个页面（或跨越两个页面）。
        3.  目标数据 B 可能在又一个页面（或跨越两个页面）。
    *   如果这些相关的页面都不在内存中，执行这条指令就可能产生多次缺页中断（如图5-1所示，最多可达6次）。
	    * ![[Pasted image 20250531133603.png]]
    *   因此，系统中的硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处继续执行。

**缺页中断的处理流程**：
当发生缺页中断时，系统会经历类似一般中断的处理步骤：
1.  保护CPU现场（程序计数器、寄存器等）。
2.  分析中断原因（确定是缺页中断）。
3.  转入缺页中断处理程序进行处理（调页）。
4.  中断处理完成后，恢复CPU现场，返回到被中断的指令处继续执行。

**3. 地址变换机构 (Address Translation Mechanism)**
请求分页系统中的地址变换机构是在纯分页系统地址变换机构的基础上，为实现虚拟存储器而增加了某些功能所形成的。这些功能包括产生和处理缺页中断，以及从内存中换出一页的功能等。
*   (参见 ![[Pasted image 20250531133657.png]]`)

**地址变换过程 (结合图5-2的逻辑)：**
1.  **检索快表 (TLB)**：
    *   CPU根据逻辑地址中的页号，首先查找快表（TLB）。
    *   **若找到 (TLB Hit)**：
        *   检查页表项中的状态位 P。
        *   若 P=1 (页面在内存)：
            *   修改页表项中的访问位 A (硬件自动置1)。
            *   若是写指令，还须将修改位 M 置为 "1"。
            *   利用页表项中给出的物理块号和页内地址形成物理地址。
            *   访问内存。地址变换结束。
        *   *(理论上快表中的项P位应为1，若P=0在快表中，则快表设计或同步有问题)*
    *   **若未找到 (TLB Miss)**：
        *   **访问内存中的页表**：到内存中去查找主页表。
        *   根据页表项中的状态位 P 判断该页是否已调入内存。
        *   **若 P=1 (页面在内存)**：
            *   将该页的页表项写入快表。若快表已满，则按某种算法（如LRU）调出快表中的一个旧页表项。
            *   修改页表项中的访问位 A。若是写指令，修改位 M 置为 "1"。
            *   利用页表项中的物理块号和页内地址形成物理地址。
            *   访问内存。地址变换结束。
        *   **若 P=0 (页面不在内存，发生缺页中断)**：
            *   产生**缺页中断**，请求 OS 从外存把该页调入内存。
            *   OS进行缺页处理：
                1.  保护CPU现场。
                2.  查找该页在外存的地址。
                3.  检查内存是否有空闲物理块：
                    *   若有空闲块：分配一个物理块，启动磁盘I/O将该页调入内存。
                    *   若无空闲块：执行页面置换算法，选择一个将被换出的页面。
                        *   若被换出页的修改位 M=1，则需将其写回外存。
                        *   将被换出页占用的物理块分配给新调入的页，启动磁盘I/O将该页调入内存。
                4.  页面调入完成后，修改内存中相应页表项的内容（状态位P=1，物理块号，修改位M=0，访问位A=0或1）。
                5.  将该页的页表项写入快表（若快表管理策略允许）。
                6.  恢复CPU现场，重新执行被中断的指令。

### 5.2.2 请求分页中的内存分配
在为进程分配内存时，将涉及到以下三个问题：
1.  **最小物理块数的确定**：为保证进程能正常运行，所需要的最少物理块数。
2.  **内存分配策略**：为每个进程分配物理块时，应采取何种策略（固定还是可变）。
3.  **物理块分配算法**：为不同进程分配物理块数时，是采取平均分配，还是按进程大小比例分配。

**1. 最小物理块数的确定**
*   **定义**：指能保证进程正常运行所需的最小物理块数。当系统为进程分配的物理块数少于此值时，进程将无法运行。
*   **影响因素**：进程应获得的最小物理块数与计算机的**硬件结构**有关，取决于**指令的格式、功能和寻址方式**。
    *   **单地址指令，直接寻址**：至少需要 **2** 个物理块。一块用于存放指令页面，另一块用于存放数据页面。
    *   **允许间接寻址**：至少需要 **3** 个物理块（指令页、间址操作数页、数据页）。
    *   **功能较强的机器 (如指令跨页、源/目标操作数跨页)**：例如，一条指令本身跨两个页面，源地址和目标地址所涉及的区域也都可能跨两个页面，则至少要为每个进程分配 **6** 个物理块。

**2. 内存分配策略**
在请求分页系统中，可采取两种内存分配策略：**固定分配**和**可变分配**。在进行置换时，也可采取两种策略：**全局置换**和**局部置换**。组合后有以下三种适用策略：
*   **(1) 固定分配局部置换 (Fixed Allocation, Local Replacement)**
    *   **固定分配**：指为每个进程分配一组**固定数目**的物理块，在进程运行期间不再改变。
    *   **局部置换**：指如果进程在运行中发现缺页，则只能从分配给该进程的 *n* 个页面中选出一页换出，然后再调入一页，以保证分配给该进程的内存空间不变。
    *   **困难**：为每个进程分配多少物理块难以确定。
        *   太少：会频繁出现缺页中断，降低系统吞吐量。
        *   太多：必然使内存中驻留的进程数目减少，可能造成CPU空闲或其他资源空闲。
    *   通常根据进程类型（交互型、批处理型）或程序员/管理员建议确定。
*   **(2) 可变分配全局置换 (Variable Allocation, Global Replacement)**
    *   **可变分配**：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况适当增加或减少。
    *   **全局置换**：指如果进程在运行中发现缺页，则 OS 将从系统的**空闲物理块队列**中取出一块分配给该进程，或者以**所有进程的全部物理块**为标的，选择一块换出（可能属于其他进程），然后将所缺之页调入。
    *   **实现**：可能是最易于实现的一种策略。当进程发生缺页时，系统都将分配新的物理块，仅当空闲物理块队列中的物理块用完时，OS才能从内存中选择一页调出。
    *   **结果**：被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，可能导致其缺页率增加。
*   **(3) 可变分配局部置换 (Variable Allocation, Local Replacement)**
    *   **分配**：同样基于进程类型或程序员要求，为每个进程分配一定数目的物理块。
    *   **置换**：当某进程发现缺页时，只允许从该进程在内存的页面中选择一页换出，这样就不会影响其它进程的运行。
    *   **动态调整**：
        *   如果进程在运行中频繁地发生缺页中断，则系统须再为该进程分配若干附加的物理块，直至该进程的缺页率减少到适当程度为止。
        *   反之，若一个进程在运行过程中的缺页率特别低，则此时可适当减少分配给该进程的物理块数，但不应引起其缺页率的明显增加。

**3. 物理块分配算法** (主要针对固定分配策略)
在采用固定分配策略时，如何将系统中可供分配的所有物理块分配给各个进程，可采用以下几种算法：
*   **(1) 平均分配算法**
    *   将系统中所有可供分配的物理块**平均分配**给各个进程。
    *   例如：系统有100个物理块，5个进程在运行，则每个进程分得20个物理块。
    *   **缺点**：貌似公平，但未考虑到各进程本身的大小，会造成实际上的不公平。一个10页的进程得到20块（浪费10块），一个200页的进程也只得到20块（缺页率会很高）。
*   **(2) 按比例分配算法**
    *   根据进程的大小按比例分配物理块。
    *   设系统中共有 *n* 个进程，每个进程的页面数为 *S<sub>i</sub>*，则系统中各进程页面数的总和为 *S = ΣS<sub>i</sub>* (i=1 to n)。
    *   若系统中可用的物理块总数为 *m*，则每个进程所能分到的物理块数 *b<sub>i</sub>* 可由下式计算：
        *b<sub>i</sub> = (S<sub>i</sub> / S) × m*
    *   *b<sub>i</sub>* 应取整，且必须大于等于该进程所需的最小物理块数。
*   **(3) 考虑优先权的分配算法**
    *   在实际应用中，为了照顾到重要的、紧迫的作业能尽快地完成，应为它分配较多的内存空间。
    *   通常采取的方法是把内存中可供分配的所有物理块分成两部分：
        *   一部分按比例地分配给各进程。
        *   另一部分则根据各进程的优先权进行分配，为高优先权进程适当地增加其相应份额。
    *   在有的系统中，如重要的实时控制系统，则可能是完全按优先权为各进程分配其物理块。

### 5.2.3 页面调入策略
为使进程能够正常运行，必须事先将要执行的那部分程序和数据所在的页面调入内存。现在的问题是：
1.  系统应在**何时**调入所需页面？
2.  系统应从**何处**调入这些页面？
3.  是**如何**进行调入的？

**1. 何时调入页面**
为了确定系统将进程运行时所缺的页面调入内存的时机，可采取两种调页策略：
*   **(1) 预调页策略 (Prepaging)**
    *   **思想**：如果进程的许多页是存放在外存的一个连续区域中，一次调入若干个相邻的页会比一次调入一页更高效些。
    *   **机制**：采用一种以**预测为基础**的策略，将那些预计在不久之后便会被访问的页面预先调入内存。
    *   **效率**：如果预测较准确，则这种策略显然很有吸引力。但遗憾的是，目前预调页的成功率仅约50%。
    *   **应用场景**：
        *   **首次调入**：可用于在第一次将进程调入内存时，此时可将程序员指出的那些页先调入内存。
        *   **工作集模型**：在采用工作集的系统中，每个进程都具有一张表，表中记录有运行时的工作集。每当程序被调度运行时，将工作集中的所有页调入内存。 (工作集概念将在5.4节介绍)
*   **(2) 请求调页策略 (Demand Paging)**
    *   **思想**：当进程在运行中需要访问某部分程序和数据时，若发现其所在的页面不在内存，便立即提出请求，由 OS 将其所需页面调入内存。
    *   **特点**：由请求调页策略所确定调入的页是一定会被访问的。
    *   **实现**：请求调页策略比较易于实现。
    *   **开销**：这种策略每次仅调入一页，故须花费较大的系统开销，增加了磁盘I/O的启动频率。
    *   **应用**：在目前的虚拟存储器中，大多采用此策略。

**2. 从何处调入页面**
请求分页系统中的外存通常分为两部分：
*   **文件区 (File Area)**：用于存放文件，采用**离散分配方式**。
*   **对换区 (Swap Area)**：用于存放对换页面，通常采用**连续分配方式**，因此对换区的数据存取（磁盘I/O）速度比文件区的高。

每当发生缺页请求时，系统应从何处将缺页调入内存，可分成以下三种情况进行：
*   **(1) 系统拥有足够的对换区空间**：
    *   这时可以全部从对换区调入所需页面，以提高调页速度。
    *   为此，在进程运行前，便须将与该进程有关的文件从文件区拷贝到对换区。
*   **(2) 系统缺少足够的对换区空间**：
    *   这时凡是**不会被修改的文件**，都直接从文件区调入。
    *   而当换出这些页面时，由于它们未被修改，则不必再将它们重写到磁盘（换出），以后再调入时，仍从文件区直接调入。
    *   但对于那些**可能被修改的部分**，在将它们换出时便须调到对换区，以后需要时再从对换区调入。
*   **(3) UNIX方式**：
    *   由于与进程有关的文件都放在文件区，故凡是**未运行过的页面**，都应从文件区调入。
    *   而对于**曾经运行过但又被换出的页面**，由于是被放在对换区，因此在下次调入时应从对换区调入。
    *   由于 UNIX 系统允许页面共享，因此，某进程所请求的页面有 可能已被其它进程调入内存，此时也就无需再从对换区调入。

**3. 页面调入过程**
每当程序所要访问的页面未在内存时（页表项中存在位为"0"），便向 CPU 发出一缺页中断，中断处理程序首先保留 CPU 环境，分析中断原因后转入缺页中断处理程序。
该程序的处理流程如下：
1.  **查找页表**：通过查找页表得到该页在外存的物理块后。
2.  **判断内存是否有空闲**：
    *   **若内存能容纳新页 (有空闲物理块)**：则启动磁盘 I/O，将所缺之页调入内存，然后修改页表中相应的表项 (状态位置"1"，物理块号，修改位置"0")。
    *   **若内存已满**：
        *   则须先按照某种**页面置换算法**，从内存中选出一页准备换出。
        *   **若该页未被修改过 (修改位为"0")**：可不必将该页写回磁盘。
        *   **但如果此页已被修改过 (修改位为"1")**：则必须将它写回磁盘。
        *   然后再把所缺的页调入内存，并修改页表中的相应表项（状态位、物理块号、修改位），并将此页表项写入快表中。
3.  **访问数据**：在缺页调入内存后，利用修改后的页表形成所要访问数据的物理地址，再去访问内存数据。
整个页面的调入过程对用户是透明的。

**4. 缺页率 (Page Fault Rate)**
*   **定义**：假设一个进程的逻辑空间为 *n* 页，系统为其分配的内存物理块数为 *m* (m ≤ n)。如果在进程的运行过程中，访问页面成功（即所访问页面在内存中）的次数为 *S*，访问页面失败（即所访问页面不在内存中，需要从外存调入）的次数为 *F*，则该进程总的页面访问次数为 *A = S + F*。那么，该进程在其运行过程中的**缺页率**即为：
    *f = F / A*
*   **影响缺页率的因素**：
    *   **(1) 页面大小**：页面划分较大，则缺页率较低；反之，缺页率较高（但页面过大也可能导致内部碎片和换入不必要数据）。
    *   **(2) 进程所分配物理块的数目**：所分配的物理块数目越多，缺页率越低；反之则越高。
    *   **(3) 页面置换算法**：算法的优劣决定了进程执行过程中缺页中断的次数，因此缺页率是衡量页面置换算法的重要指标。
    *   **(4) 程序固有特性**：程序本身的编制方法对缺页中断次数有影响。根据程序执行的局部性原理，程序编制的局部化程度越高，相应执行时的缺页程度越低。
*   **缺页中断处理时间**：
    在缺页中断处理时，如果由于空间不足，需要置换部分页面到外存，选择被置换页面时还需要考虑到置换的代价，如页面是否被修改过。
    *   没有修改过的页面可以直接放弃。
    *   修改过的页面则必须进行保存（写回磁盘）。
    处理这两种情况的时间也是不同的。假设被置换的页面被修改的概率是 β，其缺页中断处理时间（将修改页写回磁盘并调入新页）为 t<sub>a</sub>，被置换页面没有被修改的缺页中断处理时间（直接调入新页）为 t<sub>b</sub>，那么，缺页中断的平均处理时间 *t* 为：
    *t = β × t<sub>a</sub> + (1 - β) × t<sub>b</sub>*