
在进程运行过程中，若其所要访问的页面不在内存，而需把它们调入内存，但内存已无空闲空间时，为了保证该进程能正常运行，系统必须从内存中调出一页程序或数据送到磁盘的对换区中。但应将哪个页面调出，须根据一定的算法来确定。通常，把选择换出页面的算法称为**页面置换算法**。
*   **目标**：一个好的页面置换算法应具有较低的页面更换频率。
*   **"抖动" (Thrashing)**：不适当的算法可能会导致进程发生“抖动”，即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出；而此刚被调出的页很快又被访问，又需将它调入，如此频繁地更换页面，以致一个进程在运行中把大部分时间都花费在页面置换工作上。
*   **理论上理想的算法**：应将那些以后不再会访问的页面换出，或把那些在较长时间内不会再访问的页面调出。
目前已有多种置换算法，它们都试图更接近于理论上的目标。
### 5.3.1 最佳置换算法和先进先出置换算法
下面将介绍的是两种比较极端的算法。
**1. 最佳(Optimal)置换算法 (OPT / MIN)**

*   **提出者与时间**：由 Belady 于 1966 年提出。
*   **核心思想**：其所选择的被淘汰页面将是**以后永不使用**的，或者是在**最长(未来)时间内不再被访问**的页面。
*   **性能**：采用最佳置换算法通常可保证获得最低的缺页率。
*   **局限性**：由于人们目前还无法预知一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法**无法实现**。
*   **作用**：可以利用该算法去评价其它算法。

**示例：**
假定系统为某进程分配了三个物理块，并考虑有以下的页面号引用串：
`7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1`
![[Pasted image 20250531133823.png]]
**置换过程 (初始内存为空，分配3个物理块)：**

| 访问序列 | 内存状态 (块0) | 内存状态 (块1) | 内存状态 (块2) | 缺页? | 换出页 | 说明 (未来访问情况)                                     |
| :------- | :------------- | :------------- | :------------- | :---- | :----- | :------------------------------------------------------ |
| 7        | 7              |                |                | 是    | -      |                                                         |
| 0        | 7              | 0              |                | 是    | -      |                                                         |
| 1        | 7              | 0              | 1              | 是    | -      | 内存满：7, 0, 1                                         |
| **2**    | **2**          | 0              | 1              | 是    | **7**  | 缺页，需换出。未来：0(下个), 1(第14个), 7(第18个)。换出7。 |
| 0        | 2              | 0              | 1              | 否    | -      |                                                         |
| **3**    | 2              | **3**          | 1              | 是    | **0**  | 缺页，需换出。未来：1(第14个), 2(第9个), 0(第7个)。换出0。 (注：此处原笔记可能有误，应换最晚访问的，此处0比1先访问，若0和1未来都不访问，则任选，但0在第7个访问，1在第14个访问，2在第9个访问，所以应该换出1。但如果原文图示是换0，可能是示例侧重不同。此处按原文的思路是换最远访问的。如果看图5-3，是换出页面7，然后是页面1。我们按照图示的来，即7,0,1 -> 2,0,1(7换出)，然后访问3时，内存是2,0,1，未来访问顺序0(最近), 2(次近), 1(最远)，所以换出1。即：2,0,3(1换出)。)  **按照图5-3的逻辑，当访问2时，内存为7,0,1，未来访问：0(第5个)，1(第14个)，7(第18个)，所以7最远，换出7。内存变为2,0,1。当访问3时，内存为2,0,1，未来访问：0(第7个)，2(第9个)，1(第14个)，所以1最远，换出1。内存变为2,0,3。** |
| 0        | 2              | 0              | 3              | 否    | -      |                                                         |
| **4**    | **4**          | 0              | 3              | 是    | **2**  | 缺页，需换出。未来：0(第11个), 3(第10个), 2(第9个)。换出2。 |
| 2        | 4              | 0              | **2**          | 是    | **3**  | 缺页，需换出。未来：0(第11个), 4(无), 3(第10个)。换出4。  |
| 3        | 3              | 0              | 2              | 是    | **4**  | (按图是换3，内存4,0,2 -> 3,0,2。此时未来：0(11), 2(13), 3(12), 4(无)，所以换4)  **按图5-3，访问2后内存为4,0,3，访问2，命中。访问3，命中。访问0，命中。访问3，命中。访问2，命中。访问1，缺页。内存4,0,2，未来：0(16)，2(15)，1(17)，4(无)。换4。内存1,0,2。** |
| ...      | ...            | ...            | ...            | ...   | ...    |  (后续以此类推)                                         |

**根据图5-3，OPT算法发生了6次页面置换。**

**2. 先进先出(FIFO)页面置换算法**

*   **原理**：最早出现的置换算法。该算法总是淘汰**最先进入内存**的页面，即选择在内存中**驻留时间最久**的页面予以淘汰。
*   **实现**：实现简单，只需把一个进程已调入内存的页面按先后次序链接成一个队列，并设置一个替换指针，使它总是指向最老的页面。
*   **缺点**：与进程实际运行的规律不相适应，因为在进程中，有些页面经常被访问（如含有全局变量、常用函数、例程等的页面），FIFO算法并不能保证这些页面不被淘汰。性能较差。
*   **Belady异常**：对于FIFO算法，有时会出现分配的物理块数增加，缺页次数反而增加的异常现象。

**示例 (同上页面引用串和3个物理块)：**
![[Pasted image 20250531133925.png]]
**置换过程：**

| 访问序列 | 内存状态 (块0) | 内存状态 (块1) | 内存状态 (块2) | 缺页? | 换出页 | 进入顺序 (老->新) |
| :------- | :------------- | :------------- | :------------- | :---- | :----- | :---------------- |
| 7        | 7              |                |                | 是    | -      | 7                 |
| 0        | 7              | 0              |                | 是    | -      | 7, 0              |
| 1        | 7              | 0              | 1              | 是    | -      | 7, 0, 1           |
| **2**    | **2**          | 0              | 1              | 是    | **7**  | 0, 1, 2 (7最早进入) |
| 0        | 2              | 0              | 1              | 否    | -      | 0, 1, 2           |
| **3**    | 2              | **3**          | 1              | 是    | **0**  | 1, 2, 3 (0最早进入) |
| 0        | 2              | 3              | **0**          | 是    | **1**  | 2, 3, 0 (1最早进入) |
| **4**    | **4**          | 3              | 0              | 是    | **2**  | 3, 0, 4 (2最早进入) |
| 2        | 4              | **2**          | 0              | 是    | **3**  | 0, 4, 2 (3最早进入) |
| 3        | 4              | 2              | **3**          | 是    | **0**  | 4, 2, 3 (0最早进入) |
| ...      | ...            | ...            | ...            | ...   | ...    | ...               |

**根据图5-4，FIFO算法发生了12次页面置换，比最佳置换算法多一倍。**
### 5.3.2 最近最久未使用和最少使用置换算法

**1. 最近最久未使用(LRU - Least Recently Used)置换算法的描述**

*   **原因**：FIFO置换算法性能之所以较差，是因为它所依据的条件是各个页面调入内存的时间，而页面调入的先后并不能反映页面的使用情况。
*   **核心思想**：LRU算法是根据页面**调入内存后的使用情况**做出决策的。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU置换算法是选择**最近最久未使用的页面**予以淘汰。
*   **实现机制**：该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 *t*。当需淘汰一个页面时，选择现有页面中其 *t* 值最大的，即最近最久未使用的页面予以淘汰。
*   **性能**：LRU算法的性能较好，接近OPT算法。
**示例 (同上页面引用串和3个物理块)：**
![[Pasted image 20250531134007.png]]
**置换过程 (记录每个页面的上次访问时间，值越大越久未使用)：**

| 访问序列 | 内存状态 (块0) | 内存状态 (块1) | 内存状态 (块2) | 缺页? | 换出页 | 页面使用情况 (最近->最久) |
| :------- | :------------- | :------------- | :------------- | :---- | :----- | :------------------------ |
| 7        | 7              |                |                | 是    | -      | 7                         |
| 0        | 7              | 0              |                | 是    | -      | 0, 7                      |
| 1        | 7              | 0              | 1              | 是    | -      | 1, 0, 7                   |
| **2**    | **2**          | 0              | 1              | 是    | **7**  | 2, 1, 0 (7最久未使用)     |
| 0        | 2              | 0              | 1              | 否    | -      | 0, 2, 1                   |
| **3**    | 2              | 0              | **3**          | 是    | **1**  | 3, 0, 2 (1最久未使用)     |
| 0        | 2              | 0              | 3              | 否    | -      | 0, 3, 2                   |
| **4**    | **4**          | 0              | 3              | 是    | **2**  | 4, 0, 3 (2最久未使用)     |
| 2        | 4              | 0              | **2**          | 是    | **3**  | 2, 0, 4 (3最久未使用)     |
| 3        | **3**          | 0              | 2              | 是    | **4**  | 3, 2, 0 (4最久未使用)     |
| ...      | ...            | ...            | ...            | ...   | ...    | ...                       |

**根据图5-5，LRU算法与OPT算法在前5个时间的图像相同，但这并非必然。LRU是“向前看”（依据过去），OPT是“向后看”（依据未来）。**

**2. LRU 置换算法的硬件支持**

LRU置换算法虽然是一种比较好的算法，但要求系统有较多的硬件支持。需要硬件来记录每个页面的使用情况。
	![[Pasted image 20250531134122.png]]
*   **(1) 寄存器 (Counters)**
    *   为每个在内存中的页面配置一个**移位寄存器** R = R<sub>n-1</sub>R<sub>n-2</sub>...R<sub>1</sub>R<sub>0</sub>。
    *   当进程访问某物理块时，要将相应寄存器的最高位 R<sub>n-1</sub> 置为1。
    *   定时信号将每隔一定时间（例如100ms）将寄存器右移一位。
    *   R值最小的寄存器所对应的页面就是最近最久未使用的页面。
    *   **示例 (图5-6)**：某进程有8个页面，配置8位寄存器。当发生缺页时，R值最小的页面（如第3个页面）被换出。

*   **(2) 栈 (Stack)**
    *   可利用一个特殊的**栈**来保存当前使用的各个页面的页面号。
    *   每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。
    *   因此，栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面号。
    * ![[Pasted image 20250531134156.png]]
    *   **示例 (图5-7)**：进程有5个物理块，访问序列 `4, 7, 0, 7, 1, 0, 1, 2, 1, 2, 6`。
        *   访问4, 7, 0: 栈 `[0, 7, 4]` (0在顶, 4在底)
        *   访问7: 栈 `[7, 0, 4]`
        *   访问1: 栈 `[1, 7, 0, 4]`
        *   访问0: 栈 `[0, 1, 7, 4]`
        *   访问1: 栈 `[1, 0, 7, 4]`
        *   访问2: 栈 `[2, 1, 0, 7, 4]` (栈满)
        *   访问6 (缺页): 栈底的4是最近最久未使用的，被换出。栈变为 `[6, 2, 1, 0, 7]`。

**3. 最少使用(LFU - Least Frequently Used)置换算法**

*   **思想**：选择在最近时期**使用最少的页面**作为淘汰页。
*   **实现**：为在内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。
*   **与LRU硬件相似**：每次访问某页时，便将该移位寄存器的最高位置1，再每隔一定时间右移一次。这样，在最近一段时间使用最少的页面将是 ΣR<sub>i</sub> 最小的页。
*   **局限性**：这种算法并不能真正反映出页面的使用情况，因为在每一时间间隔内，只是用寄存器的一位来记录页的使用情况，因此，在该时间间隔内，对某页访问一次和访问1000次是完全等效的。（它更多反映的是“是否被访问过”，而不是“访问了多少次”）。

### 5.3.3 Clock 置换算法 (NRU - Not Recently Used / Second Chance Algorithm)
*   **背景**：LRU是一种较好的算法，但由于它要求有较多的硬件支持，使得其实现所需的成本较高。
*   **Clock算法**：是LRU的一种近似算法，用得较多。
**1. 简单的 Clock 置换算法**
*   **硬件需求**：只需为每页设置一位**访问位 (A)**，再将内存中的所有页面都通过链接指针链接成一个**循环队列**。
*   **访问时操作**：当某页被访问时，其访问位被置1。
*   **置换过程**：
    1.  当需要选择一页淘汰时，从指针当前指向的页面开始检查其访问位。
    2.  **如果访问位为0**：就选择该页换出。
    3.  **如果访问位为1**：则重新将它置0，暂不换出，给予该页第二次驻留内存的机会，再按照FIFO算法检查下一个页面。
    4.  当检查到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首去检查第一个页面。
*   **名称由来**：由于该算法是循环地检查各页面的使用情况，故称为Clock算法。又因该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面换出去，故又把该算法称为**最近未用算法 (NRU - Not Recently Used)**。
*   **图示 (图5-8)**：显示了简单Clock算法的流程和示例，指针在循环队列中移动，检查访问位。
   ![[Pasted image 20250531134224.png]]
**2. 改进型 Clock 置换算法**
*   **背景**：在将一个页面换出时，如果该页已被修改过，便须将该页重新写回到磁盘上；但如果该页未被修改过，则不必将它拷回磁盘。换而言之，对于修改过的页面，在换出时所付出的开销比未修改过的页面大。
*   **改进思路**：在改进型Clock算法中，除了须考虑页面的使用情况外，还须再增加一个因素——**置换代价**，即同时考虑**访问位A**和**修改位M**。
*   **页面分类 (由A和M组合)**：
    *   **1类 (A=0, M=0)**：表示该页最近既未被访问，又未被修改，是**最佳淘汰页**。
    *   **2类 (A=0, M=1)**：表示该页最近未被访问，但已被修改，并不是很好的淘汰页（因为要写回磁盘）。
    *   **3类 (A=1, M=0)**：表示该页最近已被访问，但未被修改，该页有可能再被访问。
    *   **4类 (A=1, M=1)**：表示该页最近已被访问且被修改，该页可能再被访问。
*   **置换步骤 (扫描循环队列)**：
    1.  **第一轮**：从指针所指示的当前位置开始，扫描循环队列，寻找 A=0 且 M=0 的第一类页面，将所遇到的第一个这类页面作为所选中的淘汰页。在第一次扫描期间不改变访问位A。
    2.  **第二轮 (若第一步失败)**：即查找一轮后未遇到第一类页面，则开始第二轮扫描，寻找 A=0 且 M=1 的第二类页面，将所遇到的第一个这类页面作为淘汰页。在第二轮扫描期间，将所有扫描过的页面的访问位都置0。
    3.  **第三轮 (若第二步也失败)**：即未找到第二类页面，则将指针返回到开始的位置，并将所有的访问位复0。然后重复第一步（寻找A=0, M=0的页面），如果仍失败，必要时再重复第二步（寻找A=0, M=1的页面），此时就一定能找到被淘汰的页。
*   **效果**：该算法与简单Clock算法比较，可减少磁盘的I/O操作次数。但为了找到一个可置换的页，可能须经过几轮扫描，实现该算法本身的开销将有所增加。

### 5.3.4 页面缓冲算法 (PBA - Page Buffering Algorithm)

*   **背景**：在请求分页系统中，由于进程在运行时经常会发生页面换进换出的情况，页面换进换出所付出的开销将对系统性能产生重大影响。

**1. 影响页面换进换出效率的若干因素**

*   **(1) 页面置换算法**：影响页面换进换出效率最重要的因素。好的算法可使进程在运行过程中具有较低的缺页率，从而可以减少页面换进换出的开销。
*   **(2) 写回磁盘的频率**：对于已经被修改过的页面，在将其换出时，应当写回磁盘。如果是采取每当有一个页面要被换出时就将它写回磁盘的策略，这意味着每换出一个页面，便需要启动一次磁盘。
*   **(3) 将磁盘内容读入内存的频率**。

**PBA算法试图通过以下方式来改善这些因素：**

*   **页面缓冲算法的主要特点**：
    *   **显著降低页面换进、换出的频率**，使磁盘I/O的操作次数大为减少，因而减少了页面换进、换出的开销。
    *   正是由于换入换出的开销大幅度减小，才能使其采用一种较简单的置换策略，如**先进先出(FIFO)算法**，它不需要特殊硬件的支持，实现起来非常简单。
**页面缓冲算法的实现 (以 VAX/VMS 操作系统为例)：**
在该系统中，内存分配策略上采用了可变分配和局部置换方式，系统为每个进程分配一定数目的物理块，系统自己保留一部分空闲物理块。为了能显著地降低页面换进、换出的频率，在内存中设置了如下两个链表：
*   **(1) 空闲页面链表 (Free Page List)**：
    *   实际上这是一个**空闲物理块链表**，是系统掌握的空闲物理块，用于分配给频繁发生缺页的进程，以降低该进程的缺页率。
    *   当一个**未被修改**的页要换出时，实际上并不将它换出到外存，而是把它们所在的物理块挂在空闲链表的末尾。
    *   这些挂在空闲链表上的未被修改的页面中是**有数据**的。如果以后某进程需要这些页面中的数据时，便可从空闲链表上将它们取下，免除了从磁盘读入数据的操作，减少了页面换进的开销。
*   **(2) 修改页面链表 (Modified Page List)**：
    *   它是由**已修改的页面**所形成的链表。
    *   设置该链表的目的是为了**减少已修改页面换出的次数**。
    *   当进程需要将一个已修改的页面换出时，系统并不立即把它换出到外存上，而是将它所在的物理块挂在修改页面链表的末尾。
    *   这样做的目的是：
        *   **降低将已修改页面写回磁盘的频率**：仅当修改页面链表上的页面数目达到一定值时（例如64个页面），再将它们一起写回到磁盘上，这样就显著地减少了磁盘I/O的操作次数。
        *   **降低将磁盘内容读入内存的频率**：如果在该链表上暂时装有数据的页面，有进程在这些数据还未写回磁盘时需要再次访问这些页面时，就不需从外存上调入，而直接从修改页面链表中获取。
### 5.3.5 访问内存的有效时间 (EAT - Effective Access Time)

与基本分页存储管理方式不同，在请求分页管理方式中，内存有效访问时间不仅要考虑访问页表和访问实际物理地址数据的时间，还必须要考虑到**缺页中断的处理时间**。

在具有快表机制的请求分页管理方式中，存在下面三种方式的内存访问操作，其有效访问时间的计算公式也有所不同：
*   **(1) 被访问页在内存中，且其对应的页表项在快表中**：
    *   此时不存在缺页中断情况。
    *   EAT = λ + t
        *   λ：查找快表的时间
        *   t：访问实际物理地址所需的时间
*   **(2) 被访问页在内存中，且其对应的页表项不在快表中**：
    *   此时也不存在缺页中断情况，但需要两次访问内存（一次读取页表，一次读取数据），另外还需要更新快表。
    *   $EAT = λ + t + λ + t = 2 × (λ + t)$
        *   (第一次 λ+t 是查快表未中后，访问主存页表；第二次 λ+t 是更新快表后，访问实际数据。更精确的表达可能是：λ (查快表) + t (查主存页表) + λ (更新快表) + t (访问数据) )
        *   原文简化为2次内存访问。
*   **(3) 被访问页不在内存中 (发生缺页中断)**：
    *   需要进行缺页中断处理。
    *   假设缺页中断处理时间为 ε。
    *   $EAT = λ (查快表) + t (查主存页表发现缺页) + ε (缺页处理) + λ (更新快表) + t (访问数据)$
    *   $EAT = ε + 2 × (λ + t)  (原文的简化公式)$
**考虑命中率和缺页率的EAT计算：**

令：
*   a：快表命中率
*   f：缺页率 (1-f 为页在内存中的概率，假设页不在内存必缺页)
*   λ：查找快表的时间
*   t：访问内存一次的时间 (查找主页表或访问数据)
*   ε：缺页中断平均处理时间 (包括调页、可能发生的写回等)

则综合的有效访问时间 EAT 为：

$EAT = a × (λ + t) + (1 - a) × [λ + t + f × (ε + λ + t) + (1 - f) × (λ + t)]$
这似乎将快表未命中后，无论是否缺页都再次查了一遍快表。

更简洁且逻辑清晰的推导是：
1.  **快表命中 (概率 a)**：访问时间 = λ + t
2.  **快表未命中 (概率 1-a)**：
    *   访问主存页表：时间 t
    *   **页面在内存 (概率 1-f)**：更新快表，访问数据。时间 λ + t
    *   **页面不在内存 (概率 f)**：发生缺页中断，处理，更新快表，访问数据。时间 ε + λ + t

	$EAT = a × (λ + t)+ (1 - a) × [t   + (1 - f) × (λ + t)+ f × (ε + λ + t)  ]$



