
1.  **常规存储器管理方式具有哪两大特征？它对系统性能有何影响？**
    *   **两大特征**：
        1.  **一次性**：作业必须一次性全部装入内存后方能开始运行。
        2.  **驻留性**：作业被装入内存后，整个作业都一直驻留在内存中，直至作业运行结束。
    *   **对系统性能的影响**：
        *   **一次性**导致：
            *   大作业无法在小内存中运行。
            *   内存利用率不高，因为作业在运行时并非所有部分都会被用到。
            *   限制了多道程序度，进而影响了处理机的利用率和系统的吞吐量。
        *   **驻留性**导致：
            *   内存中可能驻留了大量暂时不用或不再用的程序和数据，浪费了宝贵的内存资源。
            *   进一步限制了可以并发运行的作业数量。
2.  **什么是程序运行时的时间局限性和空间局限性？**
    *   **时间局限性 (Temporal Locality)**：指如果程序中的某条指令被执行，则不久以后该指令可能再次被执行；如果某数据被访问过，则不久以后该数据可能再次被访问。典型原因是程序中存在大量的循环操作。
    *   **空间局限性 (Spatial Locality)**：指一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问。典型情况是程序的顺序执行以及对数组等连续数据结构的操作。
3.  **虚拟存储器有哪些特征？其中最本质的特征是什么？**
    *   **特征**：
        1.  **多次性**：一个作业中的程序和数据无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。
        2.  **对换性**：允许在作业的运行过程中进行换进、换出。暂不使用的代码和数据可以从内存调至外存，需要时再调入内存。
        3.  **虚拟性**：能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。
    *   **最本质的特征**：**虚拟性**。它直接体现了虚拟存储器的核心目标——在逻辑上扩充内存容量，从而能够运行更大的程序或支持更高的多道程序度。多次性和对换性是实现虚拟性的基础和手段。
4.  **实现虚拟存储器需要哪些硬件支持？**
    *   **请求分页系统**：
        1.  **请求页表机制**：页表中需要包含状态位(存在位)、访问位、修改位、外存地址等字段。
        2.  **缺页中断机构**：能够在指令执行期间检测到页面不在内存并产生中断。
        3.  **地址变换机构**：能够处理缺页中断，并结合页表完成逻辑地址到物理地址的转换。
        4.  （可选）**快表 (TLB)**：用于加速地址变换。
    *   **请求分段系统**：
        1.  **请求段表机制**：段表中需要包含状态位(存在位)、访问位、修改位、外存地址、存取方式、增补位等字段。
        2.  **缺段中断机构**：能够在指令执行期间检测到分段不在内存并产生中断。
        3.  **地址变换机构**：能够处理缺段中断，并结合段表完成逻辑地址到物理地址的转换。
        4.  （可选）**段表寄存器**：存放段表始址和长度。
5.  **实现虚拟存储器需要哪几个关键技术？**
    1.  **请求调页/调段技术**：当访问的页面/段不在内存时，能够将其从外存调入内存。
    2.  **页面/分段置换技术**：当内存已满而需要调入新的页面/段时，能够选择合适的页面/段从内存中换出。
    3.  **地址映射技术**：能够在页面/段可能不在内存的情况下，有效地将逻辑地址转换为物理地址。
    4.  **中断处理技术**：包括缺页/缺段中断的产生、处理和返回。
    5.  （广义上）**内存分配与管理技术**：如何在虚拟环境下为进程分配物理内存。
6.  **在请求分页系统中，页表应包括哪些数据项？每项的作用是什么？**
    *   **页号**：逻辑页的编号。
    *   **物理块号**：该页在内存中对应的物理块号 (如果已调入)。
    *   **状态位 P (存在位)**：指示该页是否已调入内存。P=1表示在内存，P=0表示不在内存。用于判断是否发生缺页中断。
    *   **访问字段 A (访问位)**：记录本页在一段时间内是否被访问过。供页面置换算法参考。
    *   **修改位 M (脏位)**：标识该页在调入内存后是否被修改过。若未被修改，则置换时无需写回外存；若被修改，则必须写回外存。
    *   **外存地址**：指出该页在外存上的存放地址。供调入该页时参考。
7.  **试比较缺页中断机构与一般的中断，它们之间有何明显的区别？**
    *   **产生时间**：
        *   **一般中断**：通常在一条指令执行完毕后，CPU才检查是否有中断请求。
        *   **缺页中断**：在指令执行期间，当发现所要访问的指令或数据所在的页面不在内存时，立即产生。
    *   **中断次数**：
        *   **一般中断**：一条指令通常只与一次（或零次）中断相关联（例如，指令执行完成后的I/O中断）。
        *   **缺页中断**：一条指令在执行期间可能产生多次缺页中断（例如，指令跨页、操作数跨页且都不在内存时）。
    *   **处理后返回点**：
        *   **一般中断**：通常返回到被中断指令的下一条指令。
        *   **缺页中断**：处理完成后，必须返回到被中断的指令处重新执行该指令，因为该指令由于缺页而未能完成。
8.  **试说明请求分页系统中的地址变换过程。**
    1.  CPU给出逻辑地址（页号P，页内偏移W）。
    2.  **查快表(TLB)**：根据页号P查找快表。
        *   **若命中且页在内存**：从快表得到物理块号F，形成物理地址=F\*页面大小+W，访问内存。修改快表项的访问位/修改位。
        *   **若未命中或页不在内存（在快表中P位为0的情况理论上不应发生，若发生则同步问题）**：
    3.  **查主存页表**：根据页号P访问内存中的页表。
        *   找到对应页表项。
        *   **检查状态位P**：
            *   **若P=1（页在内存）**：
                *   将该页表项内容装入快表（若TLB有空间或按替换策略）。
                *   从页表项得到物理块号F，形成物理地址=F\*页面大小+W，访问内存。
                *   修改页表项的访问位/修改位。
            *   **若P=0（页不在内存，发生缺页中断）**：
                *   产生缺页中断。
                *   操作系统进行缺页处理：
                    *   保护CPU现场。
                    *   查找该页在外存的地址。
                    *   检查内存是否有空闲物理块：
                        *   若有：分配物理块，启动磁盘I/O将该页调入内存。
                        *   若无：执行页面置换算法，选择一页换出（若修改过则写回磁盘），将腾出的物理块分配给新页，启动磁盘I/O调入新页。
                    *   页面调入完成后，修改页表项（P=1，填入物理块号，M=0，A=1）。
                    *   （可选）将新页表项装入快表。
                    *   恢复CPU现场，重新执行被中断的指令。
9.  **何谓固定分配局部置换和可变分配全局置换的内存分配策略？**
    *   **固定分配局部置换 (Fixed Allocation, Local Replacement)**：
        *   **固定分配**：为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。
        *   **局部置换**：如果进程在运行中发生缺页，则只能从分配给该进程的那些物理块中选择一页换出，然后再调入所需页面。进程的内存空间大小保持不变。
    *   **可变分配全局置换 (Variable Allocation, Global Replacement)**：
        *   **可变分配**：先为每个进程分配一定数目的物理块，在进程运行期间，分配给该进程的物理块数可以动态改变（增加或减少）。
        *   **全局置换**：如果进程在运行中发生缺页，操作系统可以从系统的空闲物理块队列中取出一块分配给该进程，或者以系统中所有驻留进程的全部物理块为目标，选择一个物理块换出（可能属于其他进程），然后将所需页面调入。
10. **在请求分页系统中，应从何处将所需页面调入内存？**
    通常有三种情况：
    1.  **系统拥有足够的对换区空间**：可以将与进程相关的文件在运行前从文件区拷贝到对换区，调页时全部从对换区调入，速度较快。
    2.  **系统缺少足够的对换区空间**：
        *   对于不会被修改的文件（如代码段），可以直接从文件区调入。当这些页面被换出时，因为未被修改，无需写回，下次需要时仍从文件区调入。
        *   对于可能被修改的数据段，当它们被换出时，必须调到对换区保存，下次需要时再从对换区调入。
    3.  **UNIX方式**：
        *   未运行过的页面，从文件区调入。
        *   曾经运行过但又被换出的页面（已在对换区），从对换区调入。
        *   如果所请求的页面已被其他共享该页面的进程调入内存，则无需再从外存调入。
11. **试说明在请求分页系统中页面的调入过程。**
    1.  当程序访问的页面不在内存时（页表项中存在位P=0），CPU产生**缺页中断**。
    2.  中断处理程序首先**保留CPU现场**，分析中断原因，转入缺页中断处理程序。
    3.  缺页中断处理程序通过查找页表，找到该页在**外存的地址**。
    4.  检查内存是否有**空闲物理块**：
        *   **若有空闲块**：分配一个物理块，启动磁盘I/O，将所缺之页从外存调入该物理块。
        *   **若无空闲块**：执行**页面置换算法**，选择内存中的一个页面准备换出。
            *   如果被换出页的**修改位M=1**（已被修改），则需将其内容写回外存相应的磁盘块。
            *   如果被换出页的**修改位M=0**（未被修改），则无需写回。
            *   将被换出页所占用的物理块分配给新调入的页，启动磁盘I/O，将所缺之页调入该物理块。
    5.  页面调入内存后，**修改内存中相应页表项的内容**：将存在位P置1，填入分配到的物理块号，修改位M置0（刚调入，未修改），访问位A通常置1（因为刚被访问）。
    6.  （可选）如果系统有快表(TLB)，则将该页表项写入快表。
    7.  **恢复CPU现场**，使被中断的指令**重新执行**。
12. **在请求分页系统中，常采用哪几种页面置换算法？**
    常用的页面置换算法有：
    1.  **最佳置换算法 (OPT / MIN)** (理论上的，无法实现)
    2.  **先进先出置换算法 (FIFO)**
    3.  **最近最久未使用置换算法 (LRU)**
    4.  **最少使用置换算法 (LFU)** (LRU的变种或近似)
    5.  **Clock (时钟) 置换算法 / 最近未用算法 (NRU)** (LRU的近似)
    6.  **改进型 Clock 置换算法** (考虑修改位)
    7.  **页面缓冲算法 (PBA)** (结合FIFO等，利用空闲和修改页面链表)
13. **在一个请求分页系统中，采用FIFO页面置换算法时，假如一个作业的页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配给该作业的物理块数M分别为3和4时，试计算在访问过程中所发生的缺页次数和缺页率，并比较所得结果。**
    * ***M = 3 (3个物理块)**
    页面走向: 4, 3, 2, 1, 4, 3, 5, 4, 3, 2, 1, 5


| **访问** | **内存状态 (FIFO顺序)** | **缺页?** | **换出** |
| ------ | ----------------- | ------- | ------ |
| 4      | 4                 | 是       |        |
| 3      | 4, 3              | 是       |        |
| 2      | 4, 3, 2           | 是       |        |
| 1      | 3, 2, 1           | 是       | 4      |
| 4      | 2, 1, 4           | 是       | 3      |
| 3      | 1, 4, 3           | 是       | 2      |
| 5      | 4, 3, 5           | 是       | 1      |
| 4      | 4, 3, 5           | 否       |        |
| 3      | 4, 3, 5           | 否       |        |
| 2      | 3, 5, 2           | 是       | 4      |
| 1      | 5, 2, 1           | 是       | 3      |
| 5      | 5, 2, 1           | 否       |        |

*   缺页次数 = 9
*   总访问次数 = 12
*   缺页率 = 9 / 12 = 0.75
M = 4 (4个物理块)
页面走向: 4, 3, 2, 1, 4, 3, 5, 4, 3, 2, 1, 5

| **访问** | **内存状态 (FIFO顺序)** | **缺页?** | **换出** |
| ------ | ----------------- | ------- | ------ |
| 4      | 4                 | 是       |        |
| 3      | 4, 3              | 是       |        |
| 2      | 4, 3, 2           | 是       |        |
| 1      | 4, 3, 2, 1        | 是       |        |
| 4      | 4, 3, 2, 1        | 否       |        |
| 3      | 4, 3, 2, 1        | 否       |        |
| 5      | 3, 2, 1, 5        | 是       | 4      |
| 4      | 2, 1, 5, 4        | 是       | 3      |
| 3      | 1, 5, 4, 3        | 是       | 2      |
| 2      | 5, 4, 3, 2        | 是       | 1      |
| 1      | 4, 3, 2, 1        | 是       | 5      |
| 5      | 3, 2, 1, 5        | 是       | 4      |

 缺页次数 = 10
总访问次数 = 12
缺页率 = 10 / 12 ≈ 0.833
比较结果
在此特定页面走向和FIFO算法下，当物理块数从3增加到4时，缺页次数反而从9次增加到了10次，缺页率从0.75上升到了约0.833。这体现了FIFO算法可能存在的**Belady异常现象**。



14. **实现LRU算法所需的硬件支持是什么？**
    实现LRU（最近最久未使用）算法需要硬件来精确地记录每个页面的访问历史，以便找出在过去一段时间内最久没有被访问过的页面。主要的硬件支持方式有：
    1.  **寄存器 (Counters / Timers)**：
        *   为内存中的每个物理块（或每个页表项）配备一个寄存器或计数器。
        *   每当一个页面被访问时，将其对应寄存器的内容设置为当前时间（或一个递增的计数值）。
        *   当需要置换页面时，选择具有最小时间戳（即最久未被访问）的页面。
        *   或者，使用移位寄存器：当页面被访问时，其对应寄存器的最高位置1；定时器周期性地将所有寄存器右移一位。值最小的寄存器对应的页面即为LRU页。
    2.  **栈 (Stack)**：
        *   维护一个特殊的硬件栈，栈中按访问时间顺序存放当前在内存中的页面的页号（或物理块号）。
        *   当一个页面被访问时：
            *   如果该页号已在栈中，则将其从当前位置移出。
            *   将该页号压入栈顶。
        *   这样，栈顶始终是最近一次被访问的页面，而栈底则是最近最久未使用的页面。置换时选择栈底的页面。
    这些硬件支持的实现成本较高，因此纯粹的LRU算法在实际系统中较少直接实现，更多的是采用其近似算法。

15. **试说明改进型 Clock 置换算法的基本原理。**
    改进型Clock置换算法是在简单Clock算法（只考虑访问位A）的基础上，额外考虑了**修改位M**，目的是在选择淘汰页时，优先选择那些没有被修改过的页面，以减少写回磁盘的I/O开销。
    基本原理：
    1.  将内存中的所有页面组织成一个循环队列，并使用一个指针指向当前检查的页面。
    2.  每个页面有两个状态位：访问位A和修改位M。
    3.  置换时，算法通过多轮扫描循环队列来寻找合适的淘汰页：
        *   **第一轮扫描 (寻找 A=0, M=0 的页面)**：
            *   从指针当前位置开始，检查队列中的页面。
            *   如果找到一个页面的 A=0 且 M=0（即最近未被访问且未被修改），则选择该页淘汰，算法结束。
            *   在这一轮扫描中，不改变任何页面的访问位A。
        *   **第二轮扫描 (寻找 A=0, M=1 的页面，并重置A位)**：
            *   如果第一轮未找到可淘汰页，指针回到起始位置（或从上次停止处继续，但通常会重置A位）。
            *   从指针当前位置开始，检查队列中的页面。
            *   如果找到一个页面的 A=0 且 M=1（即最近未被访问但已被修改），则选择该页淘汰，算法结束。
            *   在这一轮扫描中，将所有经过的页面的访问位A置为0（给它们下一次机会）。
        *   **重复扫描 (如果前两轮都未找到)**：
            *   指针回到起始位置。由于第二轮扫描已将所有页面的A位置0，此时再次进行第一轮扫描（寻找A=0, M=0）必然能找到至少一个A=0的页面。如果找到A=0, M=0的则淘汰。
            *   如果所有A=0的页面都是M=1，则进行第二轮扫描（寻找A=0, M=1），此时必然能找到一个A=0, M=1的页面淘汰。
    通过这种方式，算法优先淘汰“干净”且未被访问的页面，其次是“脏”但未被访问的页面，然后是“干净”但被访问过的页面（在A位被清零后），最后是“脏”且被访问过的页面（在A位被清零后）。

16. **影响页面换进换出效率的若干因素是什么？**
    影响页面换进换出效率的因素主要包括：
    1.  **页面置换算法**：算法的优劣直接决定缺页率，从而影响换进换出的频率和总开销。
    2.  **写回磁盘的频率（针对脏页）**：如果脏页在换出时立即写回，会增加I/O次数。采用延迟写或批量写可以优化。
    3.  **页面调入策略（预调页 vs 请求调页）**：预调页如果准确，可以减少缺页；如果不准确，会调入不必要的页面。请求调页按需调入，但每次调一页开销可能较大。
    4.  **分配给进程的物理块数量**：物理块太少会导致高缺页率，物理块太多则浪费内存。
    5.  **页面大小**：页面过小导致页表过大，I/O次数可能增多；页面过大导致内部碎片严重，一次调入的数据可能很多是无用的。
    6.  **磁盘I/O速度**：外存的读写速度直接影响页面换入换出的时间。
    7.  **程序的局部性原理**：程序编写时若具有良好的局部性，则访问会集中在少数页面，缺页率低，换进换出次数少。
    8.  **多道程序度**：过高的多道程序度可能导致每个进程分配的物理块不足，从而增加整体的换进换出活动。

17. **页面缓冲算法的主要特点是什么？它是如何降低页面换进、换出的频率的？**
    *   **主要特点**：
        1.  **显著降低页面换进和换出的频率**：通过缓冲技术，减少了实际与磁盘交互的次数。
        2.  **允许采用较简单的置换策略**：由于I/O开销的降低，即使使用如FIFO这样简单的置换算法，整体性能也能接受，且实现简单，无需复杂硬件支持。
    *   **如何降低频率**：
        页面缓冲算法通常维护两个链表（或缓冲区）：
        1.  **空闲页面链表 (Free Page List)**：
            *   当一个**未被修改**的页面被选中换出时，它并**不立即从内存中清除或写回磁盘**，而是将其所在的物理块加入到空闲页面链表的末尾。这个物理块中的数据仍然保留。
            *   **降低读入频率**：如果这个“空闲”页面在被覆盖前又被访问到，那么可以直接从空闲链表中取回，而无需从磁盘重新调入，从而减少了磁盘读操作。
        2.  **修改页面链表 (Modified Page List / Dirty Page List)**：
            *   当一个**已被修改**的页面被选中换出时，它也**不立即写回磁盘**，而是将其所在的物理块加入到修改页面链表的末尾。
            *   **降低写回频率**：系统可以将修改页面链表中的多个脏页**批量地、异步地写回磁盘**（例如，当链表长度达到一定阈值，或在系统空闲时），而不是每次换出一个脏页就启动一次磁盘写操作，从而减少了磁盘写I/O的启动次数。
            *   **降低读入频率**：与空闲链表类似，如果修改链表中的某个脏页在被写回磁盘前又被访问到，可以直接从链表中取回，避免了磁盘读操作。

18. **在请求分页系统中，产生“抖动”的原因是什么？**
    产生“抖动”(Thrashing)的根本原因是**分配给并发运行进程的物理内存总量不足，导致每个进程获得的物理块数量过少，无法容纳其当前活跃使用的工作集页面。**
    具体连锁反应如下：
    1.  **物理块不足**：当系统中并发进程过多，或者单个进程需要的内存远超其分配到的物理块时，进程的常驻集远小于其工作集。
    2.  **高缺页率**：进程在执行过程中频繁遇到所需页面不在内存的情况，导致缺页中断频发。
    3.  **频繁页面置换**：为了调入新页面，必须频繁换出现有页面。由于物理块少，刚被换出的页面很可能在不久后又被需要，再次引发缺页和调页。
    4.  **CPU等待I/O**：进程大部分时间都花在等待页面从磁盘调入内存，而不是执行有效的计算任务，导致CPU利用率急剧下降。
    5.  **磁盘瓶颈**：大量的页面换入换出请求使得磁盘I/O系统高度繁忙，甚至成为瓶颈，进一步延长了缺页处理时间。
    6.  **恶性循环**：操作系统可能错误地认为CPU利用率低是因为多道程序度不够，从而试图调入更多进程，这反而加剧了物理内存的竞争，使抖动更加严重。
    最终结果是系统花费绝大部分时间在页面调度上，而实际的用户程序执行效率极低。

19. **何谓工作集？它是基于什么原理确定的？**
    *   **工作集 (Working Set)**：是指一个进程在某一个特定的时间窗口 Δ 内，实际访问的页面的集合。它反映了进程在最近一段时间内活跃使用的内存区域。记为 W(t, Δ)，表示在时间 t 之前的 Δ 时间单位内所访问的页面集合。
    *   **确定原理**：工作集的概念是基于**程序的局部性原理 (Principle of Locality)**。
        *   **时间局部性**：如果一个页面被访问，它在不久的将来很可能再次被访问。
        *   **空间局部性**：如果一个页面中的某个位置被访问，它附近的位置（可能在同一页面或相邻页面）在不久的将来很可能被访问。
        由于程序运行具有局部性，因此在一个较短的时间窗口内，进程的访存行为会集中在少数几个页面上。工作集就是试图捕获这个“活跃页面”的集合。因为无法精确预知未来，所以通常用进程在**过去**一个时间窗口 Δ 内实际访问过的页面集合来近似其当前或即将需要的工作集。

20. **当前可以利用哪几种方法来防止“抖动”？**
    防止“抖动”的方法主要是通过合理地管理多道程序度和进程的内存分配，确保进程拥有足够的物理块来容纳其工作集。常用方法有：
    1.  **采取局部置换策略**：当一个进程发生缺页时，只允许在其自身分配到的物理块中进行页面置换，而不是从全局选择。这可以防止一个抖动的进程抢占其他进程的页面，将抖动的影响局部化。
    2.  **工作集算法控制多道程序度**：
        *   在调入新进程或激活挂起进程之前，检查系统是否有足够的空闲物理块来满足该进程的工作集大小。如果不足，则不增加多道程序度，甚至可能挂起某些进程。
        *   监控所有运行进程的工作集大小总和，确保不超过可用物理内存。
    3.  **缺页率控制法 (PFF - Page Fault Frequency)**：
        *   为每个进程设定一个可接受的缺页率上限和下限。
        *   如果一个进程的缺页率高于上限，说明分配给它的物理块不足，系统应为其增加物理块。
        *   如果缺页率低于下限，说明分配给它的物理块过多，可以适当减少其物理块。
        *   如果没有足够的空闲物理块来增加，则可能需要降低多道程序度（挂起某些进程）。
    4.  **利用“L=S”准则调节多道程序度**：
        *   L 是平均缺页间隔时间，S 是平均缺页服务时间。
        *   若 L < S，说明缺页太频繁，应减少多道程序度。
        *   若 L > S，说明系统有能力支持更多进程，可适当增加多道程序度。
        *   目标是使 L ≈ S，以获得较好的CPU和磁盘利用率平衡。
    5.  **选择性暂停进程**：当检测到系统可能发生抖动时，主动选择一个或多个进程暂停（将其页面换出），以释放物理块给其他更需要的进程。选择暂停的进程可以基于优先级、已运行时间、资源占用等因素。

21. **试说明如何利用“L=S”准则来调节缺页率，以避免“抖动”的发生。**
    “L=S”准则是一种通过比较平均缺页间隔时间 (L) 和平均缺页服务时间 (S) 来动态调节多道程序度，从而控制缺页率并避免“抖动”的方法。
    *   **L (Mean time between page faults)**：指系统（或单个进程）平均两次发生缺页中断之间的时间。L越大，表示缺页率越低，CPU在两次缺页间能执行更多有效工作。
    *   **S (Mean page fault service time)**：指处理一次缺页中断所需的平均时间，包括将所需页面从磁盘调入内存、可能发生的页面换出、更新页表等操作的总时间。
    **调节原理与过程**：
    1.  **监控与计算**：操作系统持续监控并计算系统当前的L和S值。
    2.  **比较与决策**：
        *   **如果 L > S** (例如 L >> S)：
            *   **含义**：平均两次缺页之间的时间远大于处理一次缺页的时间。这表明系统缺页频率较低，CPU在两次缺页间有充足的时间进行计算，而磁盘相对空闲。
            *   **调节**：可以认为系统当前的多道程序度偏低，内存资源可能未被充分利用。此时，可以尝试**增加多道程序度**（例如，调入新的进程或激活挂起的进程），以期提高CPU和磁盘的利用率，提升系统吞吐量。
        *   **如果 L < S** (例如 L << S)：
            *   **含义**：平均两次缺页之间的时间远小于处理一次缺页的时间。这表明系统缺页频率非常高，CPU在两次缺页间几乎没有时间做有效工作，大部分时间都在等待页面调入。磁盘可能已经饱和，系统很可能处于或即将进入“抖动”状态。
            *   **调节**：必须**减少多道程序度**。例如，选择一个或多个进程暂停执行，将其页面换出到外存，释放它们占用的物理块，以增加分配给剩余活动进程的平均物理块数，从而降低它们的缺页率，使L值增大。
        *   **如果 L ≈ S**：
            *   **含义**：平均两次缺页之间的时间约等于处理一次缺页的时间。这表明缺页的发生和处理达到了一种相对平衡的状态。CPU在两次缺页之间有足够的时间进行计算，同时磁盘也在有效地为缺页服务。
            *   **目标**：此时，系统的CPU利用率和磁盘利用率可能都接近其峰值，系统运行在较优状态。应尽量维持这种状态。
    通过这种动态反馈调节机制，操作系统试图将系统的运行点维持在L≈S的区域，从而既能充分利用资源，又能有效避免因多道程序度过高而导致的“抖动”现象。

22. **为了实现请求分段式存储管理，应在系统中增加配置哪些硬件机构？**
    实现请求分段式存储管理，需要在基本分段系统的硬件基础上增加或强化以下机构：
    1.  **请求段表机制 (Enhanced Segment Table Mechanism)**：
        *   段表（Segment Table）的每个表项需要包含更多信息，以支持虚拟存储功能。除了段号、段长、段基址（内存起始地址）、存取方式外，还必须有：
            *   **存在位 P (Presence Bit)**：指示该段是否已调入内存。
            *   **访问字段 A (Access Bit)**：记录该段在一段时间内是否被访问过，供置换算法参考。
            *   **修改位 M (Modify/Dirty Bit)**：标识该段在调入内存后是否被修改过，供置换时判断是否需要写回外存。
            *   **外存始址 (External Storage Address)**：指示该段在外存磁盘上的存放位置（如起始盘块号）。
            *   **增补位 (Growth Bit / Expansion Bit)**：用于某些允许动态增长的段（如栈段或堆段），指示段是否已增长。
    2.  **缺段中断机构 (Segment Fault Interrupt Mechanism)**：
        *   当CPU访问的逻辑地址对应的段不在内存时（即段表项中存在位P=0），硬件能够检测到这种情况，并立即产生一个**缺段中断**信号，暂停当前指令的执行，将控制权转交给操作系统。
        *   该机构需要能在指令执行期间产生和处理中断。
    3.  **地址变换机构 (Address Translation Mechanism with Fault Handling)**：
        *   在基本分段地址变换的基础上，增强其功能以处理缺段情况。
        *   能根据逻辑地址中的段号查找请求段表。
        *   进行段号有效性检查（与段表长度比较）。
        *   进行段内地址越界检查（与段长比较）。
        *   进行存取权限检查（根据段表中的存取方式字段）。
        *   当检测到段不存在于内存时（P=0），能够触发缺段中断。
        *   在缺段处理完成后，能够使用更新后的段表信息完成地址变换。
    4.  **段表寄存器 (Segment Table Base Register - STBR & Segment Table Length Register - STLR)**：
        *   STBR存放当前进程段表的起始物理地址。
        *   STLR存放当前进程段表的长度（段的个数）。
        *   用于快速定位段表和进行段号越界检查。这些在基本分段系统中也需要，但在请求分段中其与中断和地址变换的配合更为复杂。

23. **在请求段表机制中，应设置哪些段表项？**
    *(此题与上一题中“请求段表机制”部分内容重复，此处列出段表*项*的具体字段)*
    在请求分段系统的段表中，每个段表项（对应一个逻辑段）通常应设置以下字段：
    *   **段名 (或段号)**：该段的唯一标识符，用于在段表中索引。
    *   **段长 (Segment Length)**：记录该段的实际长度（以字节或字为单位）。用于段内地址越界检查。
    *   **段基址 (Segment Base Address / Memory Start Address)**：如果该段已调入内存，则此字段存放该段在主存中的起始物理地址。
    *   **存取方式 (Access Control / Protection Bits)**：规定对该段的允许访问类型，如只读（R）、只执行（X）、读/写（RW）、系统段等。用于访问权限检查。
    *   **访问字段 A (Access Bit)**：一个或多个位，用于记录该段在最近一段时间内是否被访问过。供分段置换算法参考。
    *   **修改位 M (Modify Bit / Dirty Bit)**：一位，指示该段在调入内存后其内容是否被修改过。若M=1，则在置换该段时必须将其写回外存。
    *   **存在位 P (Presence Bit / Status Bit)**：一位，指示该段当前是否在内存中。P=1表示在内存，P=0表示不在内存（在外存）。若P=0且被访问，则产生缺段中断。
    *   **增补位 (Growth Bit / Expansion Bit)**：用于指示可动态增长的段（如栈段）的增长方向（向上或向下）或是否已发生增长，辅助内存管理。
    *   **外存始址 (External Storage Address / Disk Address)**：记录该段在外存（如磁盘）上的存放位置（例如，起始盘块号和块数或长度）。当段不在内存时，用于将其从外存调入。

24. **说明请求分段系统中的缺页中断处理过程。**
    *(题目原文为“缺页中断”，但上下文是请求分段系统，应为“缺段中断”处理过程)*
    请求分段系统中的**缺段中断**处理过程如下：
    1.  **产生缺段中断**：当CPU执行一条指令，试图访问一个逻辑地址时，地址变换机构通过查找段表，发现该地址所属段的段表项中**存在位P为0**，表明该段不在内存中。此时，硬件立即产生一个**缺段中断**信号。
    2.  **CPU响应与现场保护**：CPU响应中断，暂停当前指令的执行，并自动完成部分现场保护工作（如保存程序状态字PSW、程序计数器PC等），然后将控制权转交给操作系统内核的缺段中断处理例程。
    3.  **操作系统处理**：
        *   **进一步保护现场**：操作系统可能会保存更多当前进程的上下文信息。
        *   **分析中断原因**：确认是缺段中断。
        *   **查找段在外存位置**：根据该段的段表项中的“外存始址”信息，确定该段在磁盘上的具体位置和大小（段长）。
        *   **检查内存分配情况**：
            *   **寻找空闲区**：在内存中查找是否有足够大的连续空闲区域来容纳要调入的段（因为段是变长的，需要连续空间）。
            *   **若有足够空闲区**：则分配该空闲区。
            *   **若无足够大的单个空闲区，但总空闲量可能够**：操作系统可能尝试进行**内存紧缩 (Compaction)**，将已分配的段向一端移动，合并小的空闲区形成一个大的连续空闲区。此操作开销较大。
            *   **若内存不足（即使紧缩后也不够，或不进行紧缩）**：则必须执行**分段置换算法 (Segment Replacement Algorithm)**。选择一个或多个当前在内存中的段作为牺牲段将其换出。
                *   如果被选中的牺牲段的**修改位M为1**，则必须先将其内容写回到外存的相应位置。
                *   如果M为0，则无需写回。
                *   牺牲段所占用的内存空间被释放，用于调入新段。
        *   **调入所缺段**：启动磁盘I/O操作，将所缺的段从外存读入到分配好（或腾出）的内存区域。
        *   **更新段表**：在段成功调入内存后，修改该段在内存中的段表项：
            *   将**存在位P置为1**。
            *   填入该段在内存中的**起始物理地址（段基址）**。
            *   将**修改位M置为0**（因为是刚调入，尚未被修改）。
            *   将**访问位A通常置为1**。
        *   **恢复现场**：恢复被中断进程的CPU上下文。
        *   **重新执行指令**：将程序计数器PC指回到导致缺段中断的那条指令的起始处，**重新执行该指令**。此时，由于所需的段已在内存，指令可以正常执行。

25. **请对共享段表中的各项作简要说明。**
    共享段表 (Shared Segment Table) 是系统为管理被多个进程共享的分段而设置的一种数据结构。每个共享段在共享段表中通常对应一个表项，该表项包含以下信息：
    *   **第一部分：共享段自身的属性信息**
        *   **段名 (Segment Name) 或 共享段ID (Shared Segment ID)**：共享段在系统中的唯一标识。
        *   **段长 (Segment Length)**：该共享段的实际长度。
        *   **内存始址 (Memory Base Address)**：如果该共享段当前已调入内存，此字段记录其在主存中的起始物理地址。
        *   **状态位 (Status Bit / Presence Bit P)**：指示该共享段当前是否在内存中。P=1表示在内存，P=0表示不在。
        *   **外存始址 (External Storage Address)**：记录该共享段在外存（如磁盘）上的存放位置。
        *   **共享进程计数 (Share Count / Reference Count)**：一个整数，记录当前有多少个进程正在共享（即已连接到）此段。此计数器用于共享段的分配与回收管理。
    *   **第二部分：共享此段的进程列表信息 (通常是一个链表或数组，记录每个共享进程)**
        对于每个共享此段的进程，可能包含以下信息：
        *   **进程标识符 (Process ID)**：共享此段的进程的唯一ID。
        *   **在本进程中的段号 (Local Segment Number)**：该共享段在此特定进程的逻辑地址空间中所使用的段号。不同进程可以使用不同的本地段号来引用同一个共享段。
        *   **存取控制权限 (Access Control Rights)**：规定了此特定进程对该共享段所拥有的访问权限（例如，只读、读/写、只执行等）。这允许对同一共享段实现差异化的保护。
        *   **(可选) 其他状态信息**：如该进程是否已实际访问过此段等。
    共享段表使得操作系统能够有效地管理共享资源，确保数据一致性，并实现灵活的保护机制。

26. **如何实现共享分段的分配和回收？**
    *   **共享分段的分配**：
        1.  **进程请求共享段**：当一个进程首次请求访问一个（可能已存在的或新的）共享段时：
            *   **查找共享段表**：系统首先检查共享段表中是否已存在该共享段的记录。
            *   **若共享段已存在且在内存中**：
                *   在请求进程的段表中创建一个新的表项，将段基址指向共享段在内存中的物理地址。
                *   设置该进程对此共享段的访问权限（可能根据默认或请求指定）。
                *   在共享段表的对应表项中，将共享进程计数 `count` 加1。
                *   在共享段表的进程列表中，为该进程添加一条记录（包含进程ID、本地段号、访问权限）。
            *   **若共享段已存在但在外存中 (或共享段为首次创建且需要从外存调入)**：
                *   系统需要为该共享段在内存中分配一块足够大的连续空间（若内存不足，可能需要执行分段置换）。
                *   将共享段从外存调入分配的内存区域。
                *   更新共享段表中的内存始址和存在位P。
                *   然后执行与“共享段已存在且在内存中”类似的步骤：在请求进程段表建项，`count` 加1，在共享段表进程列表添加记录。
            *   **若共享段为首次创建 (且内容由进程提供或初始化)**：
                *   系统在内存中分配空间。
                *   在共享段表中创建新的表项，记录段属性，`count` 置1。
                *   在请求进程段表建项。
                *   在共享段表进程列表添加记录。
    *   **共享分段的回收**：
        1.  **进程释放共享段**：当一个进程结束或明确表示不再需要某个共享段时，它会通知操作系统。
        2.  **更新进程段表**：操作系统从该进程的段表中删除与该共享段对应的表项。
        3.  **更新共享段表**：
            *   在共享段表的对应表项中，将共享进程计数 `count` 减1。
            *   在共享段表的进程列表中，删除与该进程相关的记录。
        4.  **检查共享计数 `count`**：
            *   **如果 `count` 变为 0**：表明已没有其他进程在使用该共享段。此时，操作系统可以：
                *   回收该共享段所占用的物理内存空间。
                *   如果该段内容被修改过（修改位M=1），则在回收内存前可能需要将其写回外存（如果设计如此）。
                *   从共享段表中删除该共享段的整个表项。
            *   **如果 `count` 仍大于 0**：表明还有其他进程在继续使用该共享段。此时，操作系统不回收物理内存，该共享段继续保留在内存中（或按需调入调出），仅更新了 `count` 和进程列表。