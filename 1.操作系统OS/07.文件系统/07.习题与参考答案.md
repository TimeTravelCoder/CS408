
**习题参考答案与解析**

1.  **何谓数据项、记录和文件？**
    *   **数据项 (Data Item/Field)**：是数据组织中可以命名的最小逻辑数据单位，用于描述一个对象的某种属性。例如，学生的“学号”、“姓名”。
    *   **记录 (Record)**：是一组相关数据项的集合，用于描述一个对象在某方面的属性。例如，一个学生的完整信息（学号、姓名、年龄、班级）构成一个学生记录。
    *   **文件 (File)**：是由创建者所定义的、具有文件名的一组相关元素的集合。元素通常是记录（对于有结构文件）或字符流（对于无结构文件）。文件是文件系统中数据存储和管理的基本单位。
2.  **文件系统的模型可分为三层，试说明其每一层所包含的基本内容。**
    *   **最底层：对象及其属性层**：管理文件、目录、磁盘存储空间这些基本对象及其各自的属性（如文件名、类型、大小、物理位置、权限等）。
    *   **中间层：对对象操纵和管理的软件集合层**：这是文件系统的核心，包含实现文件系统功能的各种模块，如：
        *   文件存储空间管理
        *   文件目录管理
        *   文件逻辑地址到物理地址的转换
        *   文件读写管理
        *   文件共享与保护
    *   **最高层：文件系统提供给用户的接口层**：向用户和应用程序提供使用文件系统的便捷方式，通常包括：
        *   **命令接口**：用户通过命令行与文件系统交互（如`ls`, `cd`, `mkdir`）。
        *   **程序接口 (系统调用)**：应用程序通过系统调用来操作文件（如`open`, `read`, `write`, `close`）。
3.  **与文件系统有关的软件可分为哪几个层次？**
    *   **I/O 控制层 (设备驱动程序层)**：最低层，负责与具体硬件设备（如磁盘驱动器）交互，执行如读写物理块等操作。
    *   **基本文件系统层**：负责处理内存与磁盘之间数据块的交换，管理物理块。
    *   **基本 I/O 管理程序 (或文件组织模块)**：负责完成与磁盘 I/O 相关的事务，如将文件逻辑块号转换为物理块号，管理磁盘空闲块，I/O 缓冲区的指定等。
    *   **逻辑文件系统层**：负责处理与记录和文件相关的操作，如允许用户使用符号文件名访问文件及记录，实现对文件和记录的保护等，管理文件元数据（如FCB或inode）。
4.  **试说明用户可以对文件施加的主要操作有哪些。**
    *   **创建文件 (Create)**：建立一个新文件，分配存储空间，并在目录中创建条目。
    *   **删除文件 (Delete)**：从文件系统中移除文件，回收其占用的存储空间，并删除目录条目。
    *   **读文件 (Read)**：从文件中读取数据到内存。
    *   **写文件 (Write)**：将内存中的数据写入文件。
    *   **打开文件 (Open)**：在使用文件前，将其部分元数据调入内存，建立文件使用上下文，返回一个文件描述符或句柄。
    *   **关闭文件 (Close)**：结束对文件的使用，将缓冲区数据写回磁盘，释放相关内存资源。
    *   **设置读/写位置 (Seek/Lseek)**：改变文件当前的读写指针位置，用于随机访问。
    *   **修改文件属性 (Set Attributes)**：如修改文件名、访问权限、拥有者等。
    *   **获取文件属性 (Get Attributes)**：查询文件的属性信息。
5.  **为什么在大多数OS中都引入了“打开”这一文件系统调用？打开的含意是什么？**
    *   **引入原因**：
        *   **提高效率**：避免每次读写操作都从磁盘检索文件的元数据（如物理位置、权限等）。“打开”操作会将这些常用信息从外存拷贝到内存的“打开文件表”中，后续操作直接查表，速度更快。
        *   **建立连接/上下文**：在用户进程和指定文件之间建立一个逻辑连接，系统会维护这个连接的状态（如当前读写位置）。
        *   **权限检查**：在打开时进行一次性的权限检查，后续操作（在权限范围内）不再重复检查。
        *   **共享控制**：可以管理文件的共享模式（如独占、共享读等）。
    *   **打开的含意**：
        1.  系统根据用户提供的文件名查找目录，找到该文件的元数据（如FCB或inode）。
        2.  将该文件的属性（包括物理位置、访问权限等）从外存拷贝到内存的“打开文件表”中，并创建一个表目。
        3.  返回该表目的一个唯一标识（如文件描述符或索引号）给用户进程。
        4.  后续用户进程对该文件的操作都通过这个标识符进行，系统可以直接从打开文件表中获取信息，而无需再次检索目录。
        *   简而言之，“打开”就是在用户和指定文件之间建立起一个高效的访问通道。

6.  **何谓文件的逻辑结构？何谓文件的物理结构？**
    *   **文件的逻辑结构 (File Logical Structure / File Organization)**：是从用户观点出发所观察到的文件组织形式。它描述了文件是由一系列逻辑记录组成的，以及这些记录是如何组织的（如顺序、索引等）。它独立于文件的物理存储特性。
    *   **文件的物理结构 (File Physical Structure / Storage Structure)**：是指文件在外存（如磁盘）上是如何存储和组织的。它描述了文件数据块在磁盘上的分配方式（如连续分配、链接分配、索引分配）以及如何管理这些物理块。用户通常不可见。
7.  **按文件的组织方式可将文件分为哪几种类型？**
    *   **顺序文件 (Sequential File)**：记录按某种逻辑顺序（如关键字、时间）排列。
    *   **索引文件 (Indexed File)**：为文件中的记录建立一个或多个索引表，通过索引来快速定位记录。
    *   **索引顺序文件 (Indexed Sequential File)**：结合了顺序文件和索引文件的特点，记录按关键字顺序存放，同时为记录组建立索引。
    *   *(教材中可能还包括直接文件/哈希文件，但前三者是按组织方式分类的主要类型)*
8.  **如何提高对变长记录顺序文件的检索速度？**
    *   **建立索引**：为变长记录顺序文件建立索引表（如7.2.4节所述的索引文件或7.2.5节的索引顺序文件）。索引表本身是定长记录的，可以高效检索。通过索引快速定位到目标记录或记录组，再进行少量顺序查找。
    *   **哈希技术**：如果允许对关键字进行哈希转换直接得到地址或索引，也可以提高检索速度（如7.2.6节的哈希文件）。
    *   **对于特定场景的优化**：如果经常需要按某种非主关键字检索，可以建立辅助索引。
9.  **通过哪两种方式来对固定长记录实现随机访问？**
    *   **通过记录的逻辑位置（序号）**：如果记录是定长的 (长度为 L)，且从 0 开始编号，则第 `i` 条记录相对于文件首部的偏移地址为 `Aᵢ = i * L`。可以直接计算出地址进行访问。
    *   **通过关键字和索引/哈希**：如果文件按关键字组织，并且为这些关键字建立了索引表或哈希函数，可以通过关键字查索引/哈希表得到记录的地址或序号，然后再进行访问。
10. **可以采取什么方法来实现对变长记录文件进行随机检索？**
    *   **索引文件**：为变长记录文件建立索引表。索引表中的每个条目包含记录的关键字、指向记录的指针（逻辑地址）和记录的长度。通过检索索引表（通常是定长的，可以用二分查找等）来快速定位变长记录。
    *   **索引顺序文件**：将变长记录分组，为每组的第一个记录建立索引。先通过索引定位到组，再在组内顺序查找。
    *   **哈希文件**：如果可以为变长记录的关键字设计合适的哈希函数，将关键字映射到存储地址或索引表条目，也可以实现随机检索。
11. **试说明索引顺序文件的几个主要特征。**
    *   **记录按关键字顺序组织**：保留了顺序文件的基本特征，便于顺序处理。
    *   **引入文件索引表**：为记录组（不是每个记录）建立索引，通过索引表可以实现对文件的随机访问。
    *   **(通常) 具有溢出区/文件**：用于处理记录的插入和删除，避免大量移动主文件记录，保持主文件的有序性。
    *   **结合了顺序存取和随机存取的优点**：既能高效地进行批量顺序处理，也能较快地随机访问单个记录。
    *   **多级索引**：对于大文件，可以建立多级索引以进一步提高随机访问效率。
12. **试说明对索引文件和索引顺序文件的检索方法。**
    *   **索引文件 (Indexed File)**：
        1.  根据用户提供的关键字。
        2.  在（主）索引表中进行查找（通常是定长记录，可使用折半查找等高效算法），找到与关键字匹配的索引项。
        3.  从索引项中获取指向目标记录的指针（逻辑地址）。
        4.  通过该指针直接访问主文件中的目标记录。
        5.  如果存在多个索引表（按不同关键字），则选择相应的索引表进行检索。
    *   **索引顺序文件 (Indexed Sequential File)**：
        1.  根据用户提供的关键字。
        2.  首先在（最高级）索引表中查找，找到包含该关键字的记录组的索引项，获得指向下一级索引或主文件记录组的指针。
        3.  如果有多级索引，则逐级查找，直到定位到最低级索引，该索引项指向主文件中某个记录组的起始位置。
        4.  在主文件的该记录组内，从第一个记录开始进行顺序查找，直到找到与关键字匹配的目标记录。
        5.  (可能需要考虑溢出区的查找)。
13. **试从检索速度和存储费用两方面来比较两级索引文件和索引顺序文件。**
    *   **检索速度**：
        *   **两级索引文件 (指为每个记录都建立索引，且索引本身可能分级)**：通常随机检索速度更快。因为索引直接指向单个记录（或通过少量几级索引）。例如，如果索引完全装入内存，查找非常快。
        *   **索引顺序文件**：随机检索速度相对较慢。因为它需要先查索引定位到记录组，然后在组内进行顺序查找。组的大小会影响组内查找时间。
    *   **存储费用**：
        *   **两级索引文件**：存储费用通常更高。因为它需要为文件中的大部分（甚至所有）记录建立索引项。如果文件很大，索引本身也会很大。多级索引会进一步增加索引的存储开销。
        *   **索引顺序文件**：存储费用相对较低。因为它只为记录组的第一个记录建立索引项，索引表的规模远小于主文件。
    *   **总结**：
        *   如果对随机检索速度要求极高，且存储空间允许，**索引文件**可能更优。
        *   如果需要兼顾顺序处理效率和一定的随机访问能力，且希望控制存储开销，**索引顺序文件**是更好的选择。
14. **对目录管理的主要要求是什么？**
    *   **实现“按名存取”**：用户可以通过文件名方便地访问文件，无需关心文件的物理存储细节。这是最基本的要求。
    *   **提高对目录的检索速度**：快速找到指定文件的目录项，从而提高文件访问速度。
    *   **文件共享**：允许不同用户共享文件，并提供方便的共享机制。
    *   **允许文件重名**：在不同目录下允许使用相同的文件名，方便用户组织文件。
    *   **安全性**：保护目录信息不被非法访问和修改，控制用户对目录及目录内文件的访问权限。
    *   **灵活性和易用性**：提供方便的目录操作命令，易于用户理解和使用。
15. **采用单级目录能否满足对目录管理的主要要求？为什么？**
    *   **不能完全满足**。
    *   **能满足的要求**：可以实现最基本的“按名存取”。
    *   **不能满足或满足不好的要求**：
        *   **查找速度慢**：当文件数量很多时，在一个扁平的目录中查找文件效率低下（通常是线性查找）。
        *   **不允许文件重名**：在整个系统中，所有文件名必须唯一，这给用户命名带来极大不便，尤其在多用户环境下几乎不可行。
        *   **不便于实现文件共享**：难以区分不同用户的文件，共享和权限控制复杂。
        *   **安全性差**：所有文件都在一个目录中，难以实现细粒度的权限控制。
    *   **结论**：单级目录只适用于文件数量很少的单用户简单环境。
16. **目前广泛采用的目录结构形式是哪种？它有什么优点？**
    *   **树形结构目录 (Tree-Structured Directory)**。
    *   **优点**：
        *   **解决了文件名冲突问题**：不同目录下的文件可以同名，只要在同一目录下的文件名唯一即可。
        *   **提高了目录检索速度**：通过路径名逐级查找，可以将查找范围缩小到特定的子目录，比在整个系统中查找快得多。
        *   **便于文件分类和组织**：用户可以根据需要创建多层子目录，将文件按类别、项目等进行组织，结构清晰。
        *   **易于实现文件共享和保护**：可以为不同的目录（或子树）设置不同的访问权限，方便控制文件共享和保护。
        *   **灵活性高**：用户可以方便地创建、删除和移动目录。
17. **何谓路径名和当前目录？**
    *   **路径名 (Path Name)**：是在树形目录结构中，从指定的起始点（通常是根目录或当前目录）开始，到达目标文件或目录所经过的所有中间目录名，以及最后的目标文件或目录名，依次用路径分隔符（如 `/` 或 `\`）连接起来形成的字符串。
        *   **绝对路径名 (Absolute Path Name)**：从根目录开始的路径。
        *   **相对路径名 (Relative Path Name)**：从当前目录开始的路径。
    *   **当前目录 (Current Directory / Working Directory)**：是用户（或进程）当前正在工作的目录。当用户指定一个不以根目录起始的路径名（即相对路径名）时，系统会从当前目录开始查找。引入当前目录可以简化用户输入，避免每次都输入冗长的绝对路径。
18. **Hash 检索法有何优点？又有何局限性？**
    *   **优点**：
        *   **检索速度快**：在理想情况下（无冲突或冲突少且解决高效），哈希检索的平均时间复杂度接近 O(1)，远快于顺序查找或基于比较的树形结构查找。
        *   **实现相对简单**：基本的哈希表结构和哈希函数实现不复杂。
    *   **局限性**：
        *   **冲突问题**：不同的关键字可能通过哈希函数映射到同一个哈希地址，需要额外的机制来解决冲突（如开放定址法、链地址法），这会增加复杂性和降低性能。
        *   **空间利用率**：为了减少冲突，哈希表通常需要预留比实际数据量更大的空间，可能导致空间浪费。
        *   **不适合范围查询**：哈希表不保持关键字的顺序，因此不适合进行范围查找（如查找所有年龄在20-25岁的学生）。
        *   **对哈希函数依赖高**：哈希函数的选择对性能影响很大，一个不好的哈希函数会导致大量冲突。
        *   **不适合模糊匹配/模式匹配**：当文件名包含通配符（如 `*`, `?`）时，无法直接使用哈希法检索，仍需线性扫描或其它方法。
19. **在 Hash 检索法中，如何解决“冲突”问题？**
    *   （教材中对文件目录的哈希检索冲突处理描述较少，通常参考数据结构中的方法）
    *   **开放定址法 (Open Addressing)**：如果发生冲突，则按照某种探测序列（线性探测、二次探测、双重散列等）在哈希表中查找下一个可用的空槽位来存放冲突的元素。
    *   **链地址法 (Chaining / Separate Chaining)**：将所有哈希到同一地址的关键字（目录项）组织成一个链表。哈希表的每个槽位指向对应链表的头指针。
    *   **再哈希法 (Rehashing)**：发生冲突时，使用另一个或一系列哈希函数计算新的哈希地址，直到找到空槽位。
    *   **建立公共溢出区**：将所有冲突的记录都存放在一个公共的溢出区域。
    *   *在文件目录的上下文中，更常见的是如果哈希到的目录块已满，可能会链接到另一个溢出块，或者在目录块内采用某种形式的线性探测。*
    *   **课本中提到的处理** (P20, 第(3)点)：如果在目录表的相应目录项中的文件名与指定文件名并不匹配，则表示发生了“冲突”，此时须将其 Hash 值再加上一个常数（该常数应与目录的长度值互质），形成新的索引值，再返回到第一步重新开始查找。这是一种开放定址法的变体，类似于线性探测或某种自定义探测。
20. **试说明在树形目录结构中线性检索法的检索过程，并给出相应的流程图。**
    *   **检索过程** (假设给定路径名如 `/usr/ast/mbox`):
        1.  **分解路径名**：将路径名按分隔符分解成各个分量名 (usr, ast, mbox)。
        2.  **从根目录开始**：
            *   读取根目录文件到内存。
            *   在根目录中顺序查找第一个分量名 (usr)。
            *   如果找到，获取该分量名对应的目录文件的物理位置（如i-node号或起始盘块号）。
            *   如果未找到，则文件不存在，检索失败。
        3.  **逐级向下查找**：
            *   读取上一步找到的目录文件（如 usr 目录）到内存。
            *   在该目录中顺序查找下一个分量名 (ast)。
            *   如果找到，获取其对应的目录文件或目标文件的物理位置。
            *   如果未找到，则文件不存在，检索失败。
        4.  **重复步骤3**：直到路径名的所有分量都被处理完毕。
        5.  **定位目标文件/目录**：最后一个分量名 (mbox) 对应的就是目标文件或目录。获取其元数据（如FCB或i-node）信息。
    *   **流程图**：
    
    
[![|700x1057](https://mermaid.ink/img/pako:eNplkl1P01Acxr_KybkuTV9WaJugkY1XveiFV7RcNLZsTVi71DZRmyWYwF6isBEUjWIAETEmUk0IsE3ml9npyrfw9LTIwF6dl-f3_J-nOQF84hgmlKFmF129UgKPC5oN8PdARb9X0fGrJTA2dg9MBahRi48P4_MQ9ddQewMoYHDRBQpLAYWjAE3TeGFXU3aKMHkVXW6j5sbw4wm6fAsKYBJE-510t5QK80RYeOQ4lQCFnUF3MxvQqF3VW0CxMkOiwFoQvQ8JMq3GYQ-1du5MGH5YQ7V1dNLJ_KeJeEZFu9_w7eDix9VBF3Vb0d5R1Oxj-0w2Q6ybfdT4SYDZQLGSUakvar-7n-WYHc0w93-_BHtdR-0tHORW0bmboiNOqP2VwqneAGvSJoJ5NU2B2Wi_Hu3UB70zbEqBePM8abt-NvhzEL0MM9d5Aj1Uh73t6NPerTK730f6LKip1b9TCkSHq8PTz-jLr_j0KAMXUrc7fxxnvD6HFCy6lgHlZX3lqUnBsumW9WQPgwTSoFcyy6YGZbw0zGXdX_E0_K6qmKvo9qLjlKHsuT4mXccvlq43fsXQPbNg6fgB3ihM2zDdvOPbHpQlkThAOYDPoMyLPJ0bF0RRZHOsIDATAgWfQ5mTaEZiOVbiWG58gpcYrkrBF2QoQ4sswws8K0gSk8uJ1b8b-TQp?type=png)](https://mermaid-live.nodejs.cn/edit#pako:eNplkl1P01Acxr_KybkuTV9WaJugkY1XveiFV7RcNLZsTVi71DZRmyWYwF6isBEUjWIAETEmUk0IsE3ml9npyrfw9LTIwF6dl-f3_J-nOQF84hgmlKFmF129UgKPC5oN8PdARb9X0fGrJTA2dg9MBahRi48P4_MQ9ddQewMoYHDRBQpLAYWjAE3TeGFXU3aKMHkVXW6j5sbw4wm6fAsKYBJE-510t5QK80RYeOQ4lQCFnUF3MxvQqF3VW0CxMkOiwFoQvQ8JMq3GYQ-1du5MGH5YQ7V1dNLJ_KeJeEZFu9_w7eDix9VBF3Vb0d5R1Oxj-0w2Q6ybfdT4SYDZQLGSUakvar-7n-WYHc0w93-_BHtdR-0tHORW0bmboiNOqP2VwqneAGvSJoJ5NU2B2Wi_Hu3UB70zbEqBePM8abt-NvhzEL0MM9d5Aj1Uh73t6NPerTK730f6LKip1b9TCkSHq8PTz-jLr_j0KAMXUrc7fxxnvD6HFCy6lgHlZX3lqUnBsumW9WQPgwTSoFcyy6YGZbw0zGXdX_E0_K6qmKvo9qLjlKHsuT4mXccvlq43fsXQPbNg6fgB3ihM2zDdvOPbHpQlkThAOYDPoMyLPJ0bF0RRZHOsIDATAgWfQ5mTaEZiOVbiWG58gpcYrkrBF2QoQ4sswws8K0gSk8uJ1b8b-TQp)

21. **基于索引结点的文件共享方式有何优点？**
    *   **数据一致性**：所有共享用户都通过同一个索引结点访问文件数据和元数据。任何用户对文件的修改（内容、长度、属性等）都会反映在索引结点中，对所有其他共享用户立即可见，保证了共享数据的一致性。
    *   **节省存储空间**：文件实体只存储一份，避免了多个副本造成的空间浪费。
    *   **易于管理文件删除**：通过索引结点中的链接计数器 `count`，可以正确处理文件的删除。只有当 `count` 减为0时，才真正删除文件实体和索引结点，避免了悬空指针和过早删除共享文件的问题。
    *   **权限控制集中**：文件的访问权限信息存储在索引结点中，便于集中管理和控制。

22. **什么是主父目录和链接父目录？如何利用符号链实现共享？**
    *   **主父目录 (Primary Parent Directory / Owner Parent Directory)**：在利用符号链接实现共享时，一个文件或子目录在文件系统中实际“拥有”它的那个目录，它与文件/子目录之间通常是“实链接”（如通过索引结点）。
    *   **链接父目录 (Linked Parent Directory)**：其他希望共享该文件或子目录的目录。它通过创建一个符号链接文件来指向目标文件/子目录，这种链接是“符号”或“逻辑”上的。
    *   **如何利用符号链实现共享**：
        1.  当用户B想在其目录（链接父目录 D_B）中共享用户A的目录（主父目录 D_A）下的文件 F_target 时：
        2.  系统在 D_B 中创建一个特殊类型的文件，称为 **LINK 类型文件** (或符号链接文件)，其文件名通常与 F_target 相同（或者用户指定一个新名字）。
        3.  这个 LINK 类型文件的**内容**是目标文件 F_target 的**路径名** (例如 `/D_A/F_target`)。
        4.  当用户通过 D_B 访问这个 LINK 文件时，操作系统识别出其为符号链接。
        5.  操作系统读取 LINK 文件的内容（即目标路径名）。
        6.  然后操作系统根据这个路径名去查找并打开真正的目标文件 F_target。
        7.  后续的读写操作都作用于 F_target。

23. **基于符号链的文件共享方式有何优点？**
    *   **避免悬空指针**：当文件的拥有者（主父目录）删除原文件时，符号链接本身（包含路径名的那个小文件）仍然存在，但它指向的路径会失效。当其他用户试图通过该符号链接访问时，系统会报告“文件未找到”，而不会导致系统崩溃或指针错误。此时可以安全地删除这个失效的符号链接。
    *   **可以跨文件系统/设备**：符号链接的内容是路径名字符串，理论上可以指向位于不同文件系统甚至不同物理设备上的文件（如果操作系统支持这种解析）。硬链接通常限制在同一文件系统内。
    *   **可以链接到目录**：符号链接可以方便地创建指向目录的链接，而硬链接通常不允许指向目录（以避免循环和管理复杂性）。
    *   **对文件所有权清晰**：文件的属主关系依然是树形的（通过主父目录），结构简单，便于管理。

24. **什么是保护域？进程与保护域之间存在着的动态联系是什么？**
    *   **保护域 (Protection Domain)**：是一个进程对一组对象所拥有的访问权的集合。它定义了进程能够访问哪些资源以及能对这些资源执行哪些操作。
    *   **进程与保护域之间的动态联系**：是指一个进程在其生命周期中，不是固定地与某一个保护域相关联，而是可以根据其运行的不同阶段或需求，从一个保护域**切换 (Switch)** 到另一个保护域。每个保护域定义了该阶段进程所需的最小权限集。这种动态联系允许更细粒度地控制进程的权限，提高系统的安全性（符合最小权限原则）。

25. **试举例说明具有域切换权的访问控制矩阵。**
    *   假设有三个域 D₁, D₂, D₃，和一些对象 F₁ (文件), P₁ (打印机)。
    *   访问控制矩阵如下 (S 表示 Switch 切换权)：

| **对象/域** | **F₁** | **P₁** | **D₁** | **D₂** | **D₃** |
| -------- | ------ | ------ | ------ | ------ | ------ |
| **D₁**   | R, W   |        |        | S      |        |
| **D₂**   | R      | W      |        |        | S      |
| **D₃**   |        | W      | S      |        |        |

   **说明**：
*   在域 D₁ 中运行的进程可以读写 F₁，并且可以**切换到域 D₂**。
*   在域 D₂ 中运行的进程可以读 F₁，可以写 P₁，并且可以**切换到域 D₃**。
*   在域 D₃ 中运行的进程可以写 P₁，并且可以**切换到域 D₁**。
*   这个例子展示了域之间的切换路径，例如一个进程可以从 D₁ -> D₂ -> D₃ -> D₁ 循环切换。

26. **如何利用拷贝权来扩散某种访问权？**
    *   当访问矩阵中的某个条目 `Access(i, j)` (域 Dᵢ 对对象 Oⱼ 的访问权) 包含**拷贝权** (通常用 `*` 标记，如 `R*`, `W*`) 时，在域 Dᵢ 中运行的进程可以将这个带星号的访问权复制给同一列的另一个域 Dₖ。
    *   即，如果 `R* ∈ Access(Dᵢ, Oⱼ)`，则域 Dᵢ 中的进程可以将对 Oⱼ 的读权限赋予域 Dₖ，使得 `R ∈ Access(Dₖ, Oⱼ)`。
    *   **限制拷贝**：通常，被拷贝过去的权限是不带星号的（即普通的R），这意味着域 Dₖ 不能再将这个权限进一步拷贝给其他域，从而控制了权限的扩散范围。
    *   **例子**：
        初始：`Access(D₁, FileX) = {R*, W}`
        操作：D₁ 中的进程将对 FileX 的 `R*` 权限拷贝给 D₂。
        结果：`Access(D₂, FileX)` 中增加了 `R` 权限。

27. **如何利用拥有权来增、删某种访问权？**
    *   当访问矩阵中的某个条目 `Access(i, j)` (域 Dᵢ 对对象 Oⱼ 的访问权) 包含**拥有权** (通常用 `Owner` 或 `O` 标记) 时，在域 Dᵢ 中运行的进程（即 Oⱼ 的拥有者）可以修改对象 Oⱼ 这一列中**任何其他域** Dₖ 对 Oⱼ 的访问权。
    *   即，如果 `Owner ∈ Access(Dᵢ, Oⱼ)`，则域 Dᵢ 中的进程可以：
        *   **增加**：在 `Access(Dₖ, Oⱼ)` 中添加新的访问权（如 `R`, `W`）。
        *   **删除**：从 `Access(Dₖ, Oⱼ)` 中移除已有的访问权。
    *   **例子**：
        初始：`Access(UserA, FileY) = {Owner, R, W}`, `Access(UserB, FileY) = {R}`
        操作：UserA (FileY的拥有者) 决定撤销 UserB 对 FileY 的读权限，并赋予其写权限。
        结果：`Access(UserB, FileY) = {W}`。

28. **增加控制权的主要目的是什么？试举例说明控制权的应用。**
    *   **主要目的**：允许一个域（控制域）去修改另一个域（被控制域）**对所有不同对象的访问权**。即控制权是针对“行”的操作，可以改变被控制域所拥有的整个权限集合。
    *   **与拥有权的区别**：拥有权是针对某个特定“对象列”的权限修改；控制权是针对某个特定“域行”的权限修改。
    *   **举例说明控制权的应用**：
        *   假设域 `Admin` 拥有对域 `Guest` 的**控制权**。
        *   `Access(Admin, Guest) = {Control}`
        *   此时，在 `Admin` 域中运行的进程可以：
            *   撤销 `Guest` 域对文件 `F_secret` 的所有访问权。
            *   赋予 `Guest` 域对打印机 `P_public` 的使用权。
            *   修改 `Guest` 域对任何其他对象的访问权限。
        *   这种机制常用于系统管理员管理普通用户或进程组的整体权限。

29. **什么是访问控制表？什么是访问权限表？**
    *   **访问控制表 (Access Control List - ACL)**：
        *   是对访问矩阵按**列（对象）**进行划分和优化的结果。
        *   为**每一个对象**维护一个列表，该列表记录了所有可以访问该对象的**域（或用户/组）**以及它们各自拥有的**权限集**。
        *   例如，文件 F 的 ACL 可能包含：`(UserA, {R,W}), (UserB, {R}), (GroupX, {R})`。
        *   优点：直观地表示了“谁能对这个对象做什么”。
    *   **访问权限表 (Capability List / C-List)**：
        *   是对访问矩阵按**行（域）**进行划分和优化的结果。
        *   为**每一个域**维护一个列表，该列表记录了该域可以访问的所有**对象**以及对每个对象拥有的**权限集**。
        *   每个条目（Capability）通常表示为 `(对象标识, 权限集)`。
        *   例如，域 D 的 C-List 可能包含：`(FileX, {R,W}), (PrinterY, {Print})`。
        *   优点：当进程（在某域中）要访问对象时，只需检查其 C-List，速度较快。Capability本身可以作为一种“令牌”或“钥匙”。

30. **系统如何利用访问控制表和访问权限表来实现对文件的保护？**
    *   **利用访问控制表 (ACL) 实现保护**：
        1.  当一个进程（代表某个用户或属于某个域）尝试对一个文件进行某种操作（如读、写）时。
        2.  系统会找到该文件的 ACL。
        3.  在 ACL 中查找是否存在与该进程相关的条目（如用户名、用户组、进程所属域）。
        4.  如果找到匹配条目，则检查该条目中的权限集是否包含进程请求的操作。
            *   如果包含，则允许操作。
            *   如果不包含，则拒绝操作。
        5.  如果未找到匹配条目，则通常根据预设的默认权限（如“其他用户”的权限）或直接拒绝访问。
    *   **利用访问权限表 (C-List) 实现保护**：
        1.  当一个进程（在其当前域中）被创建或切换到一个新的域时，系统会为其加载或生成相应的 C-List。
        2.  当该进程尝试对一个文件进行操作时，它会“出示”其 C-List 中与该文件对应的 Capability（权限）。
        3.  系统验证该 Capability 的合法性（例如，Capability 是否被篡改，是否真的属于该进程/域）。
        4.  如果 Capability 有效且包含所请求的操作权限，则允许操作。
        5.  如果 Capability 无效或不包含所需权限，则拒绝操作。
    *   **结合使用**：
        *   许多系统结合使用两者。例如，当进程首次请求访问文件时，系统通过检查文件的 ACL 来验证权限。
        *   如果验证通过，系统会为该进程（或其域）创建一个临时的 Capability，并将其添加到进程的 C-List 中。
        *   后续对该文件的访问，进程可以直接使用这个 Capability 进行快速验证，而无需每次都重新检查 ACL。
        *   这种方式兼顾了 ACL 的灵活性（易于修改权限）和 C-List 的高效性（快速验证）。

