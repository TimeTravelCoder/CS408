
---

**1. 目前常用的外存有哪几种组织方式？**

*   **答：** 目前常用的外存组织方式主要有三种：
    1.  **连续组织方式 (Continuous Organization):** 文件数据存储在连续的磁盘块中。
    2.  **链接组织方式 (Linked Organization):** 文件数据存储在不连续的磁盘块中，通过指针将这些块链接起来。
    3.  **索引组织方式 (Indexed Organization):** 文件数据存储在不连续的磁盘块中，通过一个或多个索引块来记录和定位数据块。

**2. 由连续组织方式所形成的顺序文件的主要优缺点是什么？它主要应用于何种场合？**

*   **答：**
    *   **主要优点：**
        1.  **顺序访问速度快：** 由于盘块连续，磁头移动少，读写效率高。
        2.  **支持随机访问（对定长记录）：** 可以通过计算直接定位到记录所在的盘块和块内偏移。
        3.  实现简单。
    *   **主要缺点：**
        1.  **产生外部碎片：** 磁盘空间会因文件的创建和删除而变得零散。
        2.  **必须事先知道文件长度：** 分配空间时需要确定文件大小，估计不准会导致空间浪费或不足。
        3.  **文件不易扩展：** 增加文件内容时，如果后面没有连续空间则难以扩展。
        4.  **插入和删除记录困难：** 为保持连续性，可能需要移动大量数据。
    *   **主要应用场合：**
        1.  **对换区 (Swapping Area) 的管理：** 要求高速存取。
        2.  **系统文件或不经常修改的文件：** 如操作系统内核、库文件等。
        3.  **顺序访问为主的文件：** 如日志文件、磁带模拟。
        4.  **对访问速度要求极高的实时文件或多媒体文件中的部分片段。**

**3. 在链接式文件中常用哪种链接方式？为什么？**

*   **答：** 在链接式文件中，更常用的链接方式是**显式链接 (Explicit Linking)**，即使用**文件分配表 (File Allocation Table - FAT)**。
    *   **原因：**
        1.  **提高了检索效率：** 隐式链接在查找文件的第 `i` 个盘块时，需要从头开始顺序读取 `i-1` 个盘块以获取指针，磁盘I/O次数多，效率低下。而显式链接将所有链接指针集中存放在内存中的FAT表中，查找过程主要在内存中进行，速度快得多，大大减少了磁盘访问次数。
        2.  **更利于随机访问：** 虽然链接文件本质上不利于随机访问，但通过FAT表在内存中查找目标盘块号比隐式链接逐个读盘块要快得多。
        3.  **管理更方便：** FAT表提供了整个磁盘空间分配情况的视图，便于进行空间管理和错误检测。

**4. 在文件分配表中为什么要引入“簇”的概念？以“簇”为基本的分配单位有什么好处？**

*   **答：**
    *   **引入“簇”的原因：**
        1.  **解决FAT表项数量限制问题：** 早期的FAT系统（如FAT12）表项数量有限，当磁盘容量增大时，如果仍以单个盘块为分配单位，则可管理的磁盘总容量会受到FAT表大小的限制。
        2.  **减少FAT表的大小（在一定程度上）：** 对于给定的磁盘容量，如果分配单位变大（一个簇包含多个盘块），那么所需的FAT表项数量就会减少，从而可能减小FAT表本身占用的存储空间或内存空间。
        3.  **提高文件读写效率：** 当以簇为单位分配时，一次I/O操作可能读取或写入多个连续的盘块（一个簇内的盘块），减少了I/O启动次数，提高了大块数据传输的效率。
    *   **以“簇”为基本的分配单位的好处：**
        1.  **支持更大的磁盘分区：** 通过使用簇，即使FAT表项数量有限，也能管理更大的磁盘容量，因为每个表项代表的是一个簇而不是单个盘块。
        2.  **减少文件分配表的项数：** 在相同的磁盘容量下，如果簇较大，FAT表的项数会相应减少，这在FAT表需要全部加载到内存时可以节省内存空间，并可能加快FAT表的扫描速度。
        3.  **提高文件访问速度（特别是顺序访问）：** 由于一个簇内的盘块是连续的，当文件按簇分配时，可以一次性读取或写入一个簇的数据，减少了磁盘寻道和旋转延迟的次数。

**5. 简要说明为什么要从FAT12发展为FAT16？又进一步要发展为FAT32？**

*   **答：**
    *   **从FAT12发展为FAT16的原因：**
        1.  **FAT12管理磁盘容量的限制：** FAT12使用12位地址表示簇号，最多只能管理 2^12 ≈ 4096 个簇。即使使用较大的簇，其能管理的最大磁盘分区容量也非常有限（例如，对于32KB的簇，最大分区约为128MB），无法满足日益增长的硬盘容量需求。
        2.  **FAT16的改进：** FAT16使用16位地址表示簇号，最多可以管理 2^16 = 65536 个簇。这使得FAT16能够支持更大的磁盘分区（例如，对于32KB的簇，最大分区可达2GB）。
    *   **从FAT16进一步发展为FAT32的原因：**
        1.  **FAT16对大容量硬盘的簇大小问题：** 虽然FAT16支持了更大的分区，但随着硬盘容量继续增大（超过2GB），为了在65536个簇的限制内管理这些大分区，FAT16被迫使用非常大的簇（例如，对于大于2GB的分区，簇大小可能达到32KB甚至64KB）。这导致了严重的**簇内零头（内部碎片）**问题，即文件末尾未占满整个簇的空间被浪费，造成磁盘空间利用率低下。
        2.  **FAT32的改进：**
            *   FAT32使用（有效）28位地址表示簇号，可以管理数量巨大的簇 (2^28)。
            *   这使得FAT32即使在非常大的磁盘分区（可达2TB）上，也可以使用相对较小的簇（例如，常用的4KB、8KB），从而显著**减少了内部碎片**，提高了磁盘空间的利用率。
            *   FAT32还引入了对**长文件名**的支持（通过VFAT扩展）。
            *   取消了根目录中文件/目录数量的限制。

**6. 试解释逻辑簇号和虚拟簇号这两个名词，NTFS是如何将它们映射到文件的物理地址上的？**

*   **答：**
    *   **逻辑簇号 (LCN - Logical Cluster Number):**
        *   LCN是以**卷 (Volume) 或分区**为单位，对该卷中所有簇从头到尾进行的连续、唯一的编号。它代表了簇在整个卷上的物理或逻辑顺序位置。
    *   **虚拟簇号 (VCN - Virtual Cluster Number):**
        *   VCN是以**单个文件**为单位，对属于该文件的所有簇从0开始进行的逻辑编号。它表示一个簇在文件内部的相对顺序。例如，文件的第一个簇其VCN为0，第二个簇其VCN为1，依此类推。
    *   **NTFS的映射过程：**
        NTFS通过**主控文件表 (MFT - Master File Table)** 中的文件记录（元数据）以及其中包含的**属性**（特别是 `$DATA` 属性）来进行VCN到LCN的映射。
        1.  当访问文件中的某个数据时，首先确定该数据所在的**VCN**。
        2.  然后，操作系统查找该文件在MFT中的记录。
        3.  在文件记录中，找到描述文件数据存储位置的 `$DATA` 属性。
        4.  `$DATA` 属性中包含了一系列的**区段 (Run/Extent)** 信息。每个区段描述了文件数据在磁盘上的一段连续存储区域。一个区段通常由三部分组成：
            *   **起始VCN (Starting VCN):** 该区段在文件内部的起始虚拟簇号。
            *   **起始LCN (Starting LCN):** 该区段在磁盘卷上的起始逻辑簇号。
            *   **簇数量 (Number of Clusters):** 该区段包含的连续簇的个数。
        5.  通过遍历这些区段信息，系统可以找到包含目标VCN的那个区段。
        6.  一旦找到对应的区段，就可以根据该区段的起始VCN、起始LCN以及目标VCN与起始VCN的差值，计算出目标VCN对应的**LCN**。
            *   `目标LCN = 区段的起始LCN + (目标VCN - 区段的起始VCN)`
        7.  得到LCN后，乘以**卷因子 (簇的大小)**，就可以得到该簇在磁盘上的物理字节偏移量，从而定位到文件的物理地址。
        *   对于非常小的文件（常驻文件），其数据可能直接存储在MFT记录的 `$DATA` 属性内，此时不需要VCN到LCN的映射，直接从MFT读取。

**7. 在MS-DOS中有两个文件A和B，A占用11、12、16和14四个盘块；B占用13、18和20三个盘块。试画出在文件A和B中各盘块间的链接情况及FAT的情况。**

*   **答：**
    假设这是在一个简化的FAT系统中，并且这些盘块号就是FAT表中的索引（也即簇号）。
    *   **文件A的链接情况：** 11 -> 12 -> 16 -> 14 -> EOF (End Of File)
    *   **文件B的链接情况：** 13 -> 18 -> 20 -> EOF

    *   **FAT表相关条目示意：** (EOF用-1表示)
        ```
        FAT Index | Value (Next Cluster) | Comment
        --------------------------------------------------
        ...       | ...                  |
        11        | 12                   | A的第一个块指向12
        12        | 16                   | A的第二个块指向16
        13        | 18                   | B的第一个块指向18
        14        | -1                   | A的最后一个块，EOF
        15        | 0 (or other)         | (假设15是空闲的或被其他文件占用)
        16        | 14                   | A的第三个块指向14
        17        | 0 (or other)         | (假设17是空闲的)
        18        | 20                   | B的第二个块指向20
        19        | 0 (or other)         | (假设19是空闲的)
        20        | -1                   | B的最后一个块，EOF
        ...       | ...                  |
        ```
    *   **目录项示意：**
        *   文件A的目录项会记录其起始盘块（簇）号为 **11**。
        *   文件B的目录项会记录其起始盘块（簇）号为 **13**。

    *   **图示：** (这里用文字描述图形)
        可以画两个链表：
        *   链表A：$[盘块11 (指针->12)] -> [盘块12 (指针->16)] -> [盘块16 (指针->14)] -> [盘块14 (指针->EOF)]$
        *   $链表B：[盘块13 (指针->18)] -> [盘块18 (指针->20)] -> [盘块20 (指针->EOF)]$
        同时画一个FAT表的片段，标出上述索引11, 12, 13, 14, 16, 18, 20对应的值。

**8. NTFS文件系统中的文件所采用的是什么样的物理结构？**

*   **答：** NTFS文件系统中的文件物理结构是一种基于**区段 (Extents/Runs) 的索引组织方式**，并结合了**属性 (Attributes)** 的概念。
    *   **核心是MFT (Master File Table)：** 每个文件（和目录）在MFT中都有一个记录（通常1KB）。
    *   **属性流：** 文件的所有信息，包括文件名、时间戳、安全描述符以及**数据内容本身**，都作为文件的属性存储。
    *   **数据存储 (`$DATA` 属性)：**
        *   **对于非常小的文件 (Resident files)：** 文件的数据可以直接存储在MFT记录的 `$DATA` 属性内部。这种情况下，文件数据是连续存储在MFT记录中的。
        *   **对于较大的文件 (Non-resident files)：** `$DATA` 属性会包含一个或多个**区段列表 (Run list)**。每个区段描述了文件数据在磁盘上的一段**连续的簇的集合**。一个区段由 (起始VCN, 起始LCN, 簇数量) 定义。文件的数据就分布在这些区段所指向的磁盘簇中。
    *   因此，NTFS文件的物理结构可以看作是：
        *   **逻辑上是基于属性的。**
        *   **物理上是基于区段的索引分配。** 文件数据存储在一个或多个连续的磁盘簇块（区段）中，这些区段的位置信息被索引在MFT的文件记录中。
        *   它既有连续分配的特点（每个区段内部是连续的），又有索引分配的特点（通过MFT记录索引这些区段）。

**9. 假定一个文件系统的组织方式与MS-DOS相似，在FAT中可有64K个指针，磁盘的盘块大小为512B，试问该文件系统能否指引一个512MB的磁盘？**

*   **答：**
    *   FAT中有64K个指针，这意味着该FAT系统最多可以管理 64K = 65536 个分配单元（簇）。
    *   每个盘块大小为 512B。
    *   **关键在于一个分配单元（簇）包含多少个盘块。**
    *   **情况1：如果一个簇只包含一个盘块 (簇大小 = 512B)：**
        *   最大可管理的磁盘容量 = 65536 个簇 * 512 B/簇 = 33,554,432 B = 32 MB。
        *   这种情况下，不能指引一个512MB的磁盘。
    *   **情况2：如果簇可以包含多个盘块：**
        *   要指引512MB的磁盘，需要的簇大小为：
            *   512 MB = 512 * 1024 * 1024 B = 536,870,912 B
            *   每个簇的大小 = 536,870,912 B / 65536 个簇 ≈ 8192 B = 8 KB。
        *   如果系统允许一个簇的大小达到或超过8KB（即每个簇包含 8KB / 512B/盘块 = 16个盘块），那么该文件系统**可以**指引一个512MB的磁盘。
    *   **结论：** 该文件系统**能否**指引512MB的磁盘，**取决于其允许的簇的最大大小**。如果簇大小可以设置得足够大（至少8KB），则可以。如果簇大小固定为512B或较小的值，则不能。
        *   （通常，一个拥有64K指针的FAT系统指的是FAT16，FAT16确实可以通过调整簇大小来支持最大2GB的分区，所以理论上通过设置足够大的簇是可以支持512MB的。）

**10. 为了快速访问，又易于更新，当数据为以下形式时，应选用何种文件组织方式？**
    **(1) 不经常更新，经常随机访问；**
    **(2) 经常更新，经常按一定顺序访问；**
    **(3) 经常更新，经常随机访问。**

*   **答：**
    *   **(1) 不经常更新，经常随机访问：**
        *   **首选：连续组织方式。** 如果文件不经常更新（大小固定），连续存储能提供最快的随机访问速度（通过直接地址计算）。
        *   **次选：索引组织方式（特别是单级或少量间接级的）。** 也能提供较好的随机访问性能，且比链接方式好。
    *   **(2) 经常更新，经常按一定顺序访问：**
        *   **首选：链接组织方式（特别是使用FAT的显式链接）。** 易于更新（插入、删除、扩展），顺序访问通过FAT表在内存中查找下一块，效率尚可。
        *   如果“经常更新”指的是记录内容的修改而不是文件结构的频繁变动，且对顺序访问速度要求很高，那么在某些情况下（如数据库），也可能使用基于索引的顺序文件（如ISAM的变种），但教材中讨论的文件组织方式里，链接组织更直接匹配。
    *   **(3) 经常更新，经常随机访问：**
        *   **首选：索引组织方式（如多级索引、B+树索引等更高级的索引结构）。** 这是最适合这种需求的组织方式。索引结构能够高效地支持随机访问，同时其非连续存储的特性也使得文件的更新（插入、删除、扩展）相对容易，不像连续文件那样需要大量移动数据。
        *   **NTFS的组织方式**（基于区段的索引）也适合这种场景。

**11. 在UNIX中，如果一个盘块的大小为1KB，每个盘块号占4个字节，即每块可放256个地址。请转换下列文件的字节偏移量为物理地址：**
    **(1) 9999; (2) 18000; (3) 420000。**

*   **答：**
    *   盘块大小 = 1KB = 1024 字节。
    *   UNIX i-node 结构（假设是教材中描述的10个直接块，1个一次间接，1个二次间接，1个三次间接）。
    *   每个盘块可存 1024字节 / 4字节/地址 = 256 个地址。

    *   **直接地址块覆盖的字节范围：**
        *   10个直接块 * 1024 字节/块 = 10240 字节 (偏移量 0 到 10239)。

    *   **一次间接地址块覆盖的字节范围：**
        *   一个一次间接块指向 256 个数据块。
        *   覆盖字节数 = 256 个数据块 * 1024 字节/块 = 262144 字节。
        *   覆盖的偏移量范围：10240 到 10240 + 262144 - 1 = 10240 到 272383。

    *   **二次间接地址块覆盖的字节范围：**
        *   一个二次间接块指向 256 个一次间接块。
        *   每个一次间接块指向 256 个数据块。
        *   覆盖字节数 = 256 * 256 * 1024 字节 = 67,108,864 字节。
        *   覆盖的偏移量范围：272384 到 272384 + 67108864 - 1 = 272384 到 67381247。

    *   **(1) 字节偏移量 9999：**
        *   9999 < 10240。所以它在**直接地址块**中。
        *   逻辑块号 (在文件内) = 9999 DIV 1024 = 9 (第10个直接块，因为从0开始计数是块9)。
        *   块内偏移量 = 9999 MOD 1024 = 783。
        *   物理地址：i-node中 `i.addr[9]` 指向的盘块的物理地址 + 783 字节。

    *   **(2) 字节偏移量 18000：**
        *   10240 <= 18000 <= 272383。所以它在**一次间接地址块**指向的数据块中。
        *   相对于一次间接块起始的偏移量 = 18000 - 10240 = 7760。
        *   在一次间接块中的地址项索引 = 7760 DIV 1024 = 7 (第8个地址项)。
        *   块内偏移量 = 7760 MOD 1024 = 592。
        *   物理地址：
            1.  从 `i.addr[10]` 获取一次间接块的物理盘块号。
            2.  读取该一次间接块。
            3.  从该间接块的第7个地址项（索引从0开始）获取数据块的物理盘块号。
            4.  该数据块的物理地址 + 592 字节。

    *   **(3) 字节偏移量 420000：**
        *   272384 <= 420000 <= 67381247。所以它在**二次间接地址块**指向的数据块中。
        *   相对于二次间接块起始的偏移量 = 420000 - 272384 = 147616。
        *   在二次间接块中的地址项索引 (指向一次间接块) = 147616 DIV (256 * 1024) = 147616 DIV 262144 = 0 (第1个地址项)。
        *   相对于这个被指向的一次间接块起始的偏移量 = 147616 MOD 262144 = 147616。
        *   在这个一次间接块中的地址项索引 (指向数据块) = 147616 DIV 1024 = 144 (第145个地址项)。
        *   块内偏移量 = 147616 MOD 1024 = 160。
        *   物理地址：
            1.  从 `i.addr[11]` 获取二次间接块的物理盘块号。
            2.  读取该二次间接块。
            3.  从该二次间接块的第0个地址项获取一次间接块的物理盘块号。
            4.  读取这个一次间接块。
            5.  从这个一次间接块的第144个地址项获取数据块的物理盘块号。
            6.  该数据块的物理地址 + 160 字节。

**12. 什么是索引文件？为什么要引入多级索引？**

*   **答：**
    *   **索引文件：** 是一种文件组织方式，它为每个文件建立一个或多个**索引块 (Index Block)**。索引块中不存放文件数据本身，而是存放指向文件数据实际存储的**物理盘块的地址（盘块号）的列表**。当需要访问文件数据时，首先访问索引块，通过索引块找到对应数据块的地址，然后再去访问数据块。
    *   **为什么要引入多级索引：**
        1.  **单个索引块容量限制：** 一个物理盘块的大小是有限的。如果一个文件非常大，它所占用的数据盘块数量可能非常多，导致所有这些数据盘块的地址无法全部存放在一个单独的索引块中。
        2.  **解决单级索引的扩展性问题：** 如果单级索引块满了，一种简单的做法是将多个索引块链接起来，但这会降低查找效率，类似于链接文件的缺点。
        3.  **多级索引的解决方案：** 当一个索引块不足以存放所有数据块地址时，可以引入更高一级的索引。例如：
            *   **二级索引：** 创建一个**一级索引块**，这个一级索引块中存放的不再是数据块的地址，而是**二级索引块的地址**。每个二级索引块再存放实际数据块的地址。
            *   **三级或更高级索引：** 依此类推，可以构建三级甚至更高级别的索引结构。
        4.  **优点：**
            *   **大大扩展了可管理的文件大小：** 每一级索引都将可寻址的数据块数量成倍增加（通常是索引块中可存放地址的个数倍）。
            *   **保持了较好的随机访问性能：** 虽然访问数据块需要经过多次间接寻址（读取多个索引块），但对于非常大的文件，这仍然比链接方式的顺序查找要快得多。

**13. 试说明增量式索引组织方式。**

*   **答：** 增量式索引组织方式，也常被称为**混合索引组织方式**，是一种结合了**直接地址、单级间接地址和多级间接地址**来定位文件数据块的策略。其设计目标是为了高效地支持不同大小文件的访问。UNIX/Linux系统中的 **i-node (索引节点)** 就是这种方式的典型实现。
    *   **基本思想：**
        1.  **对小文件使用直接地址：** i-node中直接包含若干个指针（例如10-12个），这些指针直接指向文件数据的前几个物理盘块。对于小文件，所有数据块的地址都可以直接从i-node中获得，访问速度非常快，只需一次磁盘读（读取i-node）和一次数据块读。
        2.  **对中型文件增加一次间接地址：** 当文件稍大，直接地址指针用完后，i-node中会有一个指针指向一个**一次间接块 (Single Indirect Block)**。这个一次间接块本身是一个索引块，里面存放了更多数据块的地址。访问这些数据块需要两次间接寻址（读i-node -> 读一次间接块 -> 读数据块）。
        3.  **对大型文件增加二次间接地址：** 如果文件更大，一次间接块也存不下所有地址，i-node中会有一个指针指向一个**二次间接块 (Double Indirect Block)**。这个二次间接块中存放的是一批一次间接块的地址。访问这些数据块需要三次间接寻址。
        4.  **对特大型文件增加三次间接地址：** 对于极大的文件，还可能有一个指针指向一个**三次间接块 (Triple Indirect Block)**，进行四次间接寻址。
    *   **优点：**
        *   **对小文件友好：** 大多数文件都是小文件，直接地址使得小文件访问非常高效。
        *   **支持极大文件：** 通过多级间接地址，可以支持非常大的文件（TB甚至PB级别，取决于盘块大小和指针大小）。
        *   **空间利用率较高：** 只有当文件确实需要更多地址空间时，才会分配间接索引块，避免了为小文件也分配固定大小的、可能利用率很低的索引块。
        *   **平滑过渡：** 从小文件到大文件，地址空间的扩展是平滑的。

**14. 有一计算机系统利用图8-19所示的位示图来管理空闲盘块。盘块的大小为1KB，现要为某文件分配两个盘块，试说明盘块的具体分配过程。**

*   **答：** (图8-19在题目中未给出，这里假设一个通用的位示图和分配过程)
    假设位示图 `map[m, n]`，其中 "0" 表示空闲，"1" 表示已分配。盘块大小1KB。
    **分配过程如下：**
    1.  **确定分配策略：** 操作系统需要决定是分配任意两个空闲盘块，还是尽量分配两个**连续的**空闲盘块。为了提高文件顺序访问性能，通常会优先尝试分配连续盘块。
    2.  **扫描位示图查找空闲盘块：**
        *   **如果要分配连续盘块：**
            *   系统从位示图的起始位置（或上一次分配结束的位置）开始，逐行逐位扫描。
            *   查找连续两个值为 "0" 的位。
            *   假设在第 `i` 行、第 `j` 列和第 `j+1` 列找到了连续的两个 "0"。
        *   **如果允许分配不连续盘块（或者找不到连续的）：**
            *   系统扫描位示图，找到第一个值为 "0" 的位。假设在第 `i1` 行、第 `j1` 列。
            *   继续扫描，找到下一个值为 "0" 的位。假设在第 `i2` 行、第 `j2` 列。
    3.  **将位示图位置转换为物理盘块号：**
        *   使用公式 `b = n * (row - 1) + col` (假设行列从1开始，n为每行位数) 来转换。
        *   对于连续情况：
            *   第一个盘块号 `b1 = n * (i - 1) + j`
            *   第二个盘块号 `b2 = n * (i - 1) + (j + 1)`
        *   对于不连续情况：
            *   第一个盘块号 `b1 = n * (i1 - 1) + j1`
            *   第二个盘块号 `b2 = n * (i2 - 1) + j2`
    4.  **修改位示图：**
        *   将分配出去的盘块在位示图中对应的位从 "0" 修改为 "1"。
        *   对于连续情况：`map[i, j] = 1` 和 `map[i, j+1] = 1`。
        *   对于不连续情况：`map[i1, j1] = 1` 和 `map[i2, j2] = 1`。
    5.  **记录分配结果：**
        *   将分配得到的盘块号 `b1` 和 `b2` 记录到文件的文件控制块 (FCB) 或相应的索引结构中（例如，如果是连续分配，记录起始块号和长度；如果是链接或索引，记录这些块号）。
    6.  **返回分配信息：** 通知请求分配的进程分配成功，并提供相关信息。

    **具体示例（假设位示图每行16位，n=16）：**
    假设扫描到位示图 `map[3, 5]` 和 `map[3, 6]` 都是 "0"。
    *   `b1 = 16 * (3 - 1) + 5 = 16 * 2 + 5 = 32 + 5 = 37`
    *   `b2 = 16 * (3 - 1) + 6 = 16 * 2 + 6 = 32 + 6 = 38`
    *   修改 `map[3, 5] = 1` 和 `map[3, 6] = 1`。
    *   将盘块号37和38分配给文件。

**15. 某操作系统的磁盘文件空间共有500块，若用字长为32位的位示图管理盘空间，试问：**
    **(1) 位示图需多少个字？**
    **(2) 第i字第j位对应的块号是多少？**
    **(3) 给出申请/归还一块的工作流程。**

*   **答：**
    *   磁盘总块数 = 500 块。
    *   字长 = 32 位。

    *   **(1) 位示图需多少个字？**
        *   每个字可以表示 32 个盘块的状态。
        *   需要的字数 = 总块数 / 每字位数 (向上取整)
        *   需要的字数 = 500 / 32 = 15.625
        *   所以，位示图需要 **16 个字**。 (前15个字表示 15 * 32 = 480块，第16个字的前 500 - 480 = 20位用于表示剩余的20块，该字的后12位未使用或标记为不可用)。

    *   **(2) 第i字第j位对应的块号是多少？**
        *   假设字的编号从 0 到 15 (或 1 到 16)，位的编号从 0 到 31 (或 1 到 32)。
        *   **如果字的编号 `i` 从 0 开始，位的编号 `j` 从 0 开始 (通常计算机内部表示方式)：**
            *   块号 `b = i * 32 + j` (这里块号也从0开始计数，即块0到块499)
            *   如果要让块号从1开始计数，则 `b = i * 32 + j + 1`
        *   **如果字的编号 `i` 从 1 开始，位的编号 `j` 从 1 开始 (更符合题目“第i字第j位”的自然语言)：**
            *   块号 `b = (i - 1) * 32 + j` (这里块号从1开始计数，即块1到块500)
        *   **我们采用第二种符合自然语言的假设（i从1，j从1，块号b从1）：**
            *   **块号 `b = (i - 1) * 32 + j`**
            *   这个公式需要保证 `b <= 500`。

    *   **(3) 给出申请/归还一块的工作流程。**
        *   **申请一块的工作流程：**
            1.  **遍历位示图查找空闲位：**
                *   从第一个字 (i=1) 的第一位 (j=1) 开始查找。
                *   依次检查每个字的每一位，直到找到一个值为 "0" (表示空闲) 的位。
                *   假设找到的空闲位是第 `i_found` 字的第 `j_found` 位。
            2.  **检查是否找到：**
                *   如果遍历完整个位示图（所有表示有效块的位）都没有找到 "0"，则表示磁盘空间已满，分配失败，向用户报告错误。
            3.  **计算块号：**
                *   使用公式 `b = (i_found - 1) * 32 + j_found` 计算出对应的物理块号。
            4.  **修改位示图：**
                *   将第 `i_found` 字的第 `j_found` 位设置为 "1" (表示已分配)。
            5.  **返回块号：** 将计算得到的块号 `b` 返回给申请者。
        *   **归还一块的工作流程 (假设归还的块号为 `b_returned`)：**
            1.  **检查块号有效性：**
                *   确保 `1 <= b_returned <= 500`。如果无效，则出错。
            2.  **计算在位示图中的位置：**
                *   字号 `i = (b_returned - 1) DIV 32 + 1` (DIV是整除)
                *   位号 `j = (b_returned - 1) MOD 32 + 1` (MOD是取余)
            3.  **检查当前状态（可选但推荐）：**
                *   读取位示图中第 `i` 字的第 `j` 位。如果该位已经是 "0" (表示未分配)，则可能发生了错误（如重复归还），应进行处理。
            4.  **修改位示图：**
                *   将第 `i` 字的第 `j` 位设置为 "0" (表示空闲)。
            5.  **完成归还：** 块已成功标记为空闲。

**16. 对空闲磁盘空间的管理常采用哪几种分配方式？在UNIX系统中是采用何种分配方式？**

*   **答：**
    *   对空闲磁盘空间的管理常采用的分配方式（即管理方法）主要有：
        1.  **空闲表法 (Free Table Method)**
        2.  **空闲链表法 (Free Linked List Method)** (包括空闲盘块链和空闲盘区链)
        3.  **位示图法 (Bitmap Method)**
        4.  **成组链接法 (Grouped Linking Method)**
    *   在 **UNIX 系统**中，通常采用的是 **成组链接法 (Grouped Linking Method)** 来管理空闲磁盘空间。这种方法将空闲块分组，并使用一个内存中的栈来快速分配和回收小批量的空闲块，同时通过链接块将大量的空闲块组链接起来，兼顾了效率和大规模空闲空间的管理。

**17. 可从哪几方面来提高对文件的访问速度？**

*   **答：** 可以从以下几个主要方面来提高对文件的访问速度：
    1.  **改进文件的目录结构以及检索目录的方法：**
        *   使用高效的目录结构（如B树、哈希表）代替简单的线性列表。
        *   优化目录查找算法，减少查找比较次数。
        *   使用目录缓存，将常用目录项缓存在内存中。
        *   目标是**减少对目录的查找时间**。
    2.  **选取好的文件存储结构（即外存组织方式）：**
        *   根据文件的访问模式（顺序、随机、更新频率）选择合适的组织方式（连续、链接、索引）。
        *   例如，对随机访问频繁的文件使用索引结构，对顺序访问为主的文件尽量使用连续存储。
        *   优化物理块的分布，尽量将同一文件的块存放在相邻磁道或同一柱面，减少磁头移动（如使用簇进行分配）。
        *   目标是**优化数据在磁盘上的布局，提高对文件内容的访问效率**。
    3.  **提高磁盘本身的 I/O 速度及相关技术：**
        *   **磁盘高速缓存 (Disk Cache)：** 在内存中缓存常用的磁盘块，避免实际磁盘I/O。
        *   **提前读 (Read-Ahead / Prefetching)：** 对顺序访问的文件，预先读取后续的盘块到缓存。
        *   **延迟写 (Delayed Write)：** 将写操作先写入缓存，稍后再批量写回磁盘，减少写盘次数。
        *   **采用高性能磁盘硬件：** 更快的转速、更低的寻道时间、更大的磁盘缓存。
        *   **使用RAID技术：** 通过数据分条和并行访问提高吞吐量（如RAID 0, RAID 5）。
        *   **虚拟盘 (RAM Disk)：** 利用内存模拟磁盘，提供极快的I/O速度（但数据易失）。
        *   **I/O调度算法优化：** 如电梯算法，优化磁盘请求队列，减少磁头移动。
        *   目标是**让数据能够更快地从磁盘传送到内存，或从内存传送到磁盘**。

**18. 何谓磁盘高速缓存？在设计磁盘高速缓存时需要考虑哪些问题？**

*   **答：**
    *   **磁盘高速缓存 (Disk Cache)：** 是一种在**主存 (RAM)** 中开辟出来的专门区域，用于临时存放一部分**磁盘盘块的副本**。其目的是为了弥补CPU/内存访问速度与磁盘访问速度之间的巨大差距。当需要访问某个磁盘块时，系统首先检查该块是否在高速缓存中，如果在（缓存命中），则直接从缓存中读写，避免了 느린 物理磁盘操作，从而显著提高I/O性能。
    *   **在设计磁盘高速缓存时需要考虑的关键问题：**
        1.  **缓存的大小 (Cache Size)：** 缓存越大，命中率可能越高，但占用的内存也越多。需要在性能提升和内存成本之间进行权衡。
        2.  **数据交付方式 (Data Delivery Method)：** 当缓存命中时，如何将数据从缓存传递给请求进程？
            *   **数据复制 (Data Copying)：** 将缓存数据复制到用户缓冲区。
            *   **指针交付 (Pointer Passing)：** 将指向缓存数据的指针传递给用户进程。
        3.  **置换算法 (Replacement Algorithm)：** 当缓存已满且需要调入新盘块时，选择哪个旧盘块被替换出去？
            *   常用算法如LRU、LFU、NRU，以及针对磁盘特性的改进（考虑访问频率、可预见性、数据一致性）。
        4.  **写策略 (Write Policy)：** 缓存中被修改的数据（脏块）何时以及如何写回到物理磁盘？
            *   **写穿 (Write-Through)：** 立即写回，一致性好，性能较低。
            *   **写回 (Write-Back / Delayed Write)：** 仅在块被替换或周期性刷新时写回，性能较高，有数据丢失风险。
            *   需要考虑周期性写回机制（如UNIX的`sync`）。
        5.  **缓存块大小 (Cache Block Size)：** 缓存中数据管理的单位，通常与磁盘物理块大小一致或为其倍数。
        6.  **一致性维护 (Consistency Maintenance)：** 如何确保缓存数据与磁盘数据的一致性，特别是在多用户或分布式环境下，以及系统崩溃时。
        7.  **预取策略 (Prefetching Strategy)：** 是否以及如何进行提前读，以提高顺序访问的命中率。

**19. 可以采取哪几种方式将磁盘高速缓存中的数据传送给请求者进程？**

*   **答：** 可以采取以下两种主要方式将磁盘高速缓存中的数据传送给请求者进程：
    1.  **数据复制 (Data Copying / Data Transfer):**
        *   这是最直接和传统的方式。
        *   当缓存命中时，将高速缓存中存储的相应盘块的数据内容**复制**一份到请求者进程在其用户空间中指定的内存工作区（用户缓冲区）。
        *   **优点：** 实现相对简单，用户进程得到的是数据的私有副本，隔离性较好。
        *   **缺点：** 涉及到数据块在内存中的复制操作，当数据量较大时，这个复制过程本身会消耗一定的CPU时间和内存带宽。
    2.  **指针交付 (Pointer Passing / Address Passing):**
        *   这种方式不进行实际的数据内容复制。
        *   当缓存命中时，操作系统内核只将一个**指向高速缓存中该数据块所在内存区域的指针**交付给请求者进程。
        *   用户进程可以直接通过这个内核空间的指针（或者通过内存映射机制间接访问）来读取或修改缓存中的数据。
        *   **优点：** 由于传送的数据量极少（只有一个指针），因此可以显著节省数据从高速缓存存储空间复制到进程内存工作区的时间，效率更高，尤其对大数据块有利。
        *   **缺点：** 实现相对复杂，需要处理好内核空间与用户空间的内存共享、保护和同步问题。用户进程直接操作内核缓存数据可能带来安全风险或一致性问题，需要精心设计。

**20. 何谓提前读和延迟写？**

*   **答：**
    *   **提前读 (Read-Ahead / Prefetching):**
        *   是一种针对**文件顺序访问**模式的磁盘I/O优化技术。
        *   其核心思想是：当操作系统检测到或预测到进程正在顺序地读取文件时，它会**主动地、提前地**将文件中紧随当前正在被访问的盘块之后的**一个或多个后续盘块**也读入到内存的缓冲区（通常是磁盘高速缓存或专门的预读缓冲区）中。
        *   **目的：** 这样，当进程实际请求读取这些后续盘块时，数据很可能已经存在于内存中，可以直接从缓冲区获取，从而避免了启动物理磁盘I/O操作的延迟，显著提高了顺序读的吞吐率和响应速度。
    *   **延迟写 (Delayed Write / Write-Back Caching):**
        *   是一种旨在提高**写操作效率**和减少磁盘I/O次数的优化技术。
        *   其核心思想是：当进程执行写操作，需要将数据写入磁盘时，操作系统并**不立即**将这些数据物理地写入到磁盘上。
        *   相反，数据首先被写入到内存中的一个缓冲区（如磁盘高速缓存中的相应盘块，该盘块被标记为“脏”或“已修改”）。
        *   这些“脏”的缓冲区会暂时保留在内存中，直到满足某些条件时才会被真正写回到磁盘。这些条件可能包括：
            *   缓冲区被置换算法选中需要被替换出去。
            *   系统空闲时进行批量写回。
            *   达到一定的时间间隔（周期性写回，如UNIX的`sync`）。
            *   应用程序显式调用刷新命令（如 `fsync`）。
            *   缓冲区数量达到一定阈值。
        *   **目的：**
            *   **减少磁盘写操作次数：** 对同一盘块的多次小修改可以在内存中进行，最后合并为一次磁盘写。
            *   **提高写操作的响应速度：** 进程发出写请求后可以较快返回，因为数据只是写入了快速的内存。
            *   **可能利用磁盘调度优化：** 累积一批写操作后，可以进行磁盘调度优化，减少磁头移动。
        *   **风险：** 如果在脏数据写回磁盘前系统发生崩溃，这部分未写回的数据将会丢失。

**21. 试说明廉价磁盘冗余阵列RAID的主要优点。**

*   **答：** 廉价磁盘冗余阵列 (RAID - Redundant Array of Inexpensive Disks) 的主要优点包括：
    1.  **提高I/O性能 (特别是吞吐量)：**
        *   通过**数据分条 (Data Striping)** 技术，将数据分散存储在阵列中的多个磁盘上。
        *   当进行读写操作时，可以**并行地**从多个磁盘同时存取数据，从而显著提高数据传输速率和I/O吞吐量。RAID 0级别尤其突出这一点。
    2.  **提高数据可靠性和可用性 (容错能力)：**
        *   通过引入**数据冗余**机制，如**镜像 (Mirroring)** (RAID 1) 或**奇偶校验 (Parity)** (RAID 3, RAID 4, RAID 5, RAID 6)。
        *   当阵列中的一个（或多个，取决于RAID级别）磁盘发生故障时，系统仍然可以继续工作（降级模式），并且可以通过冗余信息恢复丢失的数据，从而保证了数据的完整性和业务的连续性。
        *   这大大降低了因单个磁盘故障导致数据丢失的风险。
    3.  **容量扩展性：**
        *   RAID可以将多个物理磁盘组合成一个逻辑上更大的存储卷，从而提供比单个磁盘更大的存储容量。
    4.  **成本效益 (相对于大型单个高性能磁盘)：**
        *   “廉价”最初指的是使用多个标准、低成本的磁盘来达到或超过单个昂贵、高性能大型磁盘驱动器 (SLED - Single Large Expensive Disk) 的性能和可靠性。虽然现在“廉价”的含义有所演变，但其组合多个驱动器的基本思想仍然具有成本上的灵活性。
    5.  **可维护性：**
        *   许多RAID系统支持**热插拔 (Hot Swapping)**，允许在系统不停止运行的情况下更换故障磁盘，提高了系统的可维护性和在线时间。
    6.  **多种级别选择：**
        *   RAID提供了多种不同的级别（如RAID 0, 1, 5, 6, 10等），用户可以根据对性能、可靠性、容量和成本的不同需求选择最合适的RAID配置。

    
---
