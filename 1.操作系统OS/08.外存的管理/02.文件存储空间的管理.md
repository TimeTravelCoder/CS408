
**核心目标与前提：**
为了实现前面章节讨论的任何一种文件组织方式（连续、链接、索引），操作系统都必须能够为文件分配实际的磁盘盘块。这就引出了一个核心问题：如何知道磁盘上哪些盘块是空闲的、可以用于分配的？

因此，在为文件分配磁盘空间时，除了需要文件分配表（如FAT，用于记录一个文件已经占用了哪些盘块）之外，系统还必须为**可供分配的存储空间**建立并维护相应的数据结构。这些数据结构通常被称为**磁盘分配表 (Disk Allocation Table)** 或空闲空间管理表，它们的核心任务是记录当前磁盘上所有空闲盘块的情况。

此外，操作系统还需要提供有效的**盘块分配和回收机制**。无论采用何种分配和回收策略，文件存储空间管理的基本单位都是**磁盘块 (block)** 或簇 (cluster)，而不是字节。

**主要的文件存储空间管理方法：**

目前常用的文件存储空间管理方法主要有以下几种：

1.  **空闲表法 (Free Table Method)**
2.  **空闲链表法 (Free Linked List Method)**
3.  **位示图法 (Bitmap Method)**
4.  **成组链接法 (Grouped Linking Method)**

---

**8.2.1 空闲表法和空闲链表法**

这两种方法是较为传统和基础的空闲空间管理方式。

**1. 空闲表法 (Free Table Method)**

*   **适用场景与原理：**
    *   空闲表法主要与**连续分配方式**相配合使用。其管理思想与内存管理中的动态分区分配非常相似。
    *   系统为外存（磁盘）上的所有空闲区域建立一张**空闲盘块表 (Free Block Table)**。
*   **数据结构：空闲盘块表**
    *   表中的每一个表项对应磁盘上的一个连续空闲区。
    *   每个表项通常包含以下信息：
        *   **表项序号 (Optional):** 用于标识表项。
        *   **该空闲区的第一个盘块号 (Starting Block Number):** 标记空闲区的起始位置。
        *   **该区的空闲盘块数 (Number of Free Blocks):** 标记空闲区的大小。
    *   为了方便查找和管理，所有空闲区通常会按照其**起始盘块号递增的次序**在表中排列。
    *   *图8-9 空闲盘块表示例：* 展示了一个典型的空闲盘块表结构，其中列出了序号、第一个空闲盘块号和空闲盘块数。
	    * ![[Pasted image 20250531145952.png]]
*   **存储空间的分配与回收：**
    *   **分配：**
        *   当系统需要为一个新创建的文件分配空闲盘块时，它会顺序地检索空闲盘块表的各个表项。
        *   常用的分配算法包括：
            *   **首次适应算法 (First Fit):** 找到第一个大小能满足请求的空闲区。
            *   **最佳适应算法 (Best Fit):** 找到大小与请求最接近且能满足要求的最小空闲区。
            *   **最坏适应算法 (Worst Fit):** 找到最大的空闲区（通常较少使用）。
        *   找到合适的空闲区后，系统会从该空闲区中划出所需数量的盘块分配给文件，并相应地修改空闲盘块表（如更新该空闲区的起始盘块号和空闲块数，或者如果整个空闲区被分配完则删除该表项）。
    *   **回收：**
        *   当一个文件被删除，其占用的磁盘空间被释放时，系统需要将这部分空间回收并加入到空闲空间中。
        *   回收过程类似于内存回收，关键在于**合并相邻空闲区**。
        *   需要检查回收的区域是否与空闲盘块表中其插入位置的前一个空闲区或后一个空闲区相物理邻接。如果邻接，则应将它们合并成一个更大的空闲区，以减少碎片。
*   **特点与应用场景：**
    *   虽然在内存分配中，由于外部碎片问题，连续分配方式的使用有所减少，但在外存管理中，由于连续分配方式具有**较高的分配速度**（一旦找到合适区域，分配过程简单）和能够**减少磁盘I/O的寻道时间与旋转延迟**（数据连续存放），它在某些场景下仍然有其优势。
    *   **常见应用：**
        *   **对换空间 (Swapping Space) 的管理：** 操作系统用于进程对换的磁盘区域通常采用连续分配方式，以保证快速的换入换出。
        *   **文件系统中的小文件：** 当文件非常小，例如只占用1到4个盘块时，系统仍然可能倾向于采用连续分配方式，因为开销小且访问快。
        *   **多媒体文件：** 对于视频、音频等多媒体文件，为了保证流畅播放，减少磁头的寻道时间至关重要，因此也常采用连续或尽量连续的分配方式。

**2. 空闲链表法 (Free Linked List Method)**

*   **核心思想：** 将磁盘上所有的空闲盘区（可以是单个盘块，也可以是连续的盘块区域）通过指针链接起来，形成一条或多条空闲链。
*   **根据构成链的基本元素的不同，可以分为两种主要形式：**

    *   **a) 空闲盘块链 (Free Block Chain):**
        *   **数据结构：**
            *   将磁盘上所有空闲空间以**单个盘块**为基本单位链接起来。
            *   每个空闲盘块中，除了自身作为空闲空间外，还需要存储一个指向**下一个空闲盘块**的指针。链的末尾盘块指针为特殊值（如NULL或-1）。
            *   系统通常会保存一个指向链首空闲盘块的指针。
        *   **分配：**
            *   当用户进程请求分配存储空间时（例如，需要 `k` 个盘块）。
            *   系统从空闲盘块链的链首开始，依次取下 `k` 个空闲盘块分配给用户。
            *   同时更新链首指针。
        *   **回收：**
            *   当文件删除释放盘块时，系统将回收的盘块逐个链接到空闲盘块链的**末尾**（或者链首，取决于实现策略）。
        *   **优点：**
            *   分配和回收**单个盘块**的过程非常简单、开销小。
        *   **缺点：**
            *   为一个文件分配**多个盘块**时，可能需要重复执行多次摘取操作，效率较低。
            *   如果磁盘空闲空间非常零散，空闲盘块链可能会非常长，遍历和管理开销增大。
            *   难以分配连续的空闲盘块。

    *   **b) 空闲盘区链 (Free Region Chain / Free Extent Chain):**
        *   **数据结构：**
            *   将磁盘上所有空闲的**连续盘区**（每个盘区可以包含一个或多个连续的盘块）链接起来。
            *   在每个空闲盘区的**起始盘块**中，除了数据（标记为空闲），还需要存储：
                *   指向**下一个空闲盘区**的指针。
                *   能指明**本盘区大小**（即包含的空闲盘块数量）的信息。
        *   **分配：**
            *   分配过程类似于内存的动态分区分配，通常采用**首次适应算法**。系统遍历空闲盘区链，查找第一个大小足够的空闲盘区。
            *   如果找到的空闲盘区大于所需空间，则将其分割，一部分分配出去，剩余部分仍作为一个较小的空闲盘区保留在链中。如果恰好相等，则整个盘区被分配，并从链中移除。
        *   **回收：**
            *   回收盘区时，同样需要考虑与链中已有的空闲盘区进行**合并**，以避免产生过多的小空闲盘区。检查回收盘区是否与前后空闲盘区物理邻接。
        *   **提高检索速度的改进：**
            *   为了提高对空闲盘区的检索速度，可以采用**显式链接方法**，即在内存中为所有空闲盘区建立一张链表。这张内存链表中的每个结点记录一个空闲盘区的起始地址和大小，以及指向下一个空闲盘区结点的指针。这样查找空闲盘区主要在内存中进行。
        *   **优缺点比较 (与空闲盘块链相比)：**
            *   **优点：** 每次为文件分配可能是多个连续的块，对于需要连续空间的应用（如前述的连续分配场景）更有利。空闲盘区链通常比空闲盘块链短。
            *   **缺点：** 分配和回收单个盘区（尤其是涉及分割和合并时）的过程比空闲盘块链复杂。

---

**8.2.2 位示图法 (Bitmap Method)**

*   **核心思想：**
    *   利用二进制位串（位图）来跟踪磁盘上每个盘块的使用情况。
    *   位图中的每一位对应磁盘上的一个物理盘块。
    *   位的状态表示对应盘块的状态：
        *   通常，若位值为 **"0"**，表示对应的盘块**空闲**。
        *   若位值为 **"1"**，表示对应的盘块**已分配**。
        *   (注意：某些操作系统实现中，"0" 和 "1" 的含义可能相反，但这只是约定问题，核心原理不变。)
*   **数据结构：位示图 (Bitmap)**
    *   位示图是一个由二进制位组成的集合，其总位数等于磁盘上的总盘块数。
    *   为了方便管理和访问，位示图通常可以组织成一个**二维数组** `map[m, n]`，其中 `m` 是行数，`n` 是每行的位数（通常是计算机字长的倍数，如32位或64位）。总位数 `m * n` 即为磁盘总块数。
    *   *图8-10 位示图示例：* 展示了一个16列（假设每行16位）的位示图。
	    * ![[Pasted image 20250531150018.png]]
*   **盘块的分配：**
    1.  **查找空闲盘块：**
        *   操作系统顺序扫描位示图（可以按行扫描，也可以按特定的搜索策略）。
        *   从中查找一个或一组（如果需要连续块）其值为 "0" 的二进制位。
    2.  **二进制位到盘块号的转换：**
        *   一旦找到一个值为 "0" 的位，需要将其在位示图中的位置（行号 `i` 和列号 `j`）转换成实际的物理盘块号 `b`。
        *   转换公式为：`b = n * (i - 1) + j` (假设行号 `i` 和列号 `j` 均从1开始计数，`n` 是位示图每行的位数)。
    3.  **修改位示图：**
        *   将找到的对应空闲盘块的位的值从 "0" 修改为 "1"，表示该盘块已被分配。即 `map[i, j] = 1`。
*   **盘块的回收：**
    1.  **盘块号到二进制位的转换：**
        *   当一个盘块被释放时，需要将其物理盘块号 `b` 转换回其在位示图中的行号 `i` 和列号 `j`。
        *   转换公式为：
            *   行号 `i = (b - 1) DIV n + 1` (DIV 表示整除)
            *   列号 `j = (b - 1) MOD n + 1` (MOD 表示取余)
    2.  **修改位示图：**
        *   将计算得到的对应盘块的位的值从 "1" 修改为 "0"，表示该盘块已变为空闲。即 `map[i, j] = 0`。
*   **优点：**
    1.  **易于找到一个或一组相邻接的空闲盘块：** 连续的 "0" 位串直接对应连续的空闲盘块，这对于需要连续存储空间的文件分配非常有利。例如，要查找6个相邻的空闲盘块，只需在位示图中查找一个长度为6的、全为 "0" 的位串。
    2.  **位示图本身占用空间小：** 例如，一个拥有 1TB 磁盘（假设盘块大小为 4KB）的系统，总盘块数约为 2.5亿，如果每位表示一块，位示图大小约为 30MB 左右，这完全可以常驻内存。
    3.  **内存常驻带来的效率提升：** 由于位示图可以保存在内存中，盘块的分配和回收操作主要在内存中进行，避免了频繁读写磁盘上的分配表，从而节省了大量的磁盘启动操作和I/O时间。
*   **应用场景：**
    *   位示图法因其高效性和易于管理连续空间的特点，常用于**微型计算机和小型计算机的操作系统**中，例如早期的 CP/M、Apple-DOS 等。现代操作系统中也仍有其变种或结合使用。

---

**8.2.3 成组链接法 (Grouped Linking Method)**

*   **适用场景与动机：**
    *   当文件系统非常大时，前面提到的空闲表法可能会导致空闲表过长，空闲链表法（特别是空闲盘块链）可能会导致空闲链过长，管理和查找效率下降。
    *   成组链接法是 **UNIX 系统中广泛采用**的一种高效的空闲盘块管理方法。它巧妙地结合了空闲表和空闲链的思想，有效地解决了表或链过长的问题。
*   **空闲盘块的组织方式：**
    1.  **空闲盘块号栈 (S.free Stack):**
        *   在内存中设置一个专用的**栈**，称为 `S.free` (或类似名称)。
        *   这个栈用于存放当前**可用的一组空闲盘块的盘块号**。栈的大小是固定的，例如，可以存放100个盘块号。
        *   栈中还需要一个变量 **N**，记录当前栈中实际存放的空闲盘块号的数量。N 同时也可以作为**栈顶指针**使用（例如，N=100时栈满，N=0时栈空，指向下一个可用的位置）。
        *   由于多个进程可能同时请求或释放盘块，该栈属于**临界资源**，对其访问需要通过锁机制进行同步保护。
        *   *图8-11 左部示例：* 展示了空闲盘块号栈的结构，`S.free(0)` 是栈底，栈满时 `S.free(99)` 是栈顶。
	        * ![[Pasted image 20250531150047.png]]
    2.  **文件区空闲盘块的分组：**
        *   磁盘上用于存放文件的区域（文件区）中的所有空闲盘块被逻辑上划分成若干**组 (groups)**。
        *   每组包含的盘块数量与内存中空闲盘块号栈的容量相同（例如，每100个盘块为一组）。
        *   *图8-11 中部和右部示例：* 假设磁盘上有10000个盘块，其中201号到7999号盘块用于存放文件。这些文件区的空闲盘块会被分组。
            *   最末尾的一组可能是：7901 ~ 7999 (99个块)
            *   倒数第二组可能是：7801 ~ 7900 (100个块)
            *   ...
            *   第一组（最靠近文件区起始位置的）可能是：201 ~ 300 (100个块)
    3.  **组间的链接 (核心思想)：**
        *   这是成组链接法的关键。将每一组（除了最后一组）的**所有盘块号**以及**指向下一组空闲盘块信息的指针**（即下一组的第一个盘块的盘块号，该盘块也充当链接块）存储在**其前一组的第一个盘块**中。
        *   具体来说，对于一个包含100个盘块的组，其前一组的第一个盘块（我们称之为链接块）的内容会是：
            *   `链接块[0]` = 该组实际包含的空闲盘块数（通常是100，但最后一组可能小于100）
            *   `链接块[1]` 到 `链接块[N]` = 该组的N个空闲盘块的盘块号
            *   （在UNIX实现中，更常见的是 `链接块[0]` 存下一组的链接块地址，`链接块[1]`存本组盘块数，`链接块[2]`...存本组盘块号）
            *   书中的描述是：将每一组含有的盘块总数N（指下一组的盘块数）和该组（指下一组）所有的盘块号记入其前一组的第一个盘块的 `S.free(0)` ~ `S.free(99)` 中。这表示前一组的第一个盘块被用作一个“目录”，指向并列出了下一大组的空闲块。
        *   这样，所有空闲盘块组通过这些“链接块”形成了一条链。
        *   *图8-11 示例理解：* 盘块301（第二组的链接块）中存放了第三组(401~500)的盘块号列表及指向第四组的链接信息。盘块201（第一组的链接块）中存放了第二组(301~400)的盘块号列表及指向盘块301的链接。
    4.  **栈的初始化（系统启动时）：**
        *   系统启动时，会将**第一组（或称为超级块中直接指向的那一组）的空闲盘块总数**和**所有盘块号**读入内存的 `S.free` 栈中。这些盘块号就构成了当前立即可供分配的空闲盘块。
        *   `S.free(0)` (栈底) 会特殊处理，通常存放指向下一大组空闲盘块的链接块的盘块号（如果当前栈中的块用完了，就从这里加载新的）。
    5.  **最末一组的特殊处理：**
        *   磁盘上最后一组空闲盘块可能不足一个完整的组（例如，不足100个）。
        *   这最后一组的盘块号列表会存储在其前一个链接块中。
        *   这个链接块的 `S.free(0)` (或表示下一组链接的字段) 会存放一个特殊的**结束标志** (例如 "0")，表示空闲盘块链的结束。
*   **空闲盘块的分配与回收：**
    *   **分配 (当进程请求一个空闲盘块时)：**
        1.  检查 `S.free` 栈是否上锁（防止并发问题），如果未锁，则加锁。
        2.  检查栈顶指针 N。如果 N > 0 (栈非空，且 `S.free(0)` 不代表链接块)，则从栈顶 `S.free[N-1]` (或 `S.free[N]` 取决于N的定义) 取出一个空闲盘块号分配给用户。
        3.  栈顶指针 N 减 1。
        4.  **关键步骤：如果栈空 (N=0，意味着当前内存栈中的直接可用盘块已分配完毕，此时 `S.free[0]` 中应该存放的是下一个链接块的盘块号)：**
            *   系统从磁盘上读取 `S.free[0]`所指向的那个链接块。
            *   将该链接块的内容（即下一大组的空闲盘块号列表和再下一组的链接信息）复制到内存的 `S.free` 栈中，更新栈顶指针 N。
            *   原来的 `S.free[0]` (即那个链接块本身) 就可以被分配出去了 (因为它现在是空闲的，并且它的信息已经被加载到内存栈中了)。
            *   (书中的描述是 "把原栈底对应的盘块分配出去(其中的有用数据已读入栈中)。然后，再分配一相应的缓冲区(作为该盘块的缓冲区)。" 这一步理解为该链接块自身被分配，其内容已转移)。
        5.  如果最初N就等于0（栈底是链接块），则先执行第4步加载新组，然后再分配。
        6.  最后，（如果之前栈是满的，则栈中空闲盘块数N实际上会变成下一组的块数，然后分配一个，N再减1）返回分配的盘块号，并解锁栈。
    *   **回收 (当进程释放一个盘块时)：**
        1.  检查 `S.free` 栈是否上锁，未锁则加锁。
        2.  检查栈顶指针 N。如果 N < 栈容量 (例如 N < 100，栈未满)，则将回收盘块的盘块号压入栈顶 `S.free[N]`。
        3.  栈顶指针 N 加 1。
        4.  **关键步骤：如果栈满 (N = 栈容量，例如 N=100)：**
            *   这表示内存中的 `S.free` 栈已经充满了空闲盘块号。
            *   此时，系统将**当前 `S.free` 栈中的全部100个盘块号**（这些代表了一组新的空闲盘块）**写入到新回收的那个盘块中**。
            *   这个新回收的盘块就变成了一个新的**链接块**，它存储了刚刚从内存栈中“溢出”的那一组空闲盘块的信息。
            *   然后，将这个新回收盘块（现在是链接块了）的**盘块号**存入 `S.free[0]` (栈底)。
            *   栈顶指针 N 设置为 1 (表示栈中现在只有一个元素，即指向新形成的磁盘链接块的指针)。
        5.  解锁栈。

**这种分配和回收机制的核心在于，大部分情况下分配和回收操作都只涉及内存栈的快速操作。只有当栈空或栈满时，才需要进行一次磁盘I/O操作（读入下一组或写出当前组到新的链接块）。这大大提高了空闲空间管理的效率，尤其是在有大量小文件频繁创建和删除的系统中。**

---

