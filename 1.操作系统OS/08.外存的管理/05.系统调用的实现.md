
**引言：**
系统调用的实现与一般过程调用的实现有很大差异。关键在于系统调用涉及从**用户态到核心态（系统态）的转换**，以及执行完毕后从核心态返回用户态。这个转换和执行过程是通过**陷入机制（Trap Mechanism）**来完成的。陷入机制包括硬件和软件两部分：硬件负责响应陷入指令并切换状态，软件（操作系统内核的陷入处理程序）负责后续的具体处理。

---

**9.6.1 系统调用的实现方法（通用步骤）**

实现一个系统调用的过程大致可以分为用户程序发起调用、操作系统内核处理、返回结果给用户程序三个阶段。

1.  **用户程序发起调用（参数传递与陷入）**
    *   **a. 设置系统调用号：**
        *   操作系统为每个系统调用分配一个唯一的编号（系统调用号）。
        *   **传递方式：**
            *   **陷入指令自带：** 某些架构（如 IBM 370，早期 UNIX）的陷入指令（如 `CHMK`）的低位字节用于存放系统调用号。
            *   **指定寄存器：** 将系统调用号放入一个约定的寄存器中（如 MS-DOS 的 AH 寄存器，Linux 的 EAX 寄存器）。
    *   **b. 设置系统调用参数：**
        *   系统调用通常需要若干参数。
        *   **传递方式：**
            *   **陷入指令自带：** 陷入指令长度有限，只能携带少量参数。
            *   **通用寄存器：** 将参数直接放入通用寄存器中（如 MS-DOS）。数量受限于可用寄存器个数。
            *   **参数表（内存块）：** 将所有参数组织成一个参数表存放在内存中，然后将该参数表的首地址放入一个指定寄存器。这是 UNIX 和 Linux 等现代操作系统常用的方式。
                *   **直接参数方式（图 9-8a）：** 参数表中直接存放参数值和参数个数 N。
	                * ![[Pasted image 20250531150530.png]]
                *   **间接参数方式（图 9-8b）：** 参数表中存放参数个数 N 和指向真正参数数据表的指针。
	                * ![[Pasted image 20250531150539.png]]
    *   **c. 执行陷入指令：**
        *   用户程序执行一条特定的陷入指令（如 `INT 21H` in MS-DOS, `INT 80H` or `SYSENTER` in Linux, `INT 2EH` or `SYSENTER` in Windows, `CHMK` in older UNIX）。

2.  **操作系统内核处理系统调用**
    *   **a. 硬件/内核的共性处理（陷入处理程序入口）：**
        *   **状态切换：** CPU 从用户态切换到核心态。
        *   **保存现场：**
            *   硬件自动保存部分现场（如程序状态字 PSW、程序计数器 PC）。
            *   内核的陷入处理总入口程序进一步保存需要保护的 CPU 运行环境（如通用寄存器内容、用户栈指针、系统调用号等）到核心栈。
        *   **参数获取：** 内核从用户空间（寄存器或用户栈/内存）拷贝参数到核心空间的安全区域。
    *   **b. 分析系统调用类型并转入相应处理程序：**
        *   内核根据系统调用号，在**系统调用入口表（System Call Table / Dispatch Table）**中查找对应的系统调用处理子程序的入口地址。
        *   系统调用入口表的每一项对应一个系统调用，包含该系统调用处理子程序的入口地址、参数个数等信息。
        *   内核将控制权转交给特定的系统调用处理子程序。
    *   **c. 执行系统调用处理子程序：**
        *   该子程序执行具体的功能。例如，`creat` 系统调用的处理过程：
            1.  根据用户提供的路径名（Path）进行目录检索。
            2.  **文件已存在：** 检查用户是否有修改权限。
                *   无权限：出错处理。
                *   有权限：释放文件原有数据块，准备写入新数据。
            3.  **文件不存在：** 表示要创建新文件。
                *   在目录中找到一个空目录项，并进行初始化（文件名、属性、建立日期等）。
                *   打开新建文件。
        *   处理过程中可能需要与硬件交互、修改内核数据结构等。
    *   **d. 返回前的共性处理：**
        *   系统调用处理子程序执行完毕后，将结果（返回值或错误码）存放到指定位置（通常是某个寄存器）。
        *   控制权返回到陷入处理总程序的末尾部分。

3.  **从核心态返回用户程序**
    *   **恢复现场：** 从核心栈中恢复之前保存的 CPU 运行环境（寄存器、PSW、PC 等）到 CPU。
    *   **状态切换：** CPU 从核心态切换回用户态。
    *   **返回用户程序：** 控制权返回到用户程序中陷入指令的下一条指令继续执行。用户程序可以从指定位置（如寄存器）获取系统调用的返回结果。

---

**9.6.2 UNIX 系统调用的实现（以 V 系列为例，经典实现）**

UNIX 系统调用的实现遵循上述通用步骤，但有其特定的细节。

1.  **核心文件：**
    *   `trap.S`：中断和陷入总控程序，汇编语言编写，处理 CPU 环境保护等。
    *   `trap.C`：C 语言编写，处理各种陷入情况的具体逻辑，包括系统调用分发。

2.  **CPU 环境保护 (`trap.S`)：**
    *   用户程序执行 `CHMK`（Change Mode to Kernel）命令前，已将参数表地址放入 R0 寄存器。
    *   `CHMK` 执行后，硬件自动将处理机状态长字 (PSL)、程序计数器 (PC) 和代码操作数 (code，包含系统调用号) 压入用户核心栈。
    *   `trap.S` 程序接管，继续将陷入类型 (type)、用户栈指针 (usp) 以及一系列通用寄存器 (R0~R11，根据屏蔽码决定哪些需要保存) 压入用户核心栈。
    *   **AP 和 FP 指针 (图 9-9)：** 为支持嵌套调用，系统还设置了系统调用参数表指针 (AP，如 R12) 和调用栈帧指针 (FP)。每次新的系统调用，AP 和 FP 会被压入用户核心栈。
	      ![[Pasted image 20250531150626.png]]
3.  **确定系统调用号 (`trap.C`)：**
    *   `trap.S` 在完成现场保护后，会调用 `trap.C` 中的 `trap(usp, type, code, PC, PSL)` 函数。
    *   `trap.C` 从 `code` 参数中提取系统调用号 `i`（例如，`i = code & 0377`）。
    *   如果 `i=0`，则表示系统调用号未包含在 `code` 中，需要通过间接参数方式（如用户提供的参数表中的指针）找到。

4.  **参数传送 (`trap.C`)：**
    *   `trap.C` 将用户程序设置的参数从用户空间拷贝到内核的 `User` 结构中的 `U.U-arg` 区域。参数表的首地址之前由用户程序放入 R0，`trap.C` 可以通过保存的 R0 值（或 `usp` 指向的栈内容）找到这个地址。通常最多允许10个参数。

5.  **利用系统调用定义表转入相应处理程序 (`trap.C`)：**
    *   UNIX 内核维护一个**系统调用定义表 `Sysent[]`**。
    *   `Sysent[]` 是一个结构数组，每个结构元素对应一个系统调用，包含：
        *   该系统调用所需参数的个数。
        *   通过寄存器传送的参数个数（如果有的話）。
        *   该系统调用处理子程序的入口地址。
    *   `trap.C` 以系统调用号 `i` 作为索引，在 `Sysent[]` 表中找到对应表项，从而获得处理子程序的入口地址，并跳转执行。

6.  **系统调用返回前的公共处理 (`trap.C` -> `trap.S`)：**
    *   子程序执行完毕后，返回到 `trap.C`。
    *   `trap.C` 重新计算进程的动态优先级。
    *   检查是否有“再调度标志”，若有则调用 `switch` 调度程序。
    *   处理信号：UNIX 规定，仅当进程从核心态返回用户态时，内核才检查是否有待处理信号。若有，则执行相应动作。
    *   控制权返回 `trap.S`，`trap.S` 执行返回指令 (RET)，将压入用户核心栈的所有数据（PSL, PC, FP, AP, 寄存器等）退还到相应寄存器。
    *   CPU 控制权从系统调用返回到被中断的用户进程，继续执行。

---

**9.6.5 Linux 系统调用的实现（简介）**

Linux 系统调用实现与 UNIX 类似，也采用陷入机制。

1.  **CPU 保护模式：** 利用 CPU 的保护模式（特权级 0 为内核态，特权级 3 为用户态）。
2.  **内核函数：** 系统调用的核心实现在内核函数中，用 C 语言编写，运行在内核态。
3.  **接口函数（库函数）：** 提供给应用程序的 API，通常是 glibc 库中的函数，用汇编语言编写一小段封装代码。
    *   将系统调用号放入 `EAX` 寄存器。
    *   将参数按顺序放入 `EBX, ECX, EDX, ESI, EDI, EBP` 等寄存器。
    *   执行 `int 0x80` 软中断指令（或现代的 `SYSENTER` 指令）。
4.  **内核处理 `int 0x80`：**
    *   内核的 `int 0x80` 处理程序（`system_call`）接管。
    *   保存寄存器现场。
    *   从 `EAX` 获取系统调用号，检查其合法性。
    *   从寄存器或用户栈拷贝参数到内核空间。
    *   使用系统调用号作为索引，在 `sys_call_table`（系统调用表，一个函数指针数组）中找到对应的内核处理函数并调用。
    *   内核处理函数执行完毕，返回值放入 `EAX`。
    *   恢复寄存器现场。
    *   执行 `iret`（中断返回）指令，返回用户态。

---

**9.6.6 Win32 的应用程序接口 (API)**

Windows 的实现方式与 UNIX/Linux 有显著不同，更侧重于 API 和事件驱动。

1.  **API 与系统调用的区别：**
    *   **API (Application Programming Interface)：** 应用程序员使用的函数定义，说明如何获得服务（如 `CreateFile()`, `ReadFile()`）。
    *   **系统调用：** 操作系统内核提供的服务请求机制，通常通过中断/陷入实现。
    *   一个 API 函数可能不对应任何系统调用（完全在用户态库中实现），或对应一个系统调用，或对应多个系统调用。
2.  **事件驱动模式：** Windows 程序通常是事件驱动的，主程序等待事件发生（鼠标点击、键盘敲击、USB 插入等），然后根据事件调用相应处理程序。
3.  **Win32 API：**
    *   提供一系列函数用于创建和管理核心对象（文件、进程、线程、管道等）。
    *   调用 API 创建对象时，返回一个**句柄 (Handle)** 给调用者。句柄是指向内核对象表的一个索引，通过句柄可以间接访问内核对象。
4.  **实现机制 (Intel x86)：**
    *   应用程序调用 Win32 API 函数（通常位于 `kernel32.dll`, `user32.dll`, `gdi32.dll` 等动态链接库中）。
    *   这些 DLL 中的 API 函数存根 (stub) 可能会调用更底层的 `ntdll.dll` 中的函数。
    *   `ntdll.dll` 中的函数负责实际的系统调用转换：
        *   将内部的系统服务号（类似于系统调用号）放入 `EAX` 寄存器。
        *   将参数放到栈上或某些寄存器中。
        *   执行 `SYSENTER` 指令（较新的 CPU）或 `INT 0x2E` 指令。
    *   **内核陷入处理：**
        *   CPU 切换到核心态，跳转到内核的系统服务分派器（System Service Dispatcher，如 `KiSystemService`）。
        *   分派器保存现场，验证参数。
        *   使用 `EAX` 中的服务号作为索引，在**系统服务分派表 (SSDT - System Service Dispatch Table)** 中查找对应的内核执行体 (Executive) 函数地址。
        *   调用内核执行体函数（位于 `ntoskrnl.exe`）。
    *   内核执行体函数完成实际操作。
    *   结果返回，恢复现场，切换回用户态。
5.  **动态链接库 (DLL)：** Windows 大量使用 DLL 来组织 API 函数。应用程序在运行时动态链接这些库。

---

