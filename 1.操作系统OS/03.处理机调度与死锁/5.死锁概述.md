**引言**
死锁是多道程序环境下，多个进程因竞争资源或通信不当而造成的一种互相等待的僵局，若无外力作用，这些进程都将无法向前推进。本节主要讨论死锁产生的原因、必要条件以及处理死锁的基本方法。

**3.5.1 资源问题**
系统中存在多种类型的资源，其中引起死锁的主要是需要互斥访问且不可被抢占的资源（临界资源）。

1.  **可重用性资源和消耗性资源**
    *   **1) 可重用性资源 (Reusable Resources)**
        *   **定义**：可供用户重复使用多次的资源，其单元在任意时刻只能分配给一个进程使用，使用完毕后会归还系统。
        *   **特性**：
            *   **互斥使用**：每个单元同一时间只能分配给一个进程。
            *   **请求-使用-释放**：进程按此顺序使用资源，若请求失败则可能阻塞。
            *   **数量固定**：系统中的该类资源单元数目相对固定，进程不能创建或删除。
        *   **示例**：处理机、内存、I/O设备（打印机、磁盘驱动器）、文件、数据库、信号量等。
        *   **操作**：通常通过系统调用（如设备的`request/release`，文件的`open/close`，信号量的`wait/signal`）来请求和释放。
    *   **2) 可消耗性资源 (Consumable Resources)**
        *   **定义**：在进程运行期间，由进程动态创建和消耗的资源，也称临时性资源。
        *   **特性**：
            *   **数量可变**：其单元数目在进程运行期间可以变化，可能为0。
            *   **动态创建**：进程可以创建该类资源的单元。
            *   **消耗不再归还**：进程请求若干单元后将其消耗掉，不会再返回给资源类。
        *   **示例**：进程间通信时产生的消息、中断信号等。

2.  **可抢占性资源和不可抢占性资源**
    *   **1) 可抢占性资源 (Preemptible Resources)**
        *   **定义**：某进程在获得这类资源后，该资源可以被其他进程或系统强制剥夺。
        *   **示例**：CPU（高优先级进程可抢占低优先级进程的CPU）、主存（进程可被换出到外存，即内存空间被抢占）。
        *   **注意**：这类资源通常不会引起死锁。
    *   **2) 不可抢占性资源 (Non-preemptible Resources)**
        *   **定义**：一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。
        *   **示例**：磁带机、打印机、刻录机（中途停止会导致数据损坏或操作失败）。
        *   **注意**：对这类资源的竞争是死锁产生的主要原因之一。

**3.5.2 计算机系统中的死锁**
死锁的起因通常源于多个进程对资源的争夺，既可能发生在对不可抢占资源的争夺中，也可能发生在对可消耗资源的争夺中。

3.  **竞争不可抢占性资源引起死锁**
    *   **原因**：系统所拥有的不可抢占资源数量不足以满足多个进程运行的需求，使得进程在运行过程中因争夺资源而陷入僵局。
    * ![[image-47.png]]
    *   **示例**：两个进程P1和P2都准备写两个文件F1和F2（均为不可抢占资源）。
        *   P1操作顺序：`Open(F1, w); Open(F2, w); ... Close(F2); Close(F1);`
        *   P2操作顺序：`Open(F2, w); Open(F1, w); ... Close(F1); Close(F2);`
        *   **死锁情景**：若P1先打开F1，同时P2打开F2。之后P1请求打开F2，因F2已被P2占用而阻塞；P2请求打开F1，因F1已被P1占用而阻塞。两者互相等待对方释放资源，形成死锁。
        *   **资源分配图**：可用圆圈代表进程，方框代表资源类。从进程到资源的边表示请求，从资源到进程的边表示分配。若图中出现环路，则可能已进入死锁状态。

4.  **竞争可消耗资源引起死锁**
	* ![[image-48.png]]
    *   **原因**：进程间通信时，若接收与发送消息的顺序安排不当，可能导致各进程都在等待接收对方的消息，而对方的消息又依赖于本进程先发送其他消息，从而形成死锁。
    *   **示例**：三个进程P1, P2, P3进行消息通信（m1, m2, m3为可消耗的消息资源）。
        *   P1: `send(P2, m1); receive(P3, m3);`
        *   P2: `send(P3, m2); receive(P1, m1);`
        *   P3: `send(P1, m3); receive(P2, m2);`
        *   **无死锁情景**：若所有进程都先执行`send`操作，再执行`receive`操作，则通信可顺利进行。
        *   **死锁情景**：若所有进程都先执行`receive`操作，则P1等待P3发送m3，P2等待P1发送m1，P3等待P2发送m2，形成循环等待，导致死锁。

5.  **进程推进顺序不当引起死锁**
    *   **原因**：进程在运行过程中，对资源进行申请和释放的顺序不合理，可能导致死锁。
    *   **示例**：系统中只有一台打印机R1和一台磁带机R2，供进程P1和P2共享。
        *   **合法推进顺序（安全）**：
            *   P1: `Request(R1) -> Request(R2) -> Release(R1) -> Release(R2)`
            *   P2: `Request(R2) -> Request(R1) -> Release(R2) -> Release(R1)`
            在这种情况下，尽管可能存在等待，但总能找到一个推进顺序使所有进程完成。
        *   **非法推进顺序（不安全，可能导致死锁）**：
            若P1请求并获得R1，同时P2请求并获得R2。之后P1请求R2（因被P2占用而阻塞），P2请求R1（因被P1占用而阻塞）。两者形成死锁。
            这种不安全的推进顺序使得系统进入不安全区D（如图3-14所示）。
	         ![[image-49.png]]

**3.5.3 死锁的定义、必要条件和处理方法**

6.  **死锁的定义**
    *   如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的（Deadlock）。
    *   这意味着这组进程都无法继续执行，它们所占有的资源也无法释放，形成永久的等待。

7.  **产生死锁的必要条件**
    死锁的发生必须同时具备以下四个条件，只要其中任一条件不成立，死锁就不会发生：
    *   **(1) 互斥条件 (Mutual Exclusion Condition)**：进程对所分配到的资源进行排它性使用，即在一段时间内某资源只能被一个进程占用。如果其他进程请求该资源，则请求进程只能等待，直至占有该资源的进程用毕释放。
    *   **(2) 请求和保持条件 (Hold and Wait Condition)**：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占用，此时请求进程被阻塞，但对自己已获得的资源保持不放。
    *   **(3) 不可抢占条件 (No Preemption Condition)**：进程已获得的资源在未使用完之前，不能被其他进程强行夺走，只能在进程使用完毕后由自己释放。
    *   **(4) 循环等待条件 (Circular Wait Condition)**：在发生死锁时，必然存在一个进程—资源的循环链，即进程集合{P0, P1, P2, ..., Pn}中的P0正在等待P1占用的资源，P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

8.  **处理死锁的方法**
    目前处理死锁的方法可归结为四种：
    *   **(1) 预防死锁 (Deadlock Prevention)**：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个，从而防止死锁的发生。这是一种较简单和直观的事先预防方法。
    *   **(2) 避免死锁 (Deadlock Avoidance)**：同样属于事先预防策略，但并非事先采取各种限制措施破坏死锁产生的必要条件，而是在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。
    *   **(3) 检测死锁 (Deadlock Detection)**：不事先采取任何限制性措施，而是允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取适当措施加以清除。
    *   **(4) 解除死锁 (Deadlock Recovery / Resolution)**：当检测到系统中已发生死锁时，须采取相应措施，将进程从死锁状态中解脱出来。常用的方法是撤销一些进程，回收它们的资源，并将这些资源分配给已处于阻塞状态的进程，使其能继续运行。
    *   **方法对比**：从(1)到(4)，对死锁的防范程度逐渐减弱，但对应的是资源利用率的提高以及进程因资源因素而阻塞的频度下降（即并发程度提高）。