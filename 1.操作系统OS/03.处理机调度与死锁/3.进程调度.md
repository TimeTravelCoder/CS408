**引言**
*   进程调度是OS中必不可少的一种调度。
*   在三种类型的OS中（批处理、分时、实时），都无一例外地配置了进程调度。
*   进程调度也是对系统性能影响最大的一种处理机调度。
*   因此，有关进程调度的算法也较多。

**3.3.1 进程调度的任务、机制和方式**

1.  **进程调度的任务**
    *   主要有三项：
        *   **(1) 保存处理机的现场信息 (Save Context):**
            *   在进行调度时，首先需要保存当前进程的处理机的现场信息。
            *   例如：程序计数器 (Program Counter)、多个通用寄存器 (General-Purpose Registers) 中的内容等。
        *   **(2) 按某种算法选取进程 (Select Process):**
            *   调度程序按某种算法从就绪队列中选取一个进程。
            *   将其状态改为运行状态。
            *   并准备把处理机分配给它。
        *   **(3) 把处理器分配给进程 (Dispatch Process):**
            *   由分派程序 (Dispatcher) 把处理器分配给该进程。
            *   此时需要将选中进程的进程控制块 (PCB) 内有关处理机现场的信息装入处理器相应的各个寄存器中。
            *   把处理器的控制权交予该进程，让它从上次的断点处恢复运行。

2.  **进程调度机制**
    *   为了实现进程调度，在进程调度机制中，应具有如下三个基本部分：
	    * ![[image-36.png]]
        *   **(1) 排队器 (Queuer):**
            *   **目的**: 提高进程调度的效率。
            *   **功能**: 事先将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便调度程序能最快地找到它。
            *   **触发**: 以后每当有一个进程转变为就绪状态时，排队器便将它插入到相应的就绪队列。
        *   **(2) 分派器 (Dispatcher):**
            *   **功能**: 依据进程调度程序所选定的进程，将其从就绪队列中取出，然后进行从分派器到新选出进程间的上下文切换，将处理机分配给新选出的进程。
        *   **(3) 上下文切换器 (Context Switcher):**
            *   **发生时机**: 在对处理机进行切换时，会发生两对上下文的切换操作。
            *   **第一对上下文切换**:
                *   OS将保存当前进程的上下文（即把当前进程的处理机寄存器内容保存到该进程的PCB内的相应单元）。
                *   再装入分派程序的上下文，以便分派程序运行。
            *   **第二对上下文切换**:
                *   移出分派程序的上下文。
                *   而把新选进程的CPU现场信息装入到处理机的各个相应寄存器中，以便新选进程运行。
            *   **开销**: 上下文切换时，需要执行大量的 `load` 和 `store` 等操作指令来保存寄存器的内容。即使是现代计算机，每一次上下文切换所花费的时间大约可执行上千条指令。
            *   **硬件优化**: 现在已有靠硬件实现的方法来减少上下文切换时间。一般采用两组（或多组）寄存器，其中一组寄存器供处理机在系统态时使用，另一组供应用程序使用。在这样的条件下，上下文切换只需改变指针，使其指向当前寄存器组即可。

3.  **进程调度方式**
    *   早期采用的**非抢占方式**存在很大局限性，很难满足交互性作业和实时任务的需求。因此，在进程调度中又引入了**抢占方式**。
    *   **1) 非抢占方式 (Nonpreemptive Mode):**
        *   **定义**: 一旦把处理机分配给某进程后，就一直让它运行下去，决不会因为时钟中断或任何其它原因去抢占当前正在运行进程的处理机。
        *   **调度时机 (引起进程调度的因素)**:
            *   ① 正在执行的进程运行完毕，或因发生某事件而使其无法再继续运行。
            *   ② 正在执行中的进程因提出I/O请求而暂停执行。
            *   ③ 在进程通信或同步过程中，执行了某种原语操作，如 `Block` 原语。
        *   **优点**: 实现简单，系统开销小。
        *   **适用场景**: 适用于大多数的批处理系统。
        *   **缺点**: 不能用于分时系统和大多数实时系统。
    *   **2) 抢占方式 (Preemptive Mode):**
        *   **定义**: 允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。
        *   **广泛应用原因**:
            *   **批处理系统**: 防止一个长进程长时间地占用处理机，确保处理机能为所有进程提供更为公平的服务。
            *   **分时系统**: 只有采用抢占方式才有可能实现人机交互。
            *   **实时系统**: 抢占方式能满足实时任务的需求。
        *   **缺点**: 比较复杂，所需付出的系统开销也较大。
        *   **“抢占”原则**: “抢占”不是一种任意性行为，必须遵循一定的原则。主要原则有：
            *   **① 优先权原则 (Priority Principle):** 允许优先级高的新到进程抢占当前进程的处理机。即当有新进程到达时，如果它的优先级比正在执行进程的优先级高，则调度程序将剥夺当前进程的运行，将处理机分配给新到的优先权高的进程。
            *   **② 短进程优先原则 (Shortest Process Next Principle):** 允许新到的短进程可以抢占当前长进程的处理机。即当新到达的进程比正在执行的进程（尚须运行的时间）明显短时，将处理机分配给新到的短进程。
            *   **③ 时间片原则 (Time Slice Principle):** 各进程按时间片轮转运行时，当正在执行的进程的一个时间片用完后，便停止该进程的执行而重新进行调度。

**3.3.2 轮转调度算法 (Round Robin, RR)**
*   **背景**: 在分时系统中，最简单也是较常用的是基于时间片的轮转调度算法。
*   **公平性**: 采取了非常公平的处理机分配方式，即让就绪队列上的每个进程每次仅运行一个时间片。
*   **分配比例**: 如果就绪队列上有n个进程，则每个进程每次大约都可获得1/n的处理机时间。

1.  **轮转法的基本原理**
    *   系统将所有的就绪进程按FCFS策略排成一个就绪队列。
    *   系统可设置每隔一定时间（如30ms）便产生一次中断，去激活进程调度程序进行调度。
    *   调度程序把CPU分配给队首进程，并令其执行一个时间片。
    *   当它运行完毕后（指一个时间片结束），又把处理机分配给就绪队列中新的队首进程，也让它执行一个时间片。
    *   这样，就可以保证就绪队列中的所有进程在确定的时间段内，都能获得一个时间片的处理机时间。

2.  **进程切换时机**
    *   可分为两种情况：
        *   **① 时间片未用完，进程已完成**: 正在运行的进程便已经完成，就立即激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。
        *   **② 时间片用完，进程未完成**: 计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。

3.  **时间片大小的确定**
	* ![[image-37.png]]
	* ![[image-38.png]]
    *   时间片的大小对系统性能有很大的影响。
    *   **时间片过小**:
        *   有利于短作业，因为它能在该时间片内完成。
        *   但会导致频繁地执行进程调度和进程上下文的切换，增加系统开销。
    *   **时间片过长**:
        *   如果时间片长到使每个进程都能在一个时间片内完成，RR算法便退化为FCFS算法。
        *   无法满足短作业和交互式用户的需求。
    *   **较为可取的时间片大小**: 略大于一次典型的交互所需要的时间，使大多数交互式进程能在一个时间片内完成，从而可以获得很小的响应时间。

**3.3.3 优先级调度算法**
*   **背景**: 时间片轮转调度算法中，隐含假设系统中所有进程的紧迫性是相同的，但实际情况并非如此。
*   **引入目的**: 为了能满足实际情况的需要，在进程调度算法中引入优先级，形成优先级调度算法。

2.  **优先级调度算法的类型**
    *   **核心思想**: 把处理机分配给就绪队列中优先级最高的进程。
    *   可进一步分为两种：
        *   **(1) 非抢占式优先级调度算法 (Nonpreemptive Priority Scheduling):**
            *   **规定**: 一旦把处理机分配给就绪队列中优先级最高的进程后，该进程便一直执行下去直至完成，或者因该进程发生某事件而放弃处理机时，系统方可将处理机重新分配给另一优先级最高的进程。
        *   **(2) 抢占式优先级调度算法 (Preemptive Priority Scheduling):**
            *   **规定**: 把处理机分配给优先级最高的进程，使之执行。但在其执行期间，只要出现了另一个其优先级更高的进程，调度程序就将处理机分配给新到的优先级最高的进程。
            *   **触发**: 每当系统中出现一个新的就绪进程i时，就将其优先级Pᵢ与正在执行的进程j的优先级Pⱼ进行比较。
                *   如果 Pᵢ ≤ Pⱼ，原进程Pⱼ便继续执行。
                *   如果 Pᵢ > Pⱼ，则立即停止Pⱼ的执行，进行进程切换，使i进程投入执行。
            *   **应用场景**: 常用于对实时性要求较高的系统中。

3.  **优先级的类型**
    *   优先级调度算法的关键在于：应如何确定进程的优先级，以及确定是使用静态优先级还是动态优先级。
    *   **1) 静态优先级 (Static Priority):**
        *   **定义**: 在创建进程时确定的，在进程的整个运行期间保持不变。
        *   **表示**: 利用某一范围内的一个整数来表示，例如0~255中的某一整数，又把该整数称为优先数。
        *   **确定依据 (三个方面)**:
            *   **(1) 进程类型**: 通常系统进程（如接收进程、对换进程）的优先级高于一般用户进程的优先级。
            *   **(2) 进程对资源的需求**: 对资源要求少的进程应赋予较高的优先级。
            *   **(3) 用户要求**: 根据进程的紧迫程度及用户所付费用的多少确定优先级。
        *   **优点**: 简单易行，系统开销小。
        *   **缺点**: 不够精确，可能会出现优先级低的进程长期没有被调度的情况（饥饿）。
    *   **2) 动态优先级 (Dynamic Priority):**
        *   **定义**: 在创建进程之初，先赋予其一个优先级，然后其值随进程的推进或等待时间的增加而改变，以便获得更好的调度性能。
        *   **示例**:
            *   可以规定在就绪队列中的进程随其等待时间的增长，使其优先级相应提高。
                *   若所有进程都具有相同优先级初值，则最先进入就绪队列的进程会因其优先级变得最高，而优先获得处理机（相当于FCFS算法）。
                *   若所有就绪进程具有各不相同的优先级初值，那么对于优先级初值低的进程，在等待了足够的时间后，也可以获得处理机。
            *   当采用抢占式调度方式时，若再规定当前进程的优先级随运行时间的推移而下降，则可防止一个长作业长期地垄断处理机。

**3.3.4 多队列调度算法**
*   **背景**: 前述各种调度算法，尤其在应用于进程调度时，由于系统中仅设置一个进程的就绪队列，即低级调度算法是固定的、单一的，无法满足系统中不同用户对进程调度策略的不同要求。
*   **多处理机系统中的缺点**: 单一调度策略实现机制的缺点更显突出。
*   **目的**: 多级队列调度算法能在一定程度上弥补这一缺点。
*   **核心思想**:
    *   将系统中的进程就绪队列从一个拆分为若干个。
    *   将不同类型或性质的进程固定分配在不同的就绪队列。
    *   不同的就绪队列采用不同的调度算法。
    *   一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。
*   **优点**:
    *   **灵活性**: 由于设置多个就绪队列，因此对每个就绪队列就可以实施不同的调度算法，系统针对不同用户进程的需求，很容易提供多种调度策略。
    *   **多处理机系统适用性**:
        *   很方便为每个处理机设置一个单独的就绪队列。这样，不仅对每个处理机的调度可以实施各自不同的调度策略。
        *   而且对于一个含有多个线程的进程而言，可以根据其要求将其所有线程分配在一个就绪队列，全部在一个处理机上运行。
        *   再者，对于一组需要相互合作的进程或线程而言，也可以将它们分配到一组处理机所对应的多个就绪队列，使得它们能同时获得处理机并行执行。

**3.3.5 多级反馈队列调度算法 (Multilevel Feedback Queue Scheduling)**
*   **背景**: 前面介绍的各种用于进程调度的算法都有一定的局限性。
    *   如果未指明进程长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。
*   **优点**:
    *   不必事先知道各种进程所需的执行时间。
    *   还可以较好地满足各种类型进程的需要。
*   **公认地位**: 目前公认的一种较好的进程调度算法。

1.  **调度机制**
	* ![[image-39.png]]
    *   可描述如下：
        *   **(1) 设置多个就绪队列:**
            *   在系统中设置多个就绪队列，并为每个队列赋予不同的优先级。
            *   第一个队列的优先级最高，第二个次之，其余队列的优先级逐个降低。
            *   该算法为不同队列中的进程所赋予的执行时间片的大小也各不相同。在优先级愈高的队列中，其时间片就愈小。
            *   例如：第二个队列的时间片要比第一个的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个的时间片长一倍。
        *   **(2) 每个队列都采用FCFS算法:**
            *   当新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度。
            *   当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。
            *   否则（即它在一个时间片结束时尚未完成），调度程序将其转入第二队列的末尾等待调度。
            *   如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，依此类推。
            *   当进程最后被降到第 n 队列后，在第 n 队列中便采取按 RR 方式运行。
        *   **(3) 按队列优先级调度:**
            *   调度程序首先调度最高优先级队列中的诸进程运行。
            *   仅当第一队列空闲时才调度第二队列中的进程运行；换言之，仅当第 1~(i-1)所有队列均空时，才会调度第 i 队列中的进程运行。
            *   如果处理机正在第 i 队列中为某进程服务时又有新进程进入任一优先级较高的队列，则此时须立即把正在运行的进程放回到第 i 队列的末尾，而把处理机分配给新到的高优先级进程。

2.  **调度算法的性能**
    *   如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能较好地满足各种类型用户的需要。
    *   **(1) 终端型用户 (Interactive User):**
        *   提交的作业多属于交互型作业，通常较小。
        *   系统只要能使这些作业在第一队列规定的时间片内完成，便可使终端型用户感到满意。
    *   **(2) 短批处理作业用户 (Short Batch Job User):**
        *   对于这类作业，如果可在第一队列中执行完成，便获得与终端型作业一样的响应时间。
        *   对于稍长的短作业，也只需在第二和第三队列各执行一时间片完成，其周转时间仍然较短。
    *   **(3) 长批处理作业用户 (Long Batch Job User):**
        *   对于长作业，它将依次在第 1, 2, …, n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。

**3.3.6 基于公平原则的调度算法**
*   **背景**: 以上介绍的几种调度算法所保证的只是优先运行（如优先级算法是优先级最高的作业优先运行），但并不保证作业占用了多少处理机时间。另外也未考虑到调度的公平性。
*   本小节将介绍两种相对公平的调度算法。

1.  **保证调度算法 (Guaranteed Scheduling)**
    *   **核心思想**: 向用户所做出的保证**不是**优先运行，而是**明确的性能保证**，该算法可以做到调度的公平性。
    *   **一种较容易实现的性能保证**: 处理机分配的公平性。
    *   **公平性定义**: 如果在系统中有 n 个相同类型的进程同时运行，为公平起见，须保证每个进程都获得相同的处理机时间 1/n。
    *   **实施要求 (系统功能)**:
        *   **(1) 跟踪计算每个进程自创建以来已经执行的处理时间。**
        *   **(2) 计算每个进程应获得的处理机时间** (即自创建以来的时间除以n)。
        *   **(3) 计算进程获得处理机时间的比率** (即进程实际执行的处理时间和应获得的处理机时间之比)。
        *   **(4) 比较各进程获得处理机时间的比率。** (如进程A的比率最低，为0.5，而进程B为0.8，进程C为1.2等)
        *   **(5) 调度程序应选择比率最小的进程将处理机分配给它**，并让该进程一直运行，直到超过最接近它的进程比率为止。