**引言**
预防死锁是处理死锁问题的一种基本策略。其核心思想是通过破坏产生死锁的四个必要条件中的一个或几个，从而防止系统进入死锁状态。由于互斥条件对于许多资源（如打印机、共享文件）来说是其固有属性，通常难以改变，因此预防死锁主要着眼于破坏后三个必要条件：“请求和保持”条件、“不可抢占”条件和“循环等待”条件。
**3.6.1 破坏“请求和保持”条件**
为了破坏“请求和保持”条件，系统必须保证：当一个进程在请求资源时，它不能持有任何不可抢占的资源。可以通过以下两种协议来实现：
1.  **第一种协议（一次性申请所有资源）**
    *   **规定**：所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。
    *   **运作机制**：
        *   如果系统有足够的资源分配给某进程，便一次性地将所有所需资源分配给它。
        *   如果系统资源不足，不能满足进程的所有请求，则即使该进程所需的其他资源都空闲，也不为其分配任何资源，让该进程等待。
    *   **效果**：
        *   进程在运行期间不会再提出新的资源请求，从而破坏了“请求”条件。
        *   进程在等待资源期间未占有任何资源，从而破坏了“保持”条件。
    *   **优点**：
        *   简单易行。
        *   能够有效地预防死锁。
    *   **缺点**：
        *   **资源严重浪费**：进程在开始运行时就占用了其整个运行周期内可能需要的所有资源，但其中一些资源可能仅在运行的初期或末期才使用，甚至根本不使用（如错误处理分支中的资源），导致资源在大部分时间内处于闲置状态，降低了资源利用率。
        *   **进程饥饿现象**：对于需要较多资源的进程，或者其所需的某些资源长时间被其他进程占用时，该进程可能因无法一次性获得所有资源而长时间等待，导致饥饿。
2.  **第二种协议（分阶段申请和释放资源）**
    *   **规定**：允许一个进程只获得运行初期所需的资源后便开始运行。在运行过程中，逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。
    *   **运作机制**：进程将任务分解为若干阶段，在每个阶段开始前申请该阶段所需的资源，在该阶段结束后释放不再需要的资源。
    *   **示例**：一个进程任务是先将数据从磁带复制到磁盘文件，然后对磁盘文件排序，最后将结果打印。
        *   采用第一种协议：进程开始时就需申请磁带机、磁盘文件空间和打印机。打印机在最后才使用，会长时间闲置。
        *   采用第二种协议：
            *   阶段一：申请磁带机和磁盘文件空间，进行数据复制。
            *   阶段一结束：释放磁带机。
            *   阶段二：(已持有磁盘文件空间) 进行排序。
            *   阶段二结束：申请打印机，打印结果。
            *   阶段三结束：释放磁盘文件空间和打印机。
    *   **效果**：相较于第一种协议，在一定程度上改善了资源利用率，减少了进程饥饿的可能性。
    *   **优点**：
        *   资源利用率有所提高。
        *   减少了进程等待时间。
    *   **缺点**：
        *   实现相对复杂，需要程序员预先规划好资源的申请和释放时机。
        *   仍然可能存在某些阶段资源被长时间占用的情况。
        *   对于难以预知资源需求的进程，此方法不适用。
**3.6.2 破坏“不可抢占”条件**
为了破坏“不可抢占”条件，协议规定：当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。
*   **运作机制**：
    *   如果进程P请求的资源R被其他进程占用，则系统可以尝试抢占进程P已经占有的资源，将这些资源分配给其他需要的进程。
    *   或者，进程P主动释放其已占有的资源。
    *   当进程P需要再次运行时，它需要重新申请之前被抢占或主动释放的资源以及新请求的资源。
*   **效果**：进程占有的资源可能会被暂时释放或被抢占，从而破坏了“不可抢占”条件。
*   **实现**：
    *   **隐式抢占**：当一个进程请求新资源得不到满足时，它必须释放所有已占有的资源。
    *   **显式抢占**：如果一个高优先级进程请求已被低优先级进程占有的资源，系统可以剥夺低优先级进程的资源。
*   **缺点**：
    *   **实现复杂，代价高昂**：例如，打印机这类资源被抢占后，可能导致前一阶段的工作失效，需要从头开始。保存和恢复进程状态的开销也很大。
    *   **可能导致进程反复申请和释放资源**：如果一个进程频繁地因资源不足而被抢占或主动释放资源，会导致其执行被无限期推迟，降低系统吞吐量，增加系统开销。
    *   **适用范围有限**：仅适用于状态易于保存和恢复的资源，如CPU、内存。对于打印机、磁带机等设备，抢占的代价通常过高。
**3.6.3 破坏“循环等待”条件**
为了破坏“循环等待”条件，可以采用**顺序资源分配法**。
*   **规定**：对系统所有资源类型进行线性排序，并为每一种类型赋予一个唯一的序号。所有进程对资源的请求必须严格按照序号递增的顺序进行。
*   **运作机制**：
    *   设 R = (R1, R2, ..., Rm) 为资源类型的集合，函数 F 为资源类型到整数序号的映射，例如 F(磁带机)=1, F(磁盘驱动器)=5, F(打印机)=12。
    *   进程在开始时，可以请求序号较低的资源。
    *   当进程要请求新的资源 Rj 时，当且仅当 F(Rj) > F(Ri) (其中 Ri 是该进程当前已占有的、序号最高的资源)，才允许请求。
    *   如果进程需要请求一个序号较低的资源，它必须首先释放所有具有相同或更高序号的已占有资源，然后才能申请该低序号资源。
    *   如果需要多个同类资源单元，必须一次性请求。
*   **效果**：在资源分配图中，由于资源请求总是从低序号指向高序号，不可能形成环路，从而破坏了“循环等待”条件。
*   **优点**：
    *   相较于前两种策略，资源利用率和系统吞吐量有明显改善。
*   **缺点**：
    *   **资源序号分配不合理**：为系统中各类资源规定一个相对稳定的序号是困难的，这个序号需要考虑到大多数作业实际使用这些资源的顺序。
    *   **限制新类型设备的增加**：新类型设备的加入可能会打乱原有的序号分配。
    *   **限制用户编程的灵活性**：用户编程时必须遵循规定的资源申请顺序，即使实际逻辑上先用高序号资源再用低序号资源更合理，也不得不调整，增加了编程的复杂性和不便。
    *   **可能造成资源浪费**：即使某个低序号资源仅在作业后期才使用，也必须先申请，导致资源闲置。

