**习题参考答案与思路**

**关于 3.1 处理机调度的层次和调度算法的目标**

1.  **高级调度与低级调度的主要任务是什么？为什么要引入中级调度？**
    *   **高级调度（作业调度/长程调度）**：主要任务是根据某种算法，决定将外存上处于后备队列中的哪些作业调入内存，为它们创建进程、分配必要的资源，并将它们放入就绪队列。它控制进入系统的作业数量和类型，影响系统的并发度和吞吐量。主要用于多道批处理系统。
    *   **低级调度（进程调度/短程调度）**：主要任务是根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机分配给被选中的进程。它是最基本、最频繁的调度，在多道批处理、分时和实时系统中都必须配置。
    *   **引入中级调度（内存调度/中程调度）**：主要目的是提高内存利用率和系统吞吐量。当内存紧张或有更高优先级的进程需要运行时，中级调度可以将那些暂时不能运行的进程（如阻塞态或低优先级就绪态进程）从内存调至外存（挂起），释放内存空间。当这些进程具备运行条件且内存有空闲时，再将它们从外存调回内存（激活），并修改其状态为就绪态。它平衡了系统负载，防止了系统颠簸。

2.  **处理机调度算法的共同目标是什么？批处理系统的调度目标又是什么？**
    *   **共同目标**：
        *   **资源利用率高**：使CPU和其他资源尽可能保持忙碌状态，减少空闲时间。
        *   **公平性**：使诸进程都获得合理的CPU时间，不发生进程饥饿现象（但公平性是相对的，不同类型进程可能服务不同）。
        *   **平衡性**：使系统中的CPU和各种外部设备都能经常处于忙碌状态，保持系统资源使用的平衡，充分利用系统资源。
        *   **策略强制执行**：对所制订的策略（如安全策略）必须准确执行，即使可能造成某些工作的延迟。
    *   **批处理系统的调度目标**：
        *   **平均周转时间短**：从作业提交给系统开始，到作业完成为止的时间间隔尽可能短。
        *   **系统吞吐量高**：单位时间内系统所完成的作业数尽可能多。
        *   **处理机利用率高**：使CPU尽可能处于忙碌状态。

**关于 3.2 作业与作业调度**

3.  **何谓作业、作业步和作业流？**
    *   **作业 (Job)**：用户在一次算题或一个事务处理过程中要求计算机系统所做工作的集合，它包括用户程序、所需的数据及命令等。在批处理系统中，作业是用户提交给系统的一个相对独立的工作单元。
    *   **作业步 (Job Step)**：一个作业在运行期间，通常需要经过若干个相对独立、又相互关联的顺序加工步骤才能得到结果。每一个这样的加工步骤称为一个作业步（如编译、链接、运行）。
    *   **作业流 (Job Stream)**：若干个作业形成的一个序列，系统按照这个序列的顺序对作业进行处理。在早期的批处理系统中，作业流通常由操作员手动组织。

4.  **在什么情况下需要使用作业控制块JCB，其中包含了哪些内容？**
    *   **情况**：在多道批处理系统中，为了管理和调度进入系统的作业，系统为每个作业都设置了一个作业控制块 (JCB)。JCB 是作业在系统中存在的标志。
    *   **内容**：通常包含：
        *   **作业标识**：唯一的作业名或编号。
        *   **用户名称/账号**：标识提交作业的用户。
        *   **作业类型**：如CPU繁忙型、I/O繁忙型、批量型、终端型等。
        *   **作业状态**：如后备状态、运行状态、完成状态。
        *   **调度信息**：如优先级、作业已等待时间、预计运行时间等。
        *   **资源需求**：如预计运行时间、要求内存大小、所需外设类型及数量等。
        *   **资源使用情况**：记录作业已使用的CPU时间、内存等。
        *   指向作业说明书、程序和数据的指针。

5.  **在作业调度中应如何确定接纳多少个作业和接纳哪些作业？**
    *   **接纳多少个作业（多道程序度）**：
        *   取决于系统的资源情况（如内存大小、CPU处理能力）和对系统性能的要求。
        *   目标是使系统资源得到充分利用，同时避免因作业过多导致系统颠簸或平均周转时间过长。
        *   需要根据系统规模、运行速度、作业大小等因素综合考虑。
    *   **接纳哪些作业（调度算法）**：
        *   取决于所采用的作业调度算法。常见的算法有：
            *   **先来先服务 (FCFS)**：按作业到达的先后顺序选择。
            *   **短作业优先 (SJF)**：选择预计运行时间最短的作业。
            *   **优先级调度 (PSA)**：选择优先级最高的作业。
            *   **高响应比优先 (HRRN)**：选择响应比（(等待时间+要求服务时间)/要求服务时间）最高的作业。

6.  **为什么要引入高响应比优先调度算法？它有何优点？**
    *   **原因**：
        *   FCFS 算法对短作业不利，可能导致短作业等待时间过长。
        *   SJF 算法对长作业不利，可能导致长作业饥饿。
        *   高响应比优先调度算法试图综合考虑作业的等待时间和运行时间，以寻求一个较好的平衡。
    *   **优点**：
        *   **对短作业有利**：当等待时间相同时，要求服务时间越短，响应比越高，短作业能较早被调度。
        *   **兼顾长作业**：长作业等待时间越长，其响应比也会随之增高，最终也能获得调度，避免了饥饿现象。
        *   **性能较好**：在周转时间和平均等待时间方面通常表现优于 FCFS，且避免了 SJF 的饥饿问题。

**关于 3.3 进程调度**

7.  **试说明低级调度的主要功能。**
    *   **保存处理机的现场信息**：当一个进程要让出CPU时，保存其在CPU寄存器中的内容（如程序计数器、通用寄存器等）到其进程控制块 (PCB) 中。
    *   **按某种算法选取进程**：从就绪队列中按照一定的调度算法选择一个进程，准备将CPU分配给它。
    *   **把处理器分配给进程**：将选中的进程的现场信息从其PCB中恢复到CPU的相应寄存器中，并将CPU的控制权交给该进程，使其从上次断点处开始（或首次）运行。这个过程也称为分派 (Dispatch)。

8.  **在抢占调度方式中，抢占的原则是什么？**
    *   **优先权原则**：允许优先级高的新到进程抢占当前正在执行的低优先级进程的处理机。
    *   **短进程优先原则**：允许新到达的、预计运行时间明显短于当前正在执行进程剩余运行时间的短进程，抢占当前长进程的处理机。
    *   **时间片原则**：在时间片轮转调度中，当一个进程的时间片用完后，即使该进程尚未完成，也必须让出处理机，由调度程序分配给就绪队列中的下一个进程。

**关于 3.4 实时调度**

19. **为什么在实时系统中，要求系统(尤其是CPU)具有较强的处理能力？**
    *   实时系统对任务的响应时间和截止时间有严格要求。
    *   如果CPU处理能力不足，可能导致任务无法在规定的截止时间内完成，从而引发严重后果（尤其是在硬实时系统中）。
    *   较强的CPU处理能力可以：
        *   **减少任务的执行时间**，更容易满足截止时间要求。
        *   **处理更多的并发任务**，提高系统的响应能力。
        *   **减少任务切换和调度的开销占比**，提高有效工作时间。
        *   为处理突发事件和异常情况提供裕量。

20. **按调度方式可将实时调度算法分为哪几种？**
    根据抢占发生的时间不同，抢占式实时调度算法可以分为：
    *   **基于时钟中断的抢占式优先级调度算法**：在某实时任务到达后，如果其优先级高于当前任务，系统并不立即抢占，而是等到下一个时钟中断到来时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先级任务。
    *   **立即抢占的抢占式优先级调度算法**：一旦出现外部中断，只要当前任务未处于临界区，便能立即剥夺其执行，将处理机分配给请求中断的紧迫任务。这种方式响应更及时。

21. **什么是最早截止时间优先 (EDF) 调度算法？举例说明之。**
    *   **定义**：该算法根据任务的截止时间来确定任务的优先级。任务的截止时间愈早，其优先级愈高，从而使其能优先获得调度。
    *   **类型**：既可用于非抢占式调度，也可用于抢占式调度。
    *   **举例 (非抢占式，非周期任务)**：
        假设有4个非周期任务T1, T2, T3, T4，到达时间(Arrival)、执行时间(Execution)和截止时间(Deadline)如下：
        | Task | Arrival | Execution | Deadline |
        |------|---------|-----------|----------|
        | T1   | 0       | 3         | 5        |
        | T2   | 1       | 2         | 4        |
        | T3   | 2       | 1         | 3        |
        | T4   | 3       | 4         | 8        |

        调度顺序 (EDF 非抢占):
        1.  t=0: T1到达 (Deadline=5)。调度T1。
        2.  t=1: T2到达 (Deadline=4)。T1仍在执行。
        3.  t=2: T3到达 (Deadline=3)。T1仍在执行。
        4.  t=3: T1完成。就绪队列中有T2(D=4), T3(D=3)。T4到达(D=8)。
            选择T3 (Deadline最早)。调度T3。
        5.  t=4: T3完成。就绪队列中有T2(D=4), T4(D=8)。
            选择T2。调度T2。
        6.  t=6: T2完成。就绪队列中有T4(D=8)。
            调度T4。
        7.  t=10: T4完成。
        最终执行序列：T1, T3, T2, T4。
        *课本图示例子 `![[image-13.png]]` 中的数据可能不同，请参照该图的具体数据进行分析。*

22. **什么是最低松弛度优先 (LLF) 调度算法？举例说明之。**
    *   **定义**：该算法根据任务的紧急（或松弛）程度来确定任务的优先级。任务的松弛度越小，其优先级越高。
    *   **松弛度计算**：`松弛度 = (必须完成时间 - 当前时间) - 剩余执行时间`。
    *   **举例 (周期任务，抢占式)**：
        任务A：周期20ms，执行时间10ms。
        任务B：周期50ms，执行时间25ms。
        (具体调度过程参照课本图3-9的详细步骤，因为LLF是动态计算松弛度的，每个时间点都可能重算并抢占)
        *   **t=0**:
            *   A1: 必须完成时间=20, 剩余执行=10. 松弛度 = (20-0)-10 = 10ms
            *   B1: 必须完成时间=50, 剩余执行=25. 松弛度 = (50-0)-25 = 25ms
            调度A1。
        *   **t=10 (A1完成)**: A1执行完毕。
            *   A2 (新周期): 必须完成时间=40 (20+20), 剩余执行=10. 松弛度 = (40-10)-10 = 20ms
            *   B1 (未执行): 必须完成时间=50, 剩余执行=25. 松弛度 = (50-10)-25 = 15ms
            调度B1。
        *   **t=20 (B1已执行10ms，A2到达其周期开始时间)**:
            *   A2: 必须完成时间=40, 剩余执行=10. 松弛度 = (40-20)-10 = 10ms
            *   B1: 必须完成时间=50, 剩余执行=15 (25-10). 松弛度 = (50-20)-15 = 15ms
            调度A2 (松弛度更小)，抢占B1。
        * ... 以此类推。

23. **何谓“优先级倒置”现象，可采取什么方法来解决？**
    *   **优先级倒置 (Priority Inversion)**：在采用基于优先级的抢占式调度策略的系统中，当一个高优先级进程P_H试图访问一个已被低优先级进程P_L占有的临界资源时，P_H会阻塞。此时，如果出现一个中等优先级进程P_M，且P_M的优先级高于P_L但低于P_H，P_M会抢占P_L的处理机。结果导致高优先级进程P_H反而要等待中等优先级进程P_M和低优先级进程P_L都执行完毕（P_L释放资源后P_H才能运行），有效地使P_H的优先级降到了P_M和P_L之下。
    *   **解决方法**：
        *   **规定进入临界区的进程不可被抢占**：简单，但若临界区过长，会影响高优先级进程的响应。
        *   **优先级继承 (Priority Inheritance)**：当一个高优先级进程P_H等待一个被低优先级进程P_L占有的临界资源时，暂时将P_L的优先级提升到P_H的优先级，使得P_L能尽快完成临界区代码并释放资源，从而P_H能尽快获得资源。P_L退出临界区后恢复其原有优先级。
        *   **优先级天花板协议 (Priority Ceiling Protocol)**：为每个临界资源设置一个优先级上限（天花板），等于可能访问该资源的所有进程中的最高优先级。当一个进程P请求进入由信号量S保护的临界区时，只有当P的优先级高于当前占有任何信号量的所有其他进程的优先级天花板时，才允许P进入。进入后，P的优先级会提升到S的优先级天花板。

**关于 3.5 死锁概述**

24. **试分别说明可重用资源和可消耗资源的性质。**
    *   **可重用资源**：
        *   **互斥使用**：每个单元同一时间只能分配给一个进程。
        *   **请求-使用-释放**：进程按此顺序使用资源。
        *   **数量固定**：系统中的该类资源单元数目相对固定。
        *   **可重复使用**：一个进程释放后，可供其他进程使用。
        *   例子：CPU、内存、打印机、磁盘驱动器。
    *   **可消耗资源**：
        *   **数量可变**：其单元数目在进程运行期间可以变化，可能为0。
        *   **动态创建和消耗**：由生产者进程创建，由消费者进程请求并消耗掉，不再归还。
        *   例子：进程间通信的消息、中断信号。

25. **试举例说明竞争不可抢占资源所引起的死锁。**
    *   **例子**：系统中有两个进程P1和P2，以及两种不可抢占资源R1（如打印机）和R2（如磁带机）。
        *   P1的执行顺序：请求R1 -> 请求R2 -> ... -> 释放R2 -> 释放R1。
        *   P2的执行顺序：请求R2 -> 请求R1 -> ... -> 释放R1 -> 释放R2。
        *   **死锁情景**：
            1.  P1请求并获得了R1。
            2.  P2请求并获得了R2。
            3.  P1请求R2，由于R2已被P2占用，P1阻塞。
            4.  P2请求R1，由于R1已被P1占用，P2阻塞。
            此时，P1等待P2释放R2，P2等待P1释放R1，形成循环等待，导致死锁。

26. **何谓死锁？产生死锁的原因和必要条件是什么？**
    *   **死锁定义**：如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件（通常是释放资源），那么该组进程是死锁的。
    *   **产生死锁的原因**：
        *   **竞争资源**：多个进程对数量不足的互斥资源进行竞争。
        *   **进程推进顺序不当**：进程在申请和释放资源的顺序不合理。
    *   **产生死锁的必要条件 (四个必须同时满足)**：
        *   **互斥条件**：资源在一段时间内只能由一个进程占有。
        *   **请求和保持条件**：进程已至少保持一个资源，又提出新的资源请求，该资源被其他进程占有，此时请求进程阻塞，但对自己已获得的资源保持不放。
        *   **不可抢占条件**：进程已获得的资源在未使用完之前，不能被强行剥夺，只能由进程自己释放。
        *   **循环等待条件**：存在一个进程资源的循环等待链，即 P0等P1的资源，P1等P2的资源，...，Pn等P0的资源。

27. **在解决死锁问题的几个方法中，哪种方法最易于实现？哪种方法使资源利用率最高？**
    *   **最易于实现的方法**：通常是**预防死锁**中的某些策略，例如，规定所有进程一次性申请所有资源，或者按序申请资源。虽然这些方法简单，但往往会降低资源利用率或限制编程灵活性。鸵鸟算法（即不理睬死锁）在某些不常发生死锁或死锁代价不大的系统中，也可以认为是一种“简单”的处理方式（但不算解决）。
    *   **使资源利用率最高的方法**：通常是**死锁的检测与解除**。这种方法允许系统进入可能发生死锁的状态，通过检测机制发现死锁，然后通过解除手段恢复。由于它对资源的分配限制最少，因此资源利用率和系统并发度可以达到较高水平，但需要付出检测和解除的开销。

28. **请详细说明可通过哪些途径预防死锁。**
    *   **破坏“请求和保持”条件**：
        *   **一次性申请**：进程在运行前一次申请所有所需资源。若不能满足则不分配任何资源，进程等待。
        *   **资源预留改进/分阶段申请**：进程只申请当前阶段所需资源，运行完当前阶段释放不再需要的资源，再申请下一阶段的。或者，进程开始运行时不持有资源，当需要资源时，若能满足则分配，若部分满足则释放已有的再等待，或等待直到全部满足。
    *   **破坏“不可抢占”条件**：
        *   当一个已保持某些资源的进程申请新资源得不到满足时，它必须释放已保持的所有资源。
        *   允许系统抢占某些进程已占有的资源（通常代价高，适用性差，主要针对CPU、内存等易于保存和恢复状态的资源）。
    *   **破坏“循环等待”条件**：
        *   **资源有序分配法**：对所有资源类型进行线性排序，进程必须按序号递增的顺序申请资源。若需申请序号较低的资源，必须先释放已占有的序号相同或更高的资源。

**关于 3.6 预防死锁**

29. (题目26与此部分题目有重复，此处为原文编号26，但内容与28相似) **为了破坏“请求和保持”条件而提出了两种协议，试比较这两种协议。**
    *   **协议一（一次性申请所有资源）**：
        *   **规定**：所有进程在开始运行前，必须一次性申请其在整个运行过程中所需的全部资源。
        *   **优点**：简单、易实现，能有效预防死锁。
        *   **缺点**：资源浪费严重（许多资源在大部分时间被占用但未使用），降低了资源利用率；进程饥饿现象（需要大量资源的进程可能长时间等待），降低了系统并发度。
    *   **协议二（分阶段申请和释放资源/改进的协议）**：
        *   **规定**：允许进程只获得运行初期所需的资源后便开始运行。在运行过程中，逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。
        *   **优点**：相较于协议一，资源利用率有所提高，减少了进程等待时间，改善了并发度。
        *   **缺点**：实现相对复杂，需要程序员预先规划资源申请释放时机；仍可能存在某些阶段资源被长时间占用的情况；对难以预知资源需求的进程不适用；破坏“请求和保持”的效果不如协议一彻底，如果“释放已用毕的全部资源，然后再请求”这个“全部”不是指所有已占有资源，那么仍然可能保持一部分再请求新的，需要严格定义。
    *   **比较**：协议二在资源利用率和进程饥饿方面优于协议一，但实现更复杂。两者都能尝试破坏“请求和保持”条件。

**关于 3.7 避免死锁** (包括银行家算法相关题目)

30. **在银行家算法的例子中，如果P0发出的请求向量由Request(0,2,0)改为Request(0,1,0)，问系统可否将资源分配给它？**
    *   参考课本图3-15 T0时刻状态：
        ![[image-12.png]]
        `Available = (3,3,2)`
        `Need_P0 = (7,4,3)`
        `Allocation_P0 = (0,1,0)`

    *   **P0 请求 Request0(0,1,0)**：
        1.  **检查1 (请求 <= 需求)**: `Request0(0,1,0) <= Need_P0(7,4,3)` (True: 0<=7, 1<=4, 0<=3)
        2.  **检查2 (请求 <= 可用)**: `Request0(0,1,0) <= Available(3,3,2)` (True: 0<=3, 1<=3, 0<=2)
        3.  **系统试探分配**：
            `Available_new = Available - Request0 = (3,3,2) - (0,1,0) = (3,2,2)`
            `Allocation_P0_new = Allocation_P0 + Request0 = (0,1,0) + (0,1,0) = (0,2,0)`
            `Need_P0_new = Need_P0 - Request0 = (7,4,3) - (0,1,0) = (7,3,3)`
        4.  **执行安全性算法** (用新的状态 `Available_new`, `Allocation_P0_new`, `Need_P0_new`，其他进程状态不变)：
            `Work = (3,2,2)`. `Finish = [F,F,F,F,F]`
            *   **P1**: `Need_P1(1,2,2) <= Work(3,2,2)` (True).
                `Work = (3,2,2) + Allocation_P1(2,0,0) = (5,2,2)`. `Finish[P1]=T`.
            *   **P3**: `Need_P3(0,1,1) <= Work(5,2,2)` (True).
                `Work = (5,2,2) + Allocation_P3(2,1,1) = (7,3,3)`. `Finish[P3]=T`.
            *   **P0 (new)**: `Need_P0_new(7,3,3) <= Work(7,3,3)` (True).
                `Work = (7,3,3) + Allocation_P0_new(0,2,0) = (7,5,3)`. `Finish[P0]=T`.
            *   **P2**: `Need_P2(6,0,0) <= Work(7,5,3)` (True).
                `Work = (7,5,3) + Allocation_P2(3,0,2) = (10,5,5)`. `Finish[P2]=T`.
            *   **P4**: `Need_P4(4,3,1) <= Work(10,5,5)` (True).
                `Work = (10,5,5) + Allocation_P4(0,0,2) = (10,5,7)`. `Finish[P4]=T`.
            所有进程均可完成，存在安全序列如 <P1, P3, P0, P2, P4>。系统是安全的。
    *   **结论**：系统可以将资源分配给P0。

31. **在银行家算法中，若出现下述资源分配情况，试问：**
    假设有A, B, C, D四种资源。
    ![[image-11.png]]
    `Available = (1,6,2,2)`

    **(1) 该状态是否安全？**
    `Work = Available = (1,6,2,2)`. `Finish = [F,F,F,F,F]`
    *   **P0**: `Need0(0,0,1,2) <= Work(1,6,2,2)` (True).
        `Work = Work + Alloc0 = (1,6,2,2) + (0,0,3,2) = (1,6,5,4)`. `Finish[P0]=T`.
    *   **P1**: `Need1(1,7,5,0)`。 `Work(1,6,5,4)`. (B: 7 > 6). P1不能满足.
    *   **P2**: `Need2(2,3,5,6)`。 `Work(1,6,5,4)`. (A: 2 > 1, D: 6 > 4). P2不能满足.
    *   **P3**: `Need3(0,6,5,2) <= Work(1,6,5,4)` (True).
        `Work = Work + Alloc3 = (1,6,5,4) + (0,3,3,2) = (1,9,8,6)`. `Finish[P3]=T`.
    *   **P4**: `Need4(0,6,5,6) <= Work(1,9,8,6)` (True).
        `Work = Work + Alloc4 = (1,9,8,6) + (0,0,1,4) = (1,9,9,10)`. `Finish[P4]=T`.
    *   现在回头检查 P1, P2 (P0, P3, P4 已完成):
        `Work = (1,9,9,10)`
    *   **P1**: `Need1(1,7,5,0) <= Work(1,9,9,10)` (True).
        `Work = Work + Alloc1 = (1,9,9,10) + (1,0,0,0) = (2,9,9,10)`. `Finish[P1]=T`.
    *   **P2**: `Need2(2,3,5,6) <= Work(2,9,9,10)` (True).
        `Work = Work + Alloc2 = (2,9,9,10) + (1,3,5,4) = (3,12,14,14)`. `Finish[P2]=T`.
    所有进程均可完成，存在安全序列如 <P0, P3, P4, P1, P2>。
    *   **结论**：该状态是安全的。

    **(2) 若进程P2提出请求Request_P2(1,2,2,2)后，系统能否将资源分配给它？**
    *   当前 `Available = (1,6,2,2)`, `Need_P2 = (2,3,5,6)`, `Allocation_P2 = (1,3,5,4)`.
    *   **检查1 (请求 <= 需求)**: `Request_P2(1,2,2,2) <= Need_P2(2,3,5,6)` (True: 1<=2, 2<=3, 2<=5, 2<=6).
    *   **检查2 (请求 <= 可用)**: `Request_P2(1,2,2,2) <= Available(1,6,2,2)` (True: 1<=1, 2<=6, 2<=2, 2<=2).
    *   **系统试探分配**:
        `Available_new = Available - Request_P2 = (1,6,2,2) - (1,2,2,2) = (0,4,0,0)`
        `Allocation_P2_new = Allocation_P2 + Request_P2 = (1,3,5,4) + (1,2,2,2) = (2,5,7,6)`
        `Need_P2_new = Need_P2 - Request_P2 = (2,3,5,6) - (1,2,2,2) = (1,1,3,4)`
        (其他进程的 Allocation 和 Need 不变)
    *   **执行安全性算法** (用新的状态):
        `Work = Available_new = (0,4,0,0)`. `Finish = [F,F,F,F,F]`
        *   **P0**: `Need0(0,0,1,2)`. `Work(0,4,0,0)`. (C: 1 > 0, D: 2 > 0). P0不能满足.
        *   **P1**: `Need1(1,7,5,0)`. `Work(0,4,0,0)`. (A: 1 > 0, B: 7 > 4, C: 5 > 0). P1不能满足.
        *   **P2 (new)**: `Need_P2_new(1,1,3,4)`. `Work(0,4,0,0)`. (A: 1 > 0, C: 3 > 0, D: 4 > 0). P2不能满足.
        *   **P3**: `Need3(0,6,5,2)`. `Work(0,4,0,0)`. (B: 6 > 4, C: 5 > 0, D: 2 > 0). P3不能满足.
        *   **P4**: `Need4(0,6,5,6)`. `Work(0,4,0,0)`. (B: 6 > 4, C: 5 > 0, D: 6 > 0). P4不能满足.
        无法找到任何一个进程可以开始。系统进入不安全状态。
    *   **结论**：系统不能将资源分配给P2，因为分配后系统将进入不安全状态。P2必须等待。