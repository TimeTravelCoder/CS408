**引言**
*   在实时系统中，可能存在两类不同性质的实时任务：**硬实时任务 (Hard Real-Time, HRT) 和 软实时任务 (Soft Real-Time, SRT)**。
*   它们都联系着一个**截止时间 (Deadline)**。
*   为保证系统能正常工作，实时调度必须能满足实时任务对截止时间的要求。
*   为此，实现实时调度应具备一定的条件。

**3.4.1 实现实时调度的基本条件**

1.  **提供必要的信息**
    *   为了实现实时调度，系统应向调度程序提供有关任务的以下信息：
        *   **(1) 就绪时间 (Ready Time):** 是指某任务成为就绪状态的起始时间。在周期任务的情况下，它是事先预知的一串时间序列。
        *   **(2) 开始截止时间和完成截止时间 (Start Deadline and Completion Deadline):** 对于典型的实时应用，只需知道开始截止时间，或者完成截止时间。
        *   **(3) 处理时间 (Processing Time):** 一个任务从开始执行，直至完成时所需的时间。
        *   **(4) 资源要求 (Resource Requirements):** 任务执行时所需的一组资源。
        *   **(5) 优先级 (Priority):**
            *   如果某任务的开始截止时间错过，势必引起故障，则应为该任务赋予“**绝对**”优先级。
            *   如果其开始截止时间的错过，对任务的继续运行无重大影响，则可为其赋予“**相对**”优先级，供调度程序参考。

2.  **系统处理能力强**
    *   在实时系统中，若处理机的处理能力不够强，则有可能因处理机忙不过来，而致使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。
    *   **单处理机系统可调度性条件**: 假定系统中有 m 个周期性的硬实时任务HRT，它们的处理时间可表示为 Cᵢ，周期时间表示为 Pᵢ，则在单处理机情况下，必须满足下面的限制条件系统才是可调度的：
        `Σ (Cᵢ / Pᵢ) ≤ 1` (i 从 1 到 m)
    *   **注意**: 上述限制条件并未考虑到任务切换所花费的时间，因此，当利用上述限制条件时，还应适当地留有余地。
    *   **提高系统处理能力的途径**:
        *   一是采用单处理机系统，但须增强其处理能力，以显著地减少对每一个任务的处理时间。
        *   二是采用多处理机系统。假定系统中的处理机数为 N，则应将上述的限制条件改为：
            `Σ (Cᵢ / Pᵢ) ≤ N` (i 从 1 到 m)

3.  **采用抢占式调度机制**
    *   在含有HRT任务的实时系统中，广泛采用抢占机制。这样便可满足HRT任务对截止时间的要求。
    *   **复杂性**: 这种调度机制比较复杂。
    *   **非抢占式调度适用场景**: 对于一些小的实时系统，如果能预知任务的开始截止时间，则对实时任务的调度可采用非抢占调度机制，以简化调度程序和在任务调度时所花费的系统开销。
    *   **设计非抢占式调度机制的考虑**: 应使所有的实时任务都比较小，并在执行完关键性程序和临界区后，能及时地将自己阻塞起来，以便释放出处理机，供调度程序去调度那个开始截止时间即将到达的任务。

4.  **具有快速切换机制**
    *   为保证硬实时任务能及时运行，在系统中还应具有快速切换机制，使之能进行任务的快速切换。
    *   该机制应具有如下两方面的能力：
        *   **(1) 对中断的快速响应能力:** 对紧迫的外部事件请求中断能及时响应，要求系统具有快速硬件中断机构，还应使禁止中断的时间间隔尽量短，以免耽误时机（其它紧迫任务）。
        *   **(2) 快速的任务分派能力:** 为了提高分派程序进行任务切换时的速度，应使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。

**3.4.2 实时调度算法的分类**
*   可以按不同方式对实时调度算法加以分类：
    *   ① 根据**实时任务性质**，可将实时调度的算法分为**硬实时调度算法**和**软实时调度算法**。
    *   ② 按**调度方式**，则可分为**非抢占调度算法**和**抢占调度算法**。

1.  **非抢占式调度算法**
    *   **(1) 非抢占式轮转调度算法 (Nonpreemptive Round Robin Scheduling):**
        *   **适用场景**: 由一台计算机控制若干个相同的（或类似的）对象，为每一个被控对象建立一个实时任务，并将它们排成一个轮转队列。
        *   **调度方式**: 调度程序每次选择队列中的第一个任务投入运行。当该任务完成后，便把它挂在轮转队列的末尾等待，调度程序再选择下一个队首任务运行。
        *   **性能**: 可获得数秒至数十秒的响应时间，可用于要求不太严格的实时控制系统中。
    *   **(2) 非抢占式优先调度算法 (Nonpreemptive Priority Scheduling):**
        *   **适用场景**: 如果在系统中还含有少数具有一定要求的实时任务，则可采用非抢占式优先调度算法。
        *   **调度方式**: 系统为这些任务赋予了较高的优先级。当这些实时任务到达时，把它们安排在就绪队列的队首，等待当前任务自我终止或运行完成后，便可去调度执行队首的高优先进程。
        *   **性能**: 这种调度算法在做了精心的处理后有可能使其响应时间减少到数秒至数百毫秒，因而可用于有一定要求的实时控制系统中。

2.  **抢占式调度算法**
	* ![[image-40.png]]
    *   可根据抢占发生时间的不同而进一步分成以下两种调度算法：
    *   **(1) 基于时钟中断的抢占式优先级调度算法 (Clock-Based Preemptive Priority Scheduling):**
        *   **调度时机**: 在某实时任务到达后，如果它的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断发生时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先级任务。
        *   **性能**: 该算法能获得较好的响应效果，其调度延迟可降为几十至几毫秒，可用于大多数的实时系统中。
    *   **(2) 立即抢占的优先级调度算法 (Immediate Preemption Priority Scheduling):**
        *   **要求**: 要求操作系统具有快速响应外部事件中断的能力。
        *   **调度时机**: 一旦出现外部中断，只要当前任务未处于临界区，便能立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。
        *   **性能**: 这种算法能获得非常快的响应，可把调度延迟降低到几毫秒至100微秒，甚至更低。
        *   **图示 (图3-5)**: 分别示出了四种情况的调度时间：(a)非抢占轮转调度, (b)非抢占优先权调度, (c)基于时钟中断抢占的优先权抢占调度, (d)立即抢占的优先权调度。

**3.4.3 最早截止时间优先 EDF (Earliest Deadline First) 算法**
*   **核心思想**: 根据任务的截止时间确定任务的优先级。任务的截止时间愈早，其优先级愈高。
*   **调度方式**: 具有最早截止时间的任务排在队列的队首。调度程序在选择任务时，总是选择就绪队列中的第一个任务，为之分配处理机。
*   **适用性**: 最早截止时间优先算法既可用于抢占式调度方式中，也可用于非抢占式调度方式中。

1.  **非抢占式调度方式用于非周期实时任务**
    *   **图示 (图3-6)**:
	    * ![[image-41.png]]
        *   **场景**: 四个非周期任务先后到达。
        *   **调度过程**:
            *   系统先调度任务1执行。
            *   在任务1执行期间，任务2、3又先后到达。由于任务3的开始截止时间早于任务2，故系统在任务1后将先调度任务3执行。
            *   在此期间又到达作业4，其开始截止时间仍是早于任务2，故在任务3执行完后，系统又先调度任务4执行，最后才调度任务2执行。

2.  **抢占式调度方式用于周期实时任务**
    *   **图示 (图3-7)**:
	    * ![[image-42.png]]
        *   **场景**: 两个周期任务A和B。任务A周期20ms，处理时间10ms；任务B周期50ms，处理时间25ms。
        *   **第一行**: 任务的到达时间、截止时间和执行时间图。
        *   **第二行 (固定优先级，A > B)**:
            *   t=0ms: 先调度A₁执行。A₁完成后 (t=10ms) 才调度B₁执行。
            *   t=20ms: A₂到达，重新调度A₂执行。A₂完成后 (t=30ms) 又调度B₁执行。
            *   t=40ms: A₃到达，重新调度A₃执行。A₃完成后 (t=50ms)，虽然A₃已完成，但B₁已错过了它的最后期限。
            *   **结论**: 利用通常的优先级调度已经失败。
        *   **第三行 (固定优先级，B > A)**: 类似第二行，只是假定B优先级更高，同样会导致任务错过截止时间。
        *   **第四行 (EDF算法)**:
            *   t=0ms: A₁和B₁同时到达，由于A₁的截止时间比B₁早，故调度A₁执行。
            *   t=10ms: A₁完成又调度B₁执行。
            *   t=20ms: A₂到达，由于A₂的截止时间比B₂早 (B₁仍在执行，其截止时间对应B₁的截止时间，但B₂也已“到达”其周期起点)，B₁被中断而调度A₂执行。
            *   t=30ms: A₂完成，又重新调度B₁执行。
            *   t=40ms: A₃又到达，但B₁的截止时间要比A₃早，仍应让B₁继续执行直到完成 (t=45ms)，然后再调度A₃执行。
            *   t=55ms: A₃完成又调度B₂执行。
            *   **结论**: 在该例中，利用最早截止时间优先算法可以满足系统的要求。

**3.4.4 最低松弛度优先 LLF (Least Laxity First) 算法**
*   **核心思想**: 在确定任务的优先级时，根据的是任务的**紧急 (或松弛) 程度**。任务紧急程度愈高，赋予该任务的优先级就愈高，以使之优先执行。
*   **松弛度 (Laxity)**:
    *   一个任务在 200ms 时必须完成，而它本身所需的运行时间是 100ms，因此调度程序必须在 100ms 之前调度执行，该任务的紧急程度（松弛程度）为 100ms。
    *   另一任务在 400ms 时必须完成，它本身需要运行 150ms，则其松弛程度为 250ms。
*   **实现**: 要求系统中有一个按松弛度排序的实时任务就绪队列，松弛度最低的任务排在最前面，调度程序选择队列中的队首任务执行。
*   **适用场景**: 该算法主要用于可抢占调度方式中。
*   **示例 (图3-8, 图3-9)**:
	* ![[image-43.png]]
	* ![[image-44.png]]
    *   **场景**: 两个周期性实时任务A和B。任务A要求每20ms执行一次，执行时间为10ms。任务B要求每50ms执行一次，执行时间为25ms。
    *   **图3-8**: A和B任务每次必须完成的时间点。
    *   **图3-9 (LLF调度过程)**:
        *   **t₁=0ms**:
            *   A₁: 必须在20ms完成，运行需10ms，松弛度 = 20 - 10 - 0 = 10ms。
            *   B₁: 必须在50ms完成，运行需25ms，松弛度 = 50 - 25 - 0 = 25ms。
            *   A₁松弛度更低，先调度A₁执行。
        *   **t₂=10ms (A₁完成)**:
            *   A₂ (新到达): 必须在40ms完成，运行需10ms，松弛度 = 40 - 10 - 10 = 20ms。
            *   B₁ (已等待10ms，还需运行15ms): 必须在50ms完成，松弛度 = 50 - 15 - 10 = 25ms。 (此处按文本“还需运行15ms”及公式 `完成时间 - 剩余执行时间 - 当前时间` 计算。原文“书中结论：B₁的松弛度为15ms”可能基于不同计算方式或假设)
            *   书中结论：B₁的松弛度为15ms（假设基于50 - (25-10) - 10 = 15ms 或者 50 - 25 - 10 = 15ms，如果25是总执行时间，10是已过去时间，则松弛度是 完成时间点 - 剩余执行时间 - 当前时间。若已执行0，则松弛度=50-25-10=15。此点需要参照课本上下文精确理解其计算方法）。此处以文本的计算逻辑为准。
            *   调度B₁运行（假设按书中松弛度B1=15ms，A2=20ms）。
        *   **t₃=30ms (B₁已运行20ms，还需5ms)**:
            *   A₂: 必须在40ms完成，运行需10ms，松弛度 = 40 - 10 - 30 = 0ms。
            *   B₁: 必须在50ms完成，已运行20ms还需5ms，松弛度 = 50 - 5 - 30 = 15ms。
            *   A₂松弛度为0，调度程序应抢占B₁的处理机而调度A₂运行。
        *   **t₄=40ms (A₂完成)**:
            *   A₃: 必须在60ms完成，运行需10ms，松弛度 = 60 - 10 - 40 = 10ms。
            *   B₁ (被抢占，还需5ms): 必须在50ms完成，松弛度 = 50 - 5 - 40 = 5ms。
            *   B₁松弛度更低，重新调度B₁运行。
        *   **t₅=45ms (B₁完成)**:
            *   A₃: 必须在60ms完成，运行需10ms，松弛度 = 60 - 10 - 45 = 5ms。
            *   B₂ (新到达): 必须在100ms完成，运行需25ms，松弛度 = 100 - 25 - 45 = 30ms。
            *   A₃松弛度更低，调度A₃执行。
        *   **t₆=55ms (A₃完成)**:
            *   任务A尚未进入第4周期。
            *   任务B已进入第2周期 (B₂)，调度B₂执行。
        *   **t₇=70ms (B₂已运行15ms，还需10ms)**:
            *   A₄: 必须在80ms完成，运行需10ms，松弛度 = 80 - 10 - 70 = 0ms。
            *   B₂: 必须在100ms完成，还需10ms，松弛度 = 100 - 10 - 70 = 20ms。
            *   A₄松弛度为0，此时调度程序又应抢占B₂的处理机而调度A₄执行。

**3.4.5 优先级倒置 (Priority Inversion Problem)**

1.  **优先级倒置的形成**
    *   **背景**: 当前OS广泛采用优先级调度算法和抢占方式。
    *   **现象**: 系统中存在着影响进程运行的资源而可能产生“优先级倒置”的现象，即高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞。
    *   **示例**: 三个完全独立的进程P₁, P₂, P₃。优先级 P₁ > P₂ > P₃。P₁和P₃通过共享的一个临界资源进行交互。
        ```
        P₁: ...P(mutex); CS-1; V(mutex);...
        P₂: ... program2...;
        P₃: ...P(mutex); CS-3; V(mutex);...
        ```
    *   **过程 (图3-10)**:
	    * ![[image-45.png]]
        *   P₃最先执行，在执行了P(mutex)操作后，进入到临界区CS-3。
        *   时刻a: P₂就绪，因为它比P₃的优先级高，P₂抢占了P₃的处理机而运行。
        *   时刻b: P₁就绪，因为它又比P₂的优先级高，P₁抢占了P₂的处理机而运行。
        *   时刻c: P₁执行P(mutex)操作，试图进入临界区CS-1，但因为相应的临界资源已被P₃占用，故P₁被阻塞。
        *   P₂继续运行，直到时刻d运行结束。
        *   然后由P₃接着运行，到时刻e时P₃退出临界区，并唤醒P₁。
        *   P₁因为它比P₃的优先级高，故它抢占了P₃的处理机而运行。
    *   **问题**: 根据优先级原则，高优先级进程应当能优先执行。但在此例中，P₁和P₃共享着“临界资源”，而出现了不合常理的现象：高优先级进程P₁因P₃进程被阻塞了，又因为P₂进程的存在而延长了P₁被阻塞的时间，而且被延长的时间是不可预知和无法限定的。
    *   **危害**: 由此所产生的“优先级倒置”的现象是非常有害的，它不应出现在实时系统中。