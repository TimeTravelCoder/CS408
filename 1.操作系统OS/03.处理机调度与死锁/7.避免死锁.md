**引言**
避免死锁与预防死锁都属于事先预防策略，但它们的着眼点不同。预防死锁是通过施加较强的限制条件，破坏死锁产生的四个必要条件之一或多个，从而杜绝死锁的发生。而避免死锁则不事先采取各种限制措施去破坏必要条件，而是在资源的动态分配过程中，通过特定的算法（如银行家算法）来判断本次分配是否会导致系统进入**不安全状态**。如果不会进入不安全状态，则允许分配；否则，让进程等待。其核心思想是确保系统始终处于安全状态，从而避免进入可能导致死锁的不安全状态。

---
**3.7.1 系统安全状态 (System Safe State)**

1.  **安全状态的定义**
    *   所谓**安全状态**，是指系统能按某种进程推进顺序 (P1, P2, ..., Pn) 为每个进程 Pi 分配其所需的全部资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺利地完成。如果系统无法找到这样一个**安全序列 (Safe Sequence)**，则称系统处于**不安全状态 (Unsafe State)**。
    *   **注意**：并非所有不安全状态都是死锁状态，不安全状态仅仅是**可能**导致死锁的状态。系统进入不安全状态后，若后续资源分配不当，则可能演变成死锁。而只要系统处于安全状态，就一定可以避免死锁的发生。

2.  **安全状态之例**
    *   **场景**：系统中有三个进程 P1, P2, P3，共享 12 台磁带机。
    *   **T0 时刻状态**：
        *   (参见 `![[image-8.png]]`)
        *   此时系统可用磁带机 (Available) = 12 - (Allocation_P1 + Allocation_P2 + Allocation_P3) = 12 - (5+2+2) = 3 台。
    *   **安全性分析**：
        1.  考察 P2：P2 尚需 (Max_P2 - Allocation_P2) = (4-2) = 2 台。系统可用 3 台。可以将 2 台分配给 P2。P2 运行完毕后释放其占有的 2+2 = 4 台磁带机。此时系统可用 = 3 - 2 + 4 = 5 台。
        2.  考察 P1：P1 尚需 (Max_P1 - Allocation_P1) = (10-5) = 5 台。系统可用 5 台。可以将 5 台分配给 P1。P1 运行完毕后释放其占有的 5+5 = 10 台磁带机。此时系统可用 = 5 - 5 + 10 = 10 台。
        3.  考察 P3：P3 尚需 (Max_P3 - Allocation_P3) = (9-2) = 7 台。系统可用 10 台。可以将 7 台分配给 P3。P3 运行完毕后释放其占有的 2+7 = 9 台磁带机。此时系统可用 = 10 - 7 + 9 = 12 台。
        *   因此，存在一个安全序列 <P2, P1, P3> (或其他可能的安全序列如 <P2, P3, P1>，只要能找到一个即可)。故 T0 时刻系统处于安全状态。

3.  **由安全状态向不安全状态的转换**
    *   **场景接上例**：在 T0 时刻后，若进程 P3 请求 1 台磁带机。
    *   **系统试探性分配**：如果系统将 1 台磁带机分配给 P3，则状态变为：
        *   (参见 `![[image-10.png]]`)
        *   P3 Allocation: 2+1 = 3. P3 Need: 9-3 = 6.
        *   此时系统可用磁带机 (Available) = 3 - 1 = 2 台。
    *   **安全性分析**：
        1.  考察 P2：P2 尚需 2 台，系统可用 2 台。可以将 2 台分配给 P2。P2 完成后释放 4 台。系统可用 = 2 - 2 + 4 = 4 台。
        2.  考察 P1：P1 尚需 5 台，系统可用 4 台。无法满足 P1。
        3.  考察 P3：P3 尚需 6 台 (新的Need)，系统可用 4 台。无法满足 P3。
        *   此时，找不到任何一个进程可以获得其剩余所需资源而运行完毕。因此，系统无法找到一个安全序列，系统进入了不安全状态。
        *   **结论**：尽管在 P3 请求 1 台磁带机时，系统尚有可用资源，但由于这次分配会导致系统进入不安全状态，所以系统不应批准 P3 的这次请求，应让 P3 等待。
    *   **避免死锁的实质**：在进行资源分配时，应使系统不进入不安全状态。

---
**3.7.2 利用银行家算法避免死锁 (Banker's Algorithm)**
银行家算法是最有代表性的避免死锁的算法，由 Dijkstra 提出。它模拟银行家在发放贷款时，确保银行不会因为无法满足所有储户的提款需求而倒闭的策略。
好的，这是按照笔记格式整理的银行家算法思想：

**银行家算法思想 (Banker's Algorithm Core Idea)**

*   **背景与目的**: 银行家算法是一种在操作系统中用于**避免死锁 (Deadlock Avoidance)** 的著名算法。其核心思想是通过模拟银行家审批贷款的过程来动态分配资源，确保系统始终处于**安全状态 (Safe State)**，从而防止进入可能导致死锁的不安全状态。

*   **核心思想步骤**:

    1.  **声明最大需求 (Proactive Declaration of Maximum Need)**:
        *   **喻体**: 银行家要求每个客户（进程）在开始业务前，声明其整个项目（生命周期）可能需要的最大贷款总额（资源最大需求量）。
        *   **系统操作**: 每个进程在进入系统时，必须申明其在运行过程中可能需要的每种资源类型的最大单元数目。
        *   **约束**: 此最大需求量不能超过系统所拥有的该类资源的总结余（银行的总资本）。

    2.  **资源请求与试探性分配 (Resource Request and Tentative Allocation)**:
        *   **喻体**: 当客户（进程）提出一笔具体的贷款请求（资源请求）时，银行家（操作系统）首先检查该请求是否合理（不超过之前声明的最大需求减去已贷款额，即不超过 `Need` 矩阵中的值），以及银行当前是否有足够的流动资金（`Available` 资源）来满足。
        *   **系统操作**:
            *   **检查请求合法性**:
                *   请求数量 ≤ 尚需数量 (`Request_i[j] ≤ Need[i,j]`)。
                *   请求数量 ≤ 当前可用数量 (`Request_i[j] ≤ Available[j]`)。
            *   若上述检查通过，则系统**假定**将资源分配给该进程，并**暂时更新**系统的资源状态（减少`Available`，增加进程的`Allocation`，减少进程的`Need`）。

    3.  **安全性检查 (Safety Check - The Core Simulation)**:
        *   **喻体**: 在假定批准了当前贷款后，银行家需要评估银行的整体风险：是否仍能找到一种方式，保证所有其他客户在未来某个时刻也能获得他们剩余的贷款需求，并最终所有客户都能完成业务并归还贷款。
        *   **系统操作**: 执行**安全性算法 (Safety Algorithm)**。
            *   **目标**: 尝试寻找一个**安全序列 (Safe Sequence)**。这是一个进程的排列 <P₁, P₂, ..., Pn>，使得对于序列中的每一个进程 Pi，其当前尚需的资源 (Need[i]) 加上之前所有进程 Pk (k<i) 完成后释放的资源，能够被系统当前可利用的资源 (Work，初始为 Available) 所满足。
            *   **过程**:
                1.  初始化一个工作向量 `Work = Available` (试探分配后的可用资源)，以及一个标记所有进程未完成的 `Finish` 向量。
                2.  查找是否存在一个未完成的进程 Pi，其 `Need[i] <= Work`。
                3.  若找到这样的 Pi：
                    *   假定 Pi 获得资源，运行完成，并释放其**全部已分配**的资源 (`Allocation[i]`)。
                    *   更新 `Work = Work + Allocation[i]`。
                    *   标记 `Finish[i] = true`。
                    *   返回步骤 2。
                4.  若找不到这样的 Pi：
                    *   如果所有进程都已标记为 `Finish[i] = true`，则系统处于**安全状态**，安全序列即为找到的进程执行顺序。
                    *   否则，如果存在未完成的进程但无法找到满足条件的 Pi，则系统处于**不安全状态**。

    4.  **决策与执行 (Decision and Execution)**:
        *   **喻体**:
            *   如果安全性检查通过（银行评估后认为风险可控，能找到安全序列），则银行家正式批准这笔贷款。
            *   如果安全性检查未通过（银行评估后认为存在风险，找不到安全序列），则银行家拒绝当前的贷款请求，让客户等待。
        *   **系统操作**:
            *   若安全性算法确认系统在试探性分配后仍处于**安全状态**，则正式将资源分配给请求进程，更新系统的实际资源状态。
            *   若安全性算法确认系统在试探性分配后将进入**不安全状态**，则撤销本次试探性分配（将资源状态恢复到请求前的状态），让请求进程阻塞等待。

*   **最终目标**: 通过这种审慎的资源分配策略，银行家算法确保操作系统**永远不会分配可能导致系统进入不安全状态的资源请求**，从而间接地避免了死锁的发生。它以一定的计算开销为代价，换取了更高的资源利用率（相比于死锁预防的某些严格策略）和系统的稳定性。

**前提条件**：
*   每个新进程在进入系统时，必须申明在运行过程中，可能需要的每种资源类型的**最大单元数目**。这个数目不应超过系统所拥有的资源总量。
*   当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，系统是否会转变为不安全状态。只有在不会转变为不安全状态时，才将资源分配给它，否则让进程等待。

1.  **银行家算法中的数据结构**
    为了实现银行家算法，系统中必须设置以下四个数据结构，来描述系统中可利用的资源、所有进程对资源的最大需求、系统中的资源分配，以及所有进程尚需的资源情况。假设系统中有 `n` 个进程 {P0, P1, ..., Pn-1} 和 `m` 种资源类型 {R0, R1, ..., Rm-1}。
    *   **(1) 可利用资源向量 `Available`**：这是一个含有 `m` 个元素的数组，其中的每一个元素代表一类可利用的资源数目。其初始值是系统中所配置的该类资源的数目。如果 `Available[j] = K`，则表示系统中现有 Rj 类资源 K 个。其数值随该类资源的分配和回收而动态地改变。
    *   **(2) 最大需求矩阵 `Max`**：这是一个 `n x m` 的矩阵，它定义了系统中 `n` 个进程中的每一个进程对 `m` 类资源的最大需求。如果 `Max[i, j] = K`，则表示进程 Pi 需要 Rj 类资源的最大数目为 K。
    *   **(3) 分配矩阵 `Allocation`**：这也是一个 `n x m` 的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果 `Allocation[i, j] = K`，则表示进程 Pi 当前已分得 Rj 类资源的数目为 K。
    *   **(4) 需求矩阵 `Need`**：这也是一个 `n x m` 的矩阵，用以表示每一个进程尚需的各类资源数。如果 `Need[i, j] = K`，则表示进程 Pi 还需要 Rj 类资源 K 个方能完成其任务。
    *   上述三个矩阵间存在下述关系：
        `Need[i, j] = Max[i, j] – Allocation[i, j]`

2.  **银行家算法**
    设 `Request_i` 是进程 Pi 的请求向量，如果 `Request_i[j] = K`，表示进程 Pi 请求 K 个 Rj 类型的资源。当 Pi 发出资源请求后，系统按下述步骤进行检查：
    *   **(1) 检查请求是否越界**：如果 `Request_i[j] ≤ Need[i, j]` 对所有 `j` 成立，则转向步骤 (2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值 (或者说超过了它尚需的资源量)。
    *   **(2) 检查是否有足够可用资源**：如果 `Request_i[j] ≤ Available[j]` 对所有 `j` 成立，则转向步骤 (3)；否则表示尚无足够资源，Pi 须等待。
    *   **(3) 系统试探性分配**：系统试探着把资源分配给进程 Pi，并修改下面数据结构中的数值：
        *   `Available[j] = Available[j] – Request_i[j];`
        *   `Allocation[i, j] = Allocation[i, j] + Request_i[j];`
        *   `Need[i, j] = Need[i, j] – Request_i[j];`
    *   **(4) 执行安全性算法**：系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。
        *   若安全，才正式将资源分配给进程 Pi，以完成本次分配。
        *   否则，将本次的试探分配作废，恢复原来的资源分配状态 (回滚步骤3的修改)，让进程 Pi 等待。

3.  **安全性算法 (Safety Algorithm)**
    系统所执行的安全性算法可描述如下：
    *   **(1) 初始化工作向量 `Work` 和结束标志 `Finish`**：
        *   设置一个工作向量 `Work`，它表示系统可提供给进程继续运行所需的各类资源数目，它含有 `m` 个元素，在执行安全算法开始时，`Work = Available` (此处的 `Available` 是试探分配后的)。
        *   设置一个布尔型向量 `Finish`，表示系统是否有足够的资源分配给进程，使之运行完成。开始时先对所有 `i` 做 `Finish[i] = false`。
    *   **(2) 寻找能满足的进程**：从进程集合中找到一个能满足下述条件的进程 Pi：
        *   `Finish[i] == false;` (进程尚未完成)
        *   `Need[i, j] ≤ Work[j]` (对所有资源类型 `j` 成立)；(进程尚需的资源小于等于当前系统可提供的资源)
        若找到，则执行步骤 (3)，否则，执行步骤 (4)。
    *   **(3) 进程获得资源并释放**：当进程 Pi 获得资源后，可顺利执行，直至完成，并释放出分配给它的所有资源 (Allocation[i])，故应执行：
        *   `Work[j] = Work[j] + Allocation[i, j];` (对所有资源类型 `j`) (系统可用资源增加)
        *   `Finish[i] = true;` (标记该进程已完成)
        *   `go to step 2;` (返回第二步，继续寻找下一个可以满足的进程)
    *   **(4) 判断系统是否安全**：如果所有进程的 `Finish[i]` 都为 `true` (即所有进程都已标记为完成)，则表示系统处于安全状态；否则，系统处于不安全状态（因为无法找到一个完整的安全序列）。

4.  **银行家算法之例** (详见课本图3-15, 3-16, 3-17, 3-18 的分析过程)
    *   (参见 ![[image-50.png]]`)
    *   该例子详细展示了 T0 时刻系统的初始状态、如何判断其安全性、当某个进程（如P1）发出资源请求时系统如何使用银行家算法进行判断，以及如果另一个进程（如P4或P0）的请求会导致不安全状态时系统如何拒绝请求。
    *   **T0 时刻的安全性分析** (如图3-16)：
        *   (参见 ![[image-51.png]])
        *   通过安全性算法，可以找到一个安全序列，例如 {P1, P3, P4, P2, P0}，因此 T0 时刻系统是安全的。
        *   （寻找过程：
            1.  初始 `Work = Available = (3, 3, 2)`。`Finish = [F, F, F, F, F]`。
            2.  P1: `Need1 = (1, 2, 2) <= Work`. Yes. `Work = (3,3,2) + Allocation1(2,0,0) = (5,3,2)`. `Finish[1] = T`.
            3.  P3: `Need3 = (0, 1, 1) <= Work`. Yes. `Work = (5,3,2) + Allocation3(2,1,1) = (7,4,3)`. `Finish[3] = T`.
            4.  P4: `Need4 = (4, 3, 1) <= Work`. Yes. `Work = (7,4,3) + Allocation4(0,0,2) = (7,4,5)`. `Finish[4] = T`.
            5.  P0: `Need0 = (7, 4, 3)` (from Fig 3-15). `Work = (7,4,5)`. `Need0 <= Work`. Yes. `Work = (7,4,5) + Allocation0(0,1,0) = (7,5,5)`. `Finish[0] = T`.
            6.  P2: `Need2 = (6, 0, 0) <= Work`. Yes. `Work = (7,5,5) + Allocation2(3,0,2) = (10,5,7)`. `Finish[2] = T`.
            所有进程的 `Finish` 均为 `true`，系统安全。）
    *   **P1 请求资源 (1, 0, 2)** (如图3-17)：
        *   (参见 ![[image-52.png]])
        1.  `Request1 = (1,0,2) <= Need1 = (1,2,2)` (True)
        2.  `Request1 = (1,0,2) <= Available = (3,3,2)` (True, assuming this is T0 state)
        3.  试探分配：
            `Available_new = (3,3,2) - (1,0,2) = (2,3,0)`
            `Allocation1_new = (2,0,0) + (1,0,2) = (3,0,2)`
            `Need1_new = (1,2,2) - (1,0,2) = (0,2,0)`
        4.  执行安全性算法（`Work = Available_new = (2,3,0)`. P1's Need is now (0,2,0). Other processes' Need/Allocation are as in T0）：
            *   P1: `Need1_new(0,2,0) <= Work(2,3,0)`. Yes. `Work = (2,3,0) + Alloc1_new(3,0,2) = (5,3,2)`. `Finish[1]=T`.
            *   P3: `Need3(0,1,1) <= Work(5,3,2)`. Yes. `Work = (5,3,2) + Alloc3(2,1,1) = (7,4,3)`. `Finish[3]=T`.
            *   P4: `Need4(4,3,1) <= Work(7,4,3)`. Yes. `Work = (7,4,3) + Alloc4(0,0,2) = (7,4,5)`. `Finish[4]=T`.
            *   P0: `Need0(7,4,3) <= Work(7,4,5)`. Yes. `Work = (7,4,5) + Alloc0(0,1,0) = (7,5,5)`. `Finish[0]=T`.
            *   P2: `Need2(6,0,0) <= Work(7,5,5)`. Yes. `Work = (7,5,5) + Alloc2(3,0,2) = (10,5,7)`. `Finish[2]=T`.
            系统仍安全，允许分配。
    *   **P4 请求资源 (3, 3, 0)** (假设在P1请求(1,0,2)被批准之后，Available=(2,3,0)):
        1.  `Request4 = (3,3,0) <= Need4 = (4,3,1)` (True)
        2.  `Request4 = (3,3,0) <= Available = (2,3,0)` (False, because 3 > 2 for resource A). P4 须等待。
    *   **P0 请求资源 (0, 2, 0)** (如图3-18, 假设在P1请求(1,0,2)被批准之后，Available=(2,3,0)):
        *   (参见 ![[image-53.png]]`)
        1.  `Request0 = (0,2,0) <= Need0 = (7,4,3)` (True)
        2.  `Request0 = (0,2,0) <= Available = (2,3,0)` (True)
        3.  试探分配：
            `Available_new = (2,3,0) - (0,2,0) = (2,1,0)`
            `Allocation0_new = (0,1,0) + (0,2,0) = (0,3,0)`
            `Need0_new = (7,4,3) - (0,2,0) = (7,2,3)`
            (P1's state is `Alloc1=(3,0,2)`, `Need1=(0,2,0)` from previous successful request)
        4.  执行安全性算法。`Work = Available_new = (2,1,0)`:
            *   P0 (`Need0_new(7,2,3)`): No (A, B, C)
            *   P1 (`Need1_new(0,2,0)`): No (B needs 2, Work has 1)
            *   P2 (`Need2(6,0,0)`): No (A needs 6, Work has 2)
            *   P3 (`Need3(0,1,1)`): No (C needs 1, Work has 0)
            *   P4 (`Need4(4,3,1)`): No (A, B, C)
            无法找到任何一个进程可以完成。系统进入不安全状态。因此，P0 的请求不被批准。

---
**总结**
避免死锁是一种更为灵活的死锁预防策略。它允许进程动态地申请资源，但通过银行家算法等机制来确保每次分配后系统仍处于安全状态。其优点在于不需要像预防死锁那样施加过强的限制，可以获得更好的并发性和资源利用率。然而，它也有其局限性：
*   **需要预知进程的最大资源需求**：这在许多实际应用中是难以准确估计的。
*   **进程数量和资源种类固定**：算法通常假设系统中的进程和资源类型是固定的，不适用于动态变化的环境。
*   **计算开销较大**：每次资源请求都需要运行安全性算法，这会带来一定的系统开销，尤其是在进程数量和资源种类较多时。
*   **可能导致资源分配保守**：为了维持安全状态，系统可能会拒绝一些实际上不会导致死锁的请求，从而降低资源利用率。