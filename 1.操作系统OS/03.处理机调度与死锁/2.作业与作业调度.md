**引言**
*   在多道批处理系统中，作业是用户提交给系统的一项相对独立的工作。
*   操作员将用户提交的作业通过输入设备输入到磁盘存储器，保存在后备作业队列中。
*   作业调度程序将其从外存调入内存。

**3.2.1 批处理系统中的作业**

1.  **作业和作业步 (Job and Job Step)**
    *   **(1) 作业 (Job):**
        *   概念比程序更广泛。
        *   不仅包含通常的程序和数据，还应配有一份**作业说明书 (Job Description)**。
        *   系统根据作业说明书来对程序的运行进行控制。
        *   在批处理系统中，作业是**基本单位**从外存调入内存。
    *   **(2) 作业步 (Job Step):**
        *   通常，作业运行期间，每个作业都必须经过若干个相对独立、又相互关联的顺序加工步骤才能得到结果。
        *   每一个加工步骤称为一个**作业步**。
        *   各作业步之间存在相互联系，往往是上一个作业步的输出作为下一个作业步的输入。
        *   典型示例：一个作业可分成 “编译 (Compile)” 作业步、“链接装配 (Link & Load)” 作业步和 “运行 (Run)” 作业步。

2.  **作业控制块 (Job Control Block, JCB)**
    *   **目的**: 为了管理和调度作业，在多道批处理系统中，为每个作业设置一个作业控制块JCB。
    *   **作用**: JCB是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。
    *   **JCB中通常包含的内容**:
        *   **作业标识 (Job Identifier)**
        *   **用户名称 (User Name)**
        *   **用户账号 (User Account)**
        *   **作业类型 (Job Type)**: 如 CPU繁忙型、I/O繁忙型、批量型、终端型等。
        *   **作业状态 (Job Status)**
        *   **调度信息 (Scheduling Information)**: 如优先级、作业运行时间等。
        *   **资源需求 (Resource Requirements)**: 如预计运行时间、要求内存大小等。
        *   **资源使用情况 (Resource Usage)** 等。
    *   **JCB的生命周期**:
        *   **创建**: 当一个作业进入系统时，由“作业注册”程序为该作业建立一个JCB。
        *   **排队**: 根据作业类型，将其放到相应的作业后备队列中等待调度。
        *   **调度与控制**: 调度程序依据一定的调度算法来调度它们，被调度到的作业将被装入内存。在作业运行期间，系统按照JCB中的信息和作业说明书对作业进行控制。
        *   **撤销**: 当一个作业执行结束进入完成状态时，系统负责回收已分配给它的资源，并撤销该作业控制块。

3.  **作业运行的三个阶段和三种状态**
    *   作业从进入系统到运行结束，通常需要经历**收容、运行和完成**三个阶段。
    *   相应的作业状态有**“后备状态”、“运行状态”和“完成状态”**。
    *   **(1) 收容阶段 (Admission Phase) -> 后备状态 (Backup State):**
        *   操作员把用户提交的作业通过某种输入方式或SPOOLing系统输入到硬盘上。
        *   再为该作业建立JCB，并把它放入作业后备队列中。
        *   此时作业的状态为“后备状态”。
    *   **(2) 运行阶段 (Execution Phase) -> 运行状态 (Running State):**
        *   当作业被作业调度选中后，便为它分配必要的资源和建立进程，并将它放入就绪队列。
        *   一个作业从第一次进入就绪状态开始，直到它运行结束前，在此期间都处于“运行状态”。
    *   **(3) 完成阶段 (Completion Phase) -> 完成状态 (Completed State):**
        *   当作业运行完成、或发生异常情况而提前结束时，作业便进入完成阶段。
        *   相应的作业状态为“完成状态”。
        *   此时系统中的“终止作业”程序将会回收已分配给该作业的作业控制块和所有资源，并将作业运行结果信息形成输出文件后输出。

---
**3.2.2 作业调度的主要任务**
*   **主要任务**: 根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度。
*   **别称**: 接纳调度 (Admission Scheduling)。
*   **每次执行作业调度时需做出的两个决定**:
    1.  **接纳多少个作业**
        *   取决于**多道程序度 (Degree of Multiprogramming)**，即允许多少个作业同时在内存中运行。
        *   **目标**: 希望装入较多的作业，有利于提高CPU的利用率和系统的吞吐量。
        *   **问题**: 若内存中同时运行的作业太多，进程在运行时因内存不足所发生的中断就会急剧增加，导致平均周转时间显著延长，影响服务质量。
        *   **决策依据**: 根据计算机的系统规模、运行速度、作业大小，以及能否获得较好的系统性能等情况作出适当的抉择。
    2.  **接纳哪些作业**
        *   取决于所采用的**调度算法**。
        *   **常见算法**:
            *   先来先服务调度算法 (FCFS): 将最早进入外存的作业优先调入内存。
            *   短作业优先调度算法 (SJF): 将外存上所需执行时间最短的作业优先调入内存。
            *   基于作业优先级的调度算法: 将外存上作业优先级最高的作业优先调入内存。
            *   “响应比高者优先”的调度算法 (HRRN): 一种较好的算法，后续介绍。
*   **不同系统中的作业调度**:
    *   **批处理系统**: 需要作业调度将作业分批装入内存。
    *   **分时系统**: 为了及时响应，用户通过键盘输入的命令或数据等都被直接送入内存，无需配置作业调度机制。但需要某种**接纳控制措施 (Admission Control)**来限制进入系统的用户数目。
    *   **实时系统**: 类似分时系统，不需要作业调度，但必需具有接纳控制措施。

---
**3.2.3 先来先服务(FCFS)和短作业优先(SJF)调度算法**

1.  **先来先服务 (First-Come First-Served, FCFS) 调度算法**
    *   **特点**: 最简单的调度算法。
    *   **适用范围**: 既可用于作业调度，也可用于进程调度。
    *   **作业调度中的FCFS**:
        *   系统按照作业到达的先后次序来进行调度，或者说优先考虑在系统中等待时间最长的作业。
        *   不考虑作业所需执行时间的长短。
        *   从后备作业队列中选择几个最先进入该队列的作业，将它们调入内存，分配资源，创建进程，然后放入就绪队列。
    *   **进程调度中的FCFS**:
        *   每次调度是从就绪的进程队列中选择一个最先进入该队列的进程，为之分配处理机，投入运行。
        *   该进程一直运行到完成或发生某事件而阻塞后，进程调度程序才将处理机分配给其它进程。
    *   **当前应用**: 在单处理机系统中已很少作为主调度算法，但经常与其它调度算法结合使用（例如，按优先级设置多个队列，每个队列内部采用FCFS）。

2.  **短作业优先 (Short Job First, SJF) 的调度算法**
    *   **提出背景**: 实际情况中，短作业(进程)占有很大比例，为了能使它们能比长作业优先执行。
    *   **1) 短作业优先算法**
        *   **优先级计算**: 以作业的长短来计算优先级，作业越短，其优先级越高。
        *   **衡量标准**: 作业的长短是以作业所要求的运行时间来衡量的。
        *   **适用范围**: 可分别用于作业调度和进程调度。
        *   **作业调度中的SJF**: 从外存的作业后备队列中选择若干个估计运行时间最短的作业，优先将它们调入内存运行。
    *   **2) 短作业优先算法的缺点**
        *   **(1) 必须预知作业的运行时间**:
            *   程序员也很难准确估计作业的运行时间。
            *   如果估计过低，系统可能按估计的时间终止作业运行，但作业未完成。
            *   故一般都会偏长估计。
        *   **(2) 对长作业非常不利**:
            *   长作业的周转时间会明显地增长。
            *   更严重的是，该算法完全忽视作业的等待时间，可能使作业等待时间过长，出现**饥饿现象 (Starvation)**。
        *   **(3) 人—机无法实现交互**: (此条原文在SJF的缺点下，但提及FCFS，可能指SJF作为批处理算法缺乏交互性，与FCFS类似)
        *   **(4) 该调度算法完全未考虑作业的紧迫程度**:
            *   故不能保证紧迫性作业能得到及时处理。

---
**3.2.4 优先级调度算法和高响应比优先调度算法**

1.  **优先级调度算法 (Priority-Scheduling Algorithm, PSA)**
    *   **回顾**:
        *   FCFS: 作业的等待时间是优先级（等待越长，优先级越高）。
        *   SJF: 作业的长短是优先级（作业越短，优先级越高）。
    *   **PSA的核心**: 基于作业的**紧迫程度 (Urgency)**，由外部赋予作业相应的优先级。调度算法根据该优先级进行调度。
    *   **目的**: 保证紧迫性作业优先运行。
    *   **适用范围**: 可作为作业调度算法，也可作为进程调度算法。
    *   **作业调度中的PSA**: 系统从后备队列中选择若干个优先级最高的作业装入内存。

2.  **高响应比优先调度算法 (Highest Response Ratio Next, HRRN)**
    *   **对比FCFS和SJF**:
        *   FCFS: 只考虑作业等待时间，忽视了运行时间。
        *   SJF: 只考虑作业运行时间，忽视了等待时间。
    *   **HRRN的特点**: 既考虑作业的等待时间，又考虑作业运行时间的调度算法。
    *   **优点**:
        *   既照顾了短作业。
        *   又不致使长作业的等待时间过长。
        *   从而改善了处理机调度的性能。
    *   **实现方式**: 为每个作业引入一个**动态优先级**，该优先级随等待时间延长而增加。
    *   **优先权计算公式**:
        `优先权 = (等待时间 + 要求服务时间) / 要求服务时间`
        或者，等价地表示为**响应比 (Rp)**:
        `Rp = 响应时间 / 要求服务时间`
        `   = (等待时间 + 要求服务时间) / 要求服务时间`
    *   **公式解读**:
        *   **(①) 等待时间相同**: 要求服务的时间愈短，其优先权愈高 (类似于SJF，有利于短作业)。
        *   **(②) 要求服务时间相同**: 作业的优先权又决定于其等待时间 (类似于FCFS)。
        *   **(③) 长作业**: 优先级可以随等待时间的增加而提高，当其等待时间足够长时，也可获得处理机。
    *   **结论**: 该算法实现了较好的折中。
    *   **缺点**: 每次要进行调度之前，都需要先做响应比的计算，会增加系统开销。