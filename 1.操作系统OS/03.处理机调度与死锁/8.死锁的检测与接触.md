**引言**
在某些系统中，既不采用死锁预防措施（破坏死锁产生的必要条件），也不采用死锁避免算法（如银行家算法），而是允许系统在运行过程中发生死锁。这种策略下，系统必须提供两个算法：
1.  **死锁检测算法**：用于检测系统状态，以确定系统中是否已发生了死锁。
2.  **死锁解除算法**：当认定系统中已发生了死锁时，利用该算法可将系统从死锁状态中解脱出来。

**3.8.1 死锁的检测 (Deadlock Detection)**
为了能对系统中是否已发生了死锁进行检测，在系统中必须：
*   保存有关资源的请求和分配信息。
*   提供一种算法，利用这些信息来检测系统是否已进入死锁状态。

1.  **资源分配图 (Resource Allocation Graph)**
    *   系统死锁可以利用资源分配图来描述。该图是由一组结点 N 和一组边 E所组成的一个对偶 G = (N, E)。
    * ![[image-54.png]]
    *   **结点 N** 分为两个互斥的子集：
        *   **进程结点 P = {P1, P2, ..., Pn}**：代表系统中的进程。
        *   **资源结点 R = {R1, R2, ..., Rm}**：代表系统中的资源类型。
    *   **边 E** 连接进程结点和资源结点：
        *   **请求边 (Request Edge)**：e = {Pi, Rj}，由进程 Pi 指向资源 Rj，表示进程 Pi 请求一个单位的 Rj 资源。
        *   **分配边 (Assignment Edge)**：e = {Rj, Pi}，由资源 Rj 指向进程 Pi，表示把一个单位的 Rj 资源分配给了进程 Pi。
    *   **资源分配图的简化 (化简)**：用于检测死锁。
        1.  **找出既不阻塞又非独立的进程结点 Pi**：即该进程的资源请求可以被满足（所有请求边指向的资源都有空闲单元或可以被释放）。
        2.  **消除 Pi 的所有请求边和分配边**：使 Pi 成为孤立的结点。这相当于 Pi 获得了其所需的全部资源，运行完毕，并释放了它所占有的所有资源。
        3.  **重复上述过程**：直到图中所有的边都被消除（所有进程结点都成为孤立结点），或者图中不存在可以消除边的进程。

2.  **死锁定理 (Deadlock Theorem)**
    *   **内容**：S 为死锁状态的充分条件是：当且仅当 S 状态的资源分配图是**不可完全简化**的。
    *   **不可完全简化**：是指在进行一系列简化后，图中仍然存在无法消除的边（即存在无法满足其资源请求的进程）。
    *   **推论**：如果资源分配图中的所有进程都是孤立结点（所有边都被消除），则称该图是可完全简化的，系统未发生死锁。
    *   **示例 (图3-20)**：
	    * ![[image-55.png]]
        *   **(a) 初始状态**：P1 占有两个 R1 单元，请求一个 R2 单元。P2 占有一个 R2 单元，请求一个 R1 单元。
        *   **(b) 简化 P1 (若假设 P1 的请求能满足，但图中未画出 R2 的可用单元，这里假设按死锁定理，寻找能释放资源的进程)**：如果 P1 能够获得 R2 (例如 R2 有空闲单元，或者 P1 是一个可以先完成并释放资源的进程)，则 P1 运行完毕释放其占有的两个 R1 单元。图中 P1 的边被消除。
        *   **(c) 简化 P2**：P1 释放 R1 后，P2 可以获得 R1，运行完毕释放其占有的 R1 和 R2 单元。图中 P2 的边被消除。
        *   此时，所有边都被消除，图是可完全简化的，系统未发生死锁。
        *   **如果图中存在环路且无法简化，则发生死锁。** 例如，如果 P1 请求 R2，R2 被 P2 占用，P2 请求 R1，R1 被 P1 占用，且没有其他可释放资源的进程，则形成死锁。

3.  **死锁检测中的数据结构 (类似于银行家算法)**
    当每类资源只有一个单元时，可以通过检测资源分配图是否存在环路来判断是否发生死锁。但当每类资源有多个单元时，仅有环路是死锁的必要条件而非充分条件。此时，需要一种类似于银行家算法中安全性算法的死锁检测算法。
    *   **(1) 可利用资源向量 `Available`**：与银行家算法中的定义相同，表示每类资源的当前可用数目。
    *   **(2) 分配矩阵 `Allocation`**：与银行家算法中的定义相同，表示当前每类资源已分配给每个进程的数目。
    *   **(3) 请求矩阵 `Request`**：这是一个 `n x m` 的矩阵，与银行家算法中的 `Need` 矩阵不同。它表示当前每一个进程**正在请求**的各类资源数目。如果 `Request[i, j] = K`，则表示进程 Pi 当前请求 K 个 Rj 类资源。
    **死锁检测算法步骤**：
    1.  **初始化工作向量 `Work` 和结束标志 `Finish`**：
        *   `Work = Available`
        *   对所有进程 Pi，如果 `Allocation[i, j] == 0` (对所有 j)，则 `Finish[i] = true`；否则 `Finish[i] = false`。 (即不占用资源的进程视为已完成)。
    2.  **寻找能满足的进程**：从进程集合中找到一个满足下述条件的进程 Pi：
        *   `Finish[i] == false;`
        *   `Request[i, j] ≤ Work[j]` (对所有 j 成立)；
        若找到，则执行步骤 (3)，否则，执行步骤 (4)。
    3.  **进程获得资源并假想释放**：假想进程 Pi 获得了它所请求的资源，运行完毕，并释放了它所占有的所有资源 (Allocation[i])。故应执行：
        *   `Work[j] = Work[j] + Allocation[i, j];` (对所有 j)
        *   `Finish[i] = true;`
        *   `go to step 2;`
    4.  **判断是否死锁**：如果存在某个进程 Pi 使得 `Finish[i] == false`，则系统处于死锁状态，并且所有 `Finish[i] == false` 的进程 Pi 都是死锁进程。否则，系统未发生死锁。
    **检测时机**：
    *   **进程请求资源且得不到满足时**：开销较大，但能及时发现。
    *   **定时检测**：例如每隔一段时间，或者当 CPU 利用率低于某个阈值时。

**3.8.2 死锁的解除 (Deadlock Recovery/Resolution)**
当死锁检测算法检测到系统中已发生死锁后，就应立即采取相应的措施，以解除死锁。常用的解除死锁的方法主要有两种：

1.  **抢占资源 (Preempt Resources)**
    *   **方法**：从一个或多个进程中抢占足够数量的资源，并将这些资源分配给死锁进程，以解除死锁状态。
    *   **选择被抢占进程的原则 (付出最小代价)**：
        *   **优先级**：优先抢占低优先级进程的资源。
        *   **已执行时间**：优先抢占已执行时间短的进程的资源。
        *   **已占用资源**：优先抢占占用资源少的进程的资源。
        *   **进程类型**：优先抢占批处理型进程的资源，而非交互型进程。
        *   **还需执行时间**：优先抢占剩余执行时间长的进程的资源。
    *   **问题**：
        *   **选择合适的被抢占进程和资源是困难的**。
        *   **进程回退 (Rollback)**：被抢占资源的进程可能需要回退到某个安全点（检查点）重新执行，增加了系统开销。如果无法回退，则可能需要终止该进程。
        *   **防止饥饿**：需要确保一个进程不会被无休止地抢占资源而无法完成。

2.  **终止（或撤销）进程 (Terminate Processes)**
    *   **方法**：终止（或撤销）系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来。
    *   **终止策略**：
        *   **(1) 终止所有死锁进程**：这是最简单的方法，但代价可能很大，因为其中一些进程可能已经运行了很长时间，接近完成。
        *   **(2) 逐个终止死锁进程**：按照某种顺序（通常是基于最小代价原则，与抢占资源时选择进程的原则类似）逐个终止死锁进程，每终止一个进程就进行一次死锁检测，直到死锁解除。这种方法开销较大，因为每次终止后都要重新检测。
    *   **选择被终止进程的原则 (付出最小代价)**：
        *   进程的优先级。
        *   进程已执行了多少时间，还剩下多少时间才能完成。
        *   进程在运行中已经使用了多少资源，以后还需要多少资源。
        *   进程的性质是交互式的还是批处理式的。
        *   有多少个进程将因该进程的终止而受到影响。

3.  **付出代价最小的死锁解除算法 (一种理论上的算法，如图3-21)**
	* ![[image-56.png]]
    *   这是一种试图找到最小代价解除路径的方法，通常基于图论搜索。
    *   **基本思想**：从当前死锁状态 S 开始，考虑终止每一个死锁进程 Pi 会将系统带入一个新的状态 $Ui$，并付出相应的代价 $C_{ui}$。然后从这些新的状态中选择一个代价最小的 U (例如 U1)，如果 U1 仍然是死锁状态，则继续从 U1 出发，考虑终止其中的某个死锁进程，得到新的状态和代价。如此递归下去，直到找到一个非死锁状态。这条路径的总代价即为解除该死锁的代价。
    *   **实际困难**：状态空间可能非常大，计算复杂度很高 ($k(k-1)(k-2).../2C$)，在实际系统中应用较少。

**总结**
死锁的检测与解除是一种允许死锁发生，但能及时发现并从中恢复的策略。
*   **死锁检测**：通过资源分配图的简化或专门的检测算法来判断系统是否处于死锁状态。
*   **死锁解除**：主要通过抢占资源或终止进程的方式来打破死锁。选择被抢占或被终止的进程时，应遵循“付出最小代价”的原则。

这种策略的优点在于它不需要像预防和避免那样施加严格的限制，因此可以获得较高的资源利用率和系统并发度。缺点是死锁检测和解除本身会带来一定的系统开销，并且解除死锁的过程可能会导致部分进程的工作丢失。在实际应用中，选择何种死锁处理策略取决于系统的具体需求和对各种开销的权衡。