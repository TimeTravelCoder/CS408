

连续分配方式（如固定分区、动态分区）会产生外部碎片，虽然可以通过“紧凑”来合并碎片，但这需要很大的系统开销。为了解决这些问题，并提高内存利用率，引入了离散分配方式。分页存储管理就是一种重要的离散分配方式。其核心思想是：允许一个进程的逻辑地址空间分散地装入到许多不相邻接的物理内存区域中。

**基本思想：**
1.  将用户程序的地址空间（逻辑地址空间）划分为若干个大小固定的区域，称为“**页(Page)**”或“**页面**”。
2.  将内存空间（物理地址空间）也划分为与页面大小相等的区域，称为“**块(Block)**”或“**页框(Frame)**”。
3.  在为进程分配内存时，以**块**为单位，可以将进程中的任意一页放入内存中的任意一个物理块中。这些块不必连续。

与分页类似，还有分段存储管理（以逻辑意义上的段为单位）和段页式存储管理（结合了分页和分段）。本节主要讨论分页。

---

## 4.5.1 分页存储管理的基本方法 (Basic Methods of Paging Storage Management)

### 1. 页面和物理块 (Page and Physical Block)

*   **页面 (Page):**
    *   进程的逻辑地址空间被划分为若干个大小相等的页。
    *   各页从0开始编号，如第0页，第1页等。
*   **物理块 (Physical Block / Page Frame):**
    *   内存的物理地址空间被划分为与页面大小相同的块。
    *   物理块也从0开始编号，如0#块，1#块等。
*   **分配 (Allocation):**
    *   为进程分配内存时，将进程的若干页分别装入多个可以不相邻的物理块中。
*   **页内碎片 (Internal Fragmentation):**
    *   由于进程的最后一页通常装不满一个物理块，导致物理块的末尾部分空间被浪费。这种浪费存在于已分配区域（页框）的内部，称为页内碎片。
*   **页面大小 (Page Size):**
    *   **过小 (Too Small):**
        *   优点 (Advantages): 减少页内碎片的平均大小，提高内存利用率。
        *   缺点 (Disadvantages): 导致进程占用页面过多，页表会很长，占用大量内存；降低页面换进换出的效率。
    *   **过大 (Too Large):**
        *   优点 (Advantages): 减少页表长度，提高页面换进换出效率。
        *   缺点 (Disadvantages): 页内碎片增大，内存利用率降低。
    *   页面大小的选择应适中，通常是2的幂（方便地址转换），如书中提到的1KB ~ 8KB。

### 2. 地址结构 (Address Structure)

分页系统中的逻辑地址结构如下：

| 页号 (P)        | 页内地址 (W) / 位移量 |
| :------------ | :------------- |
| (高位部分)(12-31) | (低位部分) (0-11)  |

*   **页号 (P - Page Number):** 指出该地址属于逻辑地址空间中的哪一页。
*   **页内地址 (W - Word Address) / 位移量 (Displacement/Offset):** 指出该地址在页面内的具体位置。
*   地址长度为32位，若页面大小为 L (例如4KB = 2^12 B)，则：
    *   页内地址 W 占低12位 (0-11)。
    *   页号 P 占高20位 (12-31)，意味着最多允许 2^20 = 1M 个页面。
*   **换算 (Conversion):**
    *   给定逻辑地址 A 和页面大小 L：
        *   页号 `P = INT(A / L)` (整除)
        *   页内地址 $d = A \mod L$ (取余)
    *   例如：页面大小 L=1KB (1024B)，逻辑地址 A=2170B。
        *   P = INT(2170 / 1024) = 2
        *   d = 2170 MOD 1024 = 122
        *   即该地址在逻辑空间的第2页，页内偏移为122。

### 3. 页表 (Page Table)

*   **目的 (Purpose):** 由于进程的页面可以离散地存放在内存的任何物理块中，系统需要记录逻辑页面到物理块的映射关系，以便在执行时能找到每个页面对应的物理位置。
*   **结构 (Structure):** 系统为每个进程建立一张**页表 (Page Table)**。进程逻辑地址空间中的每一页，在页表中都有一个对应的**页表项 (Page Table Entry, PTE)**。
*   **内容 (Contents):** 每个页表项至少包含该逻辑页在内存中对应的**物理块号 (Physical Block Number)**。
*   **作用 (Function):** 实现从**页号**到**物理块号**的地址映射。
*   **存取控制 (Access Control):** 页表项中通常还包含存取控制字段（如读/写/执行权限），用于内存保护。若进程试图进行非法访问（如对只读页进行写操作），会引发操作系统中断。
*   **虚拟存储支持 (Virtual Memory Support):** 若系统支持虚拟存储，页表项中还需包含其他信息，如页面是否在内存中、是否被修改过等（本章后续或虚拟存储章节会详述）。

**图 4-14 页表的作用示意图 (Page Table Function Diagram)**
![[image-90.png]]
*解析：该图展示了一个用户程序的逻辑页面（0页至n页）如何通过页表映射到内存中的物理块。例如，逻辑0页映射到物理2#块，逻辑1页映射到物理3#块，逻辑2页映射到物理6#块等。页表存储了这种页号到块号的对应关系。*

---

## 4.5.2 地址变换机构 (Address Translation Mechanism)

为了将用户地址空间中的逻辑地址转换为内存空间中的物理地址，系统中必须设置地址变换机构。
*   **基本任务 (Basic Task):** 实现从逻辑地址到物理地址的转换。
*   **分页系统中的转换 (Translation in Paging System):** 页内地址 W 在逻辑地址和物理地址中是相同的，因此地址变换的核心是将逻辑地址中的**页号 P** 转换为内存中的**物理块号 F**。
*   **硬件实现 (Hardware Implementation):** 地址变换频率极高（每条指令的地址都可能需要），因此必须由硬件实现。

### 1. 基本的地址变换机构 (Basic Address Translation Mechanism)

*   **页表存放位置 (Page Table Location):** 页表通常存放在内存中（因为页表可能很大，寄存器成本高且数量有限）。
*   **页表寄存器 (PTR - Page-Table Register):**
    *   系统中设置一个页表寄存器，存放当前运行进程的页表在内存中的**始址 (Base Address)** 和页表的**长度 (Length)**。
    *   进程未执行时，这些信息存放在其进程控制块(PCB)中。当进程被调度执行时，其页表始址和长度被装入页表寄存器。
    *   单处理机环境下，通常只需要一个页表寄存器。
*   **变换过程 (Translation Process - CPU accesses logical address (P, W)):**
    1.  **页号越界检查 (Page Number Boundary Check):** 将逻辑地址中的页号 P 与页表寄存器中的页表长度进行比较。
        *   如果 `P >= 页表长度`，则表示访问越界，产生地址越界中断。
    2.  **计算页表项地址 (Calculate Page Table Entry Address):** 如果未越界，则 `页表项地址 = 页表始址 + P * 页表项大小`。
    3.  **获取物理块号 (Fetch Physical Block Number):** 访问内存，根据计算出的页表项地址，从页表中读取该页号 P 对应的物理块号 F。
    4.  **形成物理地址 (Form Physical Address):** `物理地址 = F * 页面大小 + W` (或者将 F 和 W 直接拼接，如果 F 和 W 的位数设计得当)。
    5.  使用形成的物理地址访问内存。
*   **缺点 (Drawback):** 每次访问内存数据，都需要**两次**内存访问：
    1.  第一次访问内存中的页表。
    2.  第二次访问实际的物理内存单元。
    这使得CPU的处理速度降低近一半。

**图 4-15 分页系统的地址变换机构 (Address Translation Mechanism in Paging System)**
![[image-91.png]]
*解析：该图展示了基本分页系统中的地址变换过程。CPU发出的逻辑地址分为页号和页内地址。页号与页表寄存器中的页表长度比较（越界检查）。若未越界，页号与页表始址结合（通过加法和乘页表项大小）得到该页在页表中的条目地址。访问内存中的页表，获取物理块号。此物理块号与逻辑地址中的页内地址拼接，形成最终的物理地址，用于访问主存。*

### 2. 具有快表的地址变换机构 (Address Translation Mechanism with TLB)

为了解决两次访存导致的速度下降问题，引入了**快表 (Translation Lookaside Buffer, TLB)**。
*   **快表 (TLB):**
    *   也称为**联想寄存器 (Associative Memory)**。
    *   是一种具有并行查询能力的高速缓冲寄存器。
    *   用于存放当前访问最频繁的那些页表项（一部分或全部）。
*   **变换过程 (Translation Process - CPU accesses logical address (P, W)):**
    1.  CPU给出逻辑地址后，地址变换机构自动将页号 P 送入快表，并与快表中的所有页号进行**并行比较 (Parallel Comparison)**。
    2.  **快表命中 (TLB Hit):**
        *   如果在快表中找到了与 P 匹配的页号，表示所需页表项在快表中。
        *   直接从快表中读出该页对应的物理块号 F。
        *   用 F 和 W 形成物理地址并访问内存。
        *   访问速度快，只需一次内存访问（实际数据）。
    3.  **快表未命中 (TLB Miss):**
        *   如果在快表中未找到匹配的页号 P。
        *   则仍需访问内存中的主存页表（如基本地址变换机构）。
        *   从主存页表中查到对应的页表项后，获得物理块号 F。
        *   同时，将该页表项 (P, F) **存入快表 (Store in TLB)** 的一个单元中（若快表已满，则按某种替换算法替换一个旧的条目）。
        *   用 F 和 W 形成物理地址并访问内存。
*   **性能 (Performance):**
    *   快表的成本较高，容量有限（如书中提到的16~512个页表项）。
    *   由于程序的**局部性原理 (Principle of Locality)**，快表的命中率通常很高（如90%以上）。
    *   引入快表后，地址变换造成的速度损失可显著降低（如降至10%以下）。

**图 4-16 具有快表的地址变换机构 (Address Translation Mechanism with TLB)**
![[image-92.png]]
*解析：该图展示了带快表的地址变换过程。逻辑地址的页号首先送入快表（联想寄存器）进行并行查找。若命中，直接从快表得到物理块号，与页内地址拼接成物理地址。若未命中，则按基本方式访问内存中的页表，找到物理块号，形成物理地址，并将此页表项（页号、块号）调入快表。页表寄存器（存页表始址和长度）在快表未命中时使用。*

---

## 4.5.3 访问内存的有效时间 (Effective Access Time, EAT)

EAT是指从进程发出指定逻辑地址的访问请求，经过地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所花费的总时间。

*   设访问一次内存的时间为 `t`。
*   设访问一次快表的时间为 `λ` (通常 `λ << t`，例如 `λ=20ns, t=100ns`)。
*   设快表命中率为 `a`。

*   **基本分页存储管理方式 (无快表 - Basic Paging without TLB):**
    `EAT = t (访问页表) + t (访问数据) = 2t`

*   **具有快表的分页存储管理方式 (Paging with TLB):**
    *   访问快表命中时，总时间 = `λ (查快表) + t (访问数据)`。
    *   访问快表未命中时，总时间 = `λ (查快表) + t (访问主存页表) + t (访问数据)`。
    *   所以，`EAT = a * (λ + t) + (1-a) * (λ + t + t)`
    *   书中给出的公式 `EAT = a*λ + (t+λ)(1-a) + t` 也可以理解为：`a*λ` (命中时查快表时间) + `(1-a)*(t+λ)` (未命中时查主存页表和快表的时间) + `t` (最终访问数据的时间)。
        *   简化后为 `EAT = a*λ + (1-a)*(λ+t) + t` （这与前面推导的 `a * (λ + t) + (1-a) * (λ + t + t)` 一致）

    **书中示例 (λ=20ns, t=100ns - Book Example):**

    | 命中率 (a) (Hit Rate) | 有效访问时间 (EAT) (ns) (Effective Access Time) |
    | ----------------- | ------------------------------------------------- |
    | 0%                | 220 (即 20+100+100)                               |
    | 50%               | 170                                               |
    | 80%               | 140                                               |
    | 90%               | 130                                               |
    | 98%               | 122                                               |

    可见，引入快表后，CPU访问数据的平均耗时明显减少。

---

## 4.5.4 两级和多级页表 (Two-Level and Multi-Level Page Tables)

现代计算机系统支持非常大的逻辑地址空间（如32位可达4GB，64位则更大）。这会导致一级页表本身变得非常巨大，难以在内存中找到连续空间存放，且占用内存过多。

*   **问题 (Problem):**
    *   例如，32位逻辑地址，页面大小4KB (2^12 B)。则页号占20位 (2^20 = 1M个页表项)。若每个页表项占4字节，则页表大小为 1M * 4B = 4MB。
    *   要求这4MB页表是连续存放的，这在内存中可能难以满足。

*   **解决思路 (Solution Approaches):**
    1.  对页表本身也进行分页，使其可以离散存储 (即两级或多级页表)。
    2.  只将当前需要的部分页表项调入内存 (结合虚拟存储技术)。

### 1. 两级页表 (Two-Level Page Table)

*   将一级页表再进行分页，每个页表“页”的大小与内存物理块大小相同。
*   为这些离散存放的页表“页”再建立一张更高层次的页表，称为**外层页表 (Outer Page Table)** 或 **页目录表 (Page Directory Table)**。外层页表的每个表项记录了某个页表“页”所在的物理块号。
*   **逻辑地址结构 (以32位，4KB页面为例 - Logical Address Structure (e.g., 32-bit, 4KB page)):**
    *   假设每个页表“页”也能容纳1024个页表项 (4KB / 4B每项 = 1024项)。
    *   则原来的20位页号可以进一步划分为：

    | 外层页号 P1 (10位) | (二级)页内页号 P2 (10位) | 页内地址 d (12位) |
    | ------------------ | ---------------------- | ----------------- |
    | (用于索引外层页表)     | (用于索引二级页表)         | (页内偏移)        |

*   **地址变换过程 (Address Translation Process):**
    1.  系统中设置**外层页表寄存器 (Outer Page Table Register)**，存放外层页表的始址。
    2.  根据逻辑地址中的外层页号 P1，在外层页表中找到对应的表项，获得二级页表的始址。
    3.  根据逻辑地址中的二级页内页号 P2，在对应的二级页表中找到表项，获得该逻辑页最终存放的物理块号 F。
    4.  用物理块号 F 和页内地址 d 形成物理地址。
*   **优点 (Advantages):**
    *   解决了大页表需要连续存储空间的问题。
    *   在结合虚拟存储时，不必将所有二级页表都调入内存，只需调入当前需要用到的二级页表页和外层页表即可，节省内存。
*   **缺点 (Disadvantages):**
    *   地址变换次数增加。无快表时，访问一次数据需要三次访存（一次访问外层页表，一次访问二级页表，一次访问实际数据）。因此，TLB对于多级页表系统更为关键。

**图 4-17 两级页表的逻辑地址结构 (Logical Address Structure for Two-Level Page Table)**
![[image-93.png]]
*解析：该图展示了两级页表模式下32位逻辑地址的划分。P1是外层页号（或称页目录索引），P2是外层页内地址（或称二级页表索引），d是页内偏移量。例如，图中22-31位为P1，12-21位为P2，0-11位为d。*

**图 4-18 具有两级页表的地址变换机构 (Address Translation Mechanism with Two-Level Page Table)**
![[image-94.png]]
*解析：该图展示了两级页表的地址变换过程。外层页表寄存器（图中未显式标出，但其功能是提供外部页表的基址）和逻辑地址中的P1（外层页号）用于索引外部页表（图左侧），得到二级页表的基址（例如1011#块是0#二级页表的基址）。然后用P2（二级页号）索引该二级页表，得到最终的物理块号（例如物理块1）。该物理块号与页内地址d拼接形成最终物理地址。图中示例：逻辑页(P1=0, P2=0) -> 物理块1；逻辑页(P1=0, P2=1) -> 物理块4；逻辑页(P1=n, P2=0) -> 物理块1468。*

*   **页表分页的按需调入 (On-demand Paging of Page Tables - mentioned on Page 25):**
    *   在外层页表的表项中可以增设一个状态位 S。
    *   S=0 表示该外层页表项对应的二级页表页尚未调入内存。
    *   S=1 表示已调入内存。
    *   当访问到 S=0 的表项时，产生中断，由OS负责将相应的二级页表页调入内存。

### 2. 多级页表 (Multi-Level Page Table)

*   对于32位机器，两级页表通常是合适的。
*   对于64位机器，逻辑地址空间极大，即使是外层页表本身也可能非常大。因此需要更多级的分页。
    *   例如，64位地址，4KB页面（12位页内地址），剩下52位用于页号。如果每级页表索引占10位，则可能需要 `52/10 ≈ 5` 级页表。
*   **实际应用 (Practical Application):**
    *   现代64位OS通常不会使用全部64位逻辑地址空间，而是限制一个较小的可直接寻址范围（如书中提到的45位，2^45），这样三级或四级页表就足够。

---

## 4.5.5 反置页表 (Inverted Page Table, IPT)

传统页表（每个进程一张）的主要问题是当进程数量多或逻辑地址空间大时，页表本身会占用大量内存。反置页表是为了解决这个问题而提出的。

### 1. 反置页表的引入 (Introduction of Inverted Page Table)

*   **核心思想 (Core Idea):** 系统中只维护**一张**全局的页表，而不是为每个进程都维护一张页表。
*   **结构 (Structure):** 这张全局页表的表项数量与物理内存的**物理块数量**相同。每个表项记录了占用该物理块的进程的**进程标识符(PID)** 和该进程的**逻辑页号(P)**。
*   **索引 (Indexing):** 表项按物理块号排序。即第 `i` 个表项对应物理内存的第 `i` 块。
*   **优点 (Advantages):**
    *   极大地减少了页表所占用的内存空间。页表大小只与物理内存大小有关，与逻辑地址空间大小和进程数量无关。
    *   例如：64MB物理内存，4KB页面，则有 16K (64MB/4KB) 个物理块。反置页表只需16K个表项。若每个表项4字节，则IPT总大小为64KB，远小于传统多进程环境下的页表总和。

### 2. 地址变换 (Address Translation)

*   **过程 (Process):**
    1.  当进程访问逻辑地址 (PID, P, W) 时，系统需要在反置页表中查找是否存在一个表项，其内容为 (PID, P)。
    2.  **找到匹配 (Match Found):** 如果在反置页表的第 `i` 个表项中找到了匹配项 (PID, P)，则说明该逻辑页存放在物理内存的第 `i` 块中。物理地址即为 `i` (块号) 和 W (页内地址) 的组合。
    3.  **未找到匹配 (Match Not Found):**
        *   对于不具有请求调页功能的系统：表示地址错误。
        *   对于具有请求调页功能的系统：表示该页不在内存中，产生缺页中断，系统将此页调入内存。
*   **查找效率问题 (Search Efficiency Problem):**
    *   由于反置页表是根据物理块号组织的，要查找 (PID, P) 组合，线性搜索整个表会非常慢。
*   **解决方案 (Solution):**
    *   通常采用**哈希表 (Hash Table)** 来辅助查找。将 (PID, P) 通过哈希函数计算得到一个哈希值，该值作为哈希表的索引，哈希表对应项指向反置页表中的相关条目或条目链（处理哈希冲突）。这样可以大大加快查找速度。
*   **外部页表 (External Page Table):**
    *   反置页表只包含已调入内存的页面的信息。对于尚未调入内存的页面，还需要为每个进程维护一个外部页表（类似于传统页表，但可以存放在磁盘上），用于在缺页中断时定位页面在磁盘上的位置。
*   **应用 (Application):** IBM的一些系统（如AS/400, IBM RISC System, IBM RT）采用反置页表。

---