好的，这是重新排版后的学习笔记，力求体现清晰的层级结构：

---

## 4.6 分段存储管理方式 (Comprehensive Notes)

### 引言
在操作系统发展的过程中，存储管理技术经历了从连续分配（单一连续、固定分区、动态分区）到离散分配的演进。分页存储管理是离散分配的一种重要方式，它将进程的逻辑地址空间和物理内存都划分为固定大小的“页”和“块”，有效地解决了外部碎片问题，提高了内存利用率。然而，分页完全是操作系统的行为，对用户是透明的，“页”本身并不是一个具有完整逻辑意义的单位。为了更好地满足用户在程序设计、信息共享、保护以及动态内存需求等方面的要求，**分段存储管理方式 (Segmentation Memory Management)** 应运而生。

### 核心思想与定义
分段存储管理是**一种根据程序的逻辑结构来划分其地址空间的内存管理技术**。它将用户进程的地址空间按照其**逻辑功能和模块化特性**，划分为若干个**逻辑段 (Segment)**。每个段都是一个逻辑上相对独立的、具有特定意义的地址单元，例如：

*   主程序代码段 (Main Program Code Segment)
*   子程序/函数段 (Subroutine/Function Segment)
*   全局数据段 (Global Data Segment)
*   共享库段 (Shared Library Segment)
*   堆栈段 (Stack Segment)
*   符号表段 (Symbol Table Segment)
*   常量段 (Constant Segment)

### 关键特性
*   **逻辑单位**：段是信息的逻辑单位，其划分依据是程序的内在结构和用途。
*   **段长可变**：每个段的长度由其包含的逻辑信息量决定，因此不同段的长度通常是不同的。
*   **用户可见性**：分段的概念对程序员是可见的（至少在逻辑层面）。程序员可以按段组织其程序和数据，并可以引用段名（或段号）和段内地址。
*   **二维地址空间**：进程的逻辑地址由两部分组成：**段号 (Segment Number)** 和 **段内偏移量 (Offset within Segment)**。

### 与分页的根本区别
分页的划分是为了系统管理的方便，对用户透明，是物理单位；分段的划分是基于程序的逻辑结构，对用户有意义，是逻辑单位。

---

### 4.6.1 分段存储管理方式的引入（引入分段的动机和需求）
引入分段存储管理主要是为了满足以下几个方面的需求，这些需求是单纯的分页管理难以有效满足的：

1.  **方便编程 (Convenience of Programming)**
    *   **模块化编程**：现代软件开发强调模块化设计。程序员习惯于将一个复杂的程序分解为多个功能模块（如主程序、各种子程序、数据结构等）。分段管理允许将这些逻辑模块映射为独立的段，使得程序的逻辑结构与内存中的组织结构相对应。
    *   **独立编译与链接**：不同的段可以独立编译。在链接时，可以将编译好的段组合起来形成可执行程序。这种方式便于团队协作和代码复用。
    *   **清晰的地址引用**：程序员可以使用“段名+段内偏移”的方式来思考和引用地址，这比使用一个单一的、巨大的线性地址空间更直观、更易于理解和调试。例如，访问某个特定数据结构中的元素，如果该数据结构是一个段，那么地址引用就是相对于该数据段的起始位置。

2.  **信息共享 (Information Sharing)**
    *   **以逻辑单位共享**：共享的需求通常是针对具有完整逻辑意义的程序或数据块。例如，多个用户可能需要共享同一个编辑器程序（代码段），或者共享一个公用的数据库（数据段）。
    *   **分段的优势**：
        *   **精确共享**：可以精确地共享一个完整的逻辑段，而不会像分页那样可能只共享一个页的一部分（如果一个逻辑实体跨页且页内还有其他非共享内容）。
        *   **易于管理**：在段表中，只需让不同进程的段表项指向内存中同一个共享段的物理副本即可。
        *   **可重入代码（纯代码）的实现**：对于代码段，如果它是可重入的（即执行过程中不修改自身，所有进程特定的数据存放在各自的私有数据段或堆栈段中），那么它可以被多个进程安全地共享，只需在内存中保留一份副本，极大地节省了内存。
    *   **分页共享的局限性**：一个逻辑上完整的共享模块可能被分割到多个页中，管理起来较为复杂。如果共享模块的边界与页边界不对齐，可能会导致共享不必要的额外数据，或者需要更复杂的机制来处理部分共享的页。

3.  **信息保护 (Information Protection)**
    *   **以逻辑单位保护**：对信息的保护也应该基于其逻辑属性。例如，代码段通常应设置为只读和可执行，数据段可能设置为可读写，而某些敏感数据段可能具有更严格的访问限制。
    *   **分段的优势**：
        *   **精细化控制**：可以为每个段独立设置访问权限（如读、写、执行、追加等）。
        *   **与逻辑一致**：保护的粒度与信息的逻辑单位相匹配，更符合安全需求。
    *   **分页保护的局限性**：一个页中可能混合了不同保护属性的内容（例如，一个页的开头是只读代码，末尾是可写数据）。在这种情况下，很难对整个页实施单一的、恰当的保护策略。如果以页为单位进行保护，可能会过于宽松或过于严格。

4.  **动态增长 (Dynamic Growth of Segments)**
    *   在程序运行期间，某些数据结构（如堆、栈、某些类型的表格或缓冲区）的大小可能会动态变化。
    *   **分段的优势**：如果这些动态增长的数据结构被组织成独立的段，那么系统可以更容易地处理其大小变化。例如，当一个栈段需要更多空间时，如果其相邻的物理内存区域是空闲的，可以扩展该段的长度（更新段表中的段长信息）。如果相邻区域不空闲，可能需要操作系统为其分配一个新的、更大的内存区域，并将原有内容拷贝过去（类似于动态分区的“紧凑”，但只针对单个段的移动）。
    *   **分页的局限性**：页的大小是固定的。虽然可以通过分配更多的页来间接支持逻辑实体的增长，但这与段的“逻辑整体动态增长”的概念不同。

5.  **动态链接 (Dynamic Linking)**
    *   **按需加载和链接**：动态链接是指在程序执行到需要某个外部模块（如共享库中的函数）时，才将该模块加载到内存并将其链接到调用者的地址空间。
    *   **分段的优势**：由于段是逻辑单位，非常适合作为动态链接的基本单元。当需要一个外部库时，可以将该库作为一个或多个段调入内存，并更新调用进程的段表来建立链接。
    *   **编译时未知大小和地址**：动态链接的模块在编译时其确切的内存地址和大小可能未知，分段管理能够较好地适应这种情况。

---

### 4.6.2 分段系统的基本原理与实现
为了实现分段存储管理，系统需要提供相应的硬件和软件支持。

1.  **分段 (Segmentation Process)**
    *   **逻辑地址空间的划分**：在编译或链接阶段，用户的程序和数据被划分为若干个逻辑段。每个段被赋予一个唯一的**段名**（通常由编译器内部转换为**段号**）。
        *   ![[image-82.png]]
    *   **段的属性确定**：每个段都有一个**段内地址空间**，从0开始编址，最大地址为其**段长**。段长由段内包含的实际代码或数据量决定。
    *   **二维逻辑地址**：程序中使用的逻辑地址不再是单一的线性地址，而是由两部分组成的二维地址：
        *   **段号 S (Segment Number)**：用于指定要访问哪一个段。
        *   **段内偏移量 d (Offset / Displacement within Segment)**：用于指定在选定段内的具体位置。
        *   例如，一个32位系统的逻辑地址可以划分为：高16位为段号S（允许 `2^16` = 65536个段），低16位为段内偏移d（每个段的最大长度为 `2^16`B = 64KB）。

2.  **段表 (Segment Table)**
    *   **目的**：由于进程的各个段被离散地装入到物理内存的不同区域，操作系统必须为每个进程维护一张**段表**，以记录其所有段的映射信息。段表的作用是实现从**逻辑段号到物理内存基地址的转换**。
    *   **结构**：段表是一个由**段表项 (Segment Table Entry, STE)** 组成的数组。每个段表项对应进程的一个逻辑段。
    *   **段表项 (STE) 的内容**：
        *   **段基址 (Base Address)**：该段在物理内存中的起始地址。
        *   **段长/界限 (Limit / Length)**：该段的实际长度。
        *   **各种标志位 (Flags / Status Bits)**：
            *   **存在位/有效位 (Present/Valid Bit)**: `P`。
            *   **访问权限位 (Protection Bits)**: `R/W/X`。
            *   **已修改位 (Dirty/Modified Bit)**: `M`。
            *   **已访问位 (Accessed Bit)**: `A`。
            *   其他可能的标志位。
    *   **段表的位置**：段表本身也存储在物理内存中。
    *   ![[image-83.png]]

3.  **地址变换机构 (Address Translation Mechanism)**
    实现从二维逻辑地址 (S, d) 到一维物理地址的转换，通常由专门的硬件（内存管理单元 MMU 的一部分）完成。
    *   ![[image-84.png]]
    *   **硬件支持**：
        *   **段表寄存器 (Segment Table Register, STR)**：
            *   **段表基址 (Segment Table Base Address)**。
            *   **段表长度 (Segment Table Limit)**。
    *   **地址变换过程**：
        1.  CPU要访问一个逻辑地址 (S, d)。
        2.  **段号合法性检查**：`S >= TL` ? (TL: 段表长度) -> 中断。
        3.  **定位段表项**：`段表项地址 = 段表基址 + S * 大小(STE)`。
        4.  **访问段表项**：读取段基址 (Base_S), 段长 (Limit_S), 标志位。
        5.  **(可选) 存在位检查**：P=0 ? -> 缺段中断。
        6.  **段内偏移量越界检查**：`d >= Limit_S` ? -> 中断。
        7.  **(可选) 权限检查**：违反权限? -> 保护性中断。
        8.  **计算物理地址**：`物理地址 = 段基址_S + 段内偏移量_d`。
        9.  **访问物理内存**。
    *   **性能考虑与快表 (TLB)**：
        *   TLB缓存最近使用过的段表项。
        *   **TLB命中 (Hit)**：直接从TLB获取信息，加快转换。
        *   **TLB未命中 (Miss)**：访问主存段表，并将条目加载到TLB。

---

### 4.6.3 信息共享在分段系统中的实现
分段系统为实现程序和数据的共享提供了非常自然和方便的机制。

1.  **共享段的原理**：
    *   ![[image-85.png]]
    *   多个进程的段表项中的**段基址都指向物理内存中该共享段的同一个起始位置**。
2.  **可重入代码 (Reentrant Code) / 纯代码 (Pure Code)**：
    *   ![[image-86.png]]
    *   特性：不修改自身；进程局部数据分离。
    *   通常标记为只读和可执行。
3.  **共享数据段**：
    *   只读数据段：共享方式类似代码段。
    *   可读写数据段：需要同步机制。
4.  **共享段的段号**：
    *   在不同进程中可以不同。
5.  **示例 (P30, 图4-22 的详细解释)**：
    *   (对编辑器代码段共享的例子说明)
        *   进程1段表：`{S1_editor: {Base: Pa_editor_base, Limit: L_editor, ...}}`
        *   进程2段表：`{S2_editor: {Base: Pa_editor_base, Limit: L_editor, ...}}`

---

#### **分页和分段的主要区别 (P29表格的展开与深化)**

| 特性             | 分页存储管理 (Paging)                                                                                                | 分段存储管理 (Segmentation)                                                                                                   |
| :--------------- | :------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- |
| **基本单位**     | **页 (Page)**                                                                                                        | **段 (Segment)**                                                                                                             |
| **单位性质**     | 信息的**物理单位**。                                                                                                    | 信息的**逻辑单位**。                                                                                                        |
| **单位大小**     | **固定大小**。                                                                                                      | **可变大小**。                                                                                                             |
| **地址空间**     | **一维线性地址空间**。                                                                                                   | **二维地址空间** (段号, 段内偏移量)。                                                                                            |
| **用户可见性**   | 对应用程序员**完全透明**。                                                                                               | 对应用程序员**可见** (概念上)。                                                                                                |
| **产生原因**     | 主要为了**克服外部碎片**，提高内存利用率，实现虚拟存储。                                                                   | 主要为了**满足用户编程方便性、信息共享、保护、动态链接/增长**等。                                                               |
| **碎片类型**     | **内部碎片 (Internal Fragmentation)**。                                                                                 | **外部碎片 (External Fragmentation)**。                                                                                         |
| **地址转换**     | 通过**页表**。                                                                                                       | 通过**段表**。两次越界检查。                                                                                                     |
| **内存分配**     | 相对简单（找空闲物理块）。                                                                                                | 相对复杂（类似动态分区，找连续空间）。                                                                                             |
| **共享实现**     | 页级共享，管理较复杂。                                                                                                  | 段级共享，自然方便。                                                                                                      |
| **保护实现**     | 页级保护，不灵活。                                                                                                    | 段级保护，符合逻辑。                                                                                                      |

---

### 分段系统的优点总结
1.  **模块化与结构化**
2.  **易于实现信息共享**
3.  **易于实现信息保护**
4.  **支持动态链接**
5.  **支持动态增长**
6.  **代码和数据的分离**

### 分段系统的缺点总结
1.  **外部碎片 (External Fragmentation)**
    *   **解决方案**：内存紧凑 (Compaction)，但耗时。
2.  **内存分配的复杂性**
3.  **地址转换的潜在开销** (TLB缓解)
4.  **段交换的开销** (虚拟分段时)

---
---

## 4.6.4 段页式存储管理方式 (Segmented Paging Memory Management)

### 引言
为了**集分页和分段的优点于一身，同时克服它们各自的缺点**，操作系统引入了**段页式存储管理方式**。
*   **分页优点**：无外部碎片，物理内存管理简单。
*   **分页缺点**：页非逻辑单位，共享保护不便。
*   **分段优点**：逻辑单位，共享保护方便。
*   **分段缺点**：外部碎片，内存分配复杂。

### 核心思想
**先将用户程序的地址空间按照其逻辑结构划分为若干个逻辑段，然后再将每个段的地址空间划分为若干个固定大小的页**。物理内存也同样划分为与页面大小相等的物理块。内存分配时，以页为单位。

**简言之：段是逻辑划分，页是物理分配。一个段由若干页组成。**

---

### 1. 基本原理与地址结构
![[image-87.png]]

1.  **地址空间的划分**：
    *   **第一步：分段 (Segmentation)**：按逻辑结构划分段。
    *   **第二步：分页 (Paging within Segments)**：每个段内部再划分页。
    *   ![[image-88.png]]

2.  **逻辑地址结构**：
    由三部分组成：**段号 S**, **段内页号 P**, **页内偏移量 W**。
    *   示例： `| 段号 S (8 bits) | 段内页号 P (12 bits) | 页内偏移 W (12 bits, 4KB pages) |`
        *   `2^8 = 256` 个段。
        *   每个段 `2^12 = 4096` 个页。
        *   页大小 `2^12 B = 4KB`。
        *   段最大长度 `16MB`。

3.  **内存分配**：
    *   物理内存划分为**物理块 (Frames)**。
    *   以页为单位分配，一个段内的页可离散存放。

---

### 2. 数据结构：段表和页表
每个进程维护两级映射表：

1.  **段表 (Segment Table)**：
    *   每个进程一张段表。
    *   **段表项 (STE) 的主要内容**：
        *   **页表基址 (Page Table Base Address)**：该段对应页表的物理起始地址。
        *   **页表长度 (Page Table Length)**：该段包含的页数（用于检查P）。
        *   段的保护信息。
        *   段的存在位。

2.  **页表 (Page Table)**：
    *   **每个段都有一张自己的页表**。
    *   **页表项 (PTE) 的主要内容**：
        *   **物理块号 (Frame Number)**。
        *   页的存在位/有效位 (P=0 -> 缺页中断)。
        *   页的保护信息 (可选)。
        *   已修改位 (Dirty Bit)。
        *   已访问位 (Accessed Bit)。

---

### 3. 地址变换过程
![[image-89.png]]
从逻辑地址 (S, P, W) 到物理地址的转换：

1.  **获取段表基址**：从 **段表寄存器 (STR)** (含段表基址, 段表长度 TL_segment)。

2.  **访问段表**：
    a.  **段号越界检查**: `S >= TL_segment`? -> 中断。
    b.  **定位段表项**: `STE地址 = STR.base + S * 大小(STE)`。
    c.  **读取段表项**: 获取 **页表基址 (Base_page_table)** 和 **页表长度 (TL_page_table)**。

3.  **访问页表**：
    a.  **段内页号越界检查**: `P >= TL_page_table`? -> 中断。
    b.  **定位页表项**: `PTE地址 = Base_page_table + P * 大小(PTE)`。
    c.  **读取页表项**: 获取 **物理块号 (Frame_Number)**。
    d.  **存在位检查**: PTE.Present_Bit = 0? -> **缺页中断 (Page Fault)**。

4.  **形成物理地址**：
    *   `物理地址 = Frame_Number * Page_Size + W`。

5.  **访问物理内存**。

**性能考虑与TLB**：
*   最坏情况：**三次内存访问** (段表 -> 页表 -> 实际数据)。
*   TLB缓存 (S, P) -> Frame_Number 映射。
    *   **TLB命中**：一次TLB查找 + 一次内存访问。
    *   **TLB未命中**：三次内存访问，然后加载到TLB。

---

### 4. 段页式系统的优缺点

**优点**：
1.  **结合了分段和分页的优点**：
    *   **逻辑清晰性 (来自段)**：便于编程、共享、保护。
    *   **内存利用率高 (来自页)**：消除外部碎片，只有少量内部碎片。
    *   **物理内存管理简单 (来自页)**。
2.  **良好的共享和保护机制** (段级为主)。
3.  **支持虚拟存储** (通过缺页中断)。

**缺点**：
1.  **系统复杂性增加**：
    *   **硬件要求更高** (MMU, TLB)。
    *   **软件管理更复杂** (段表 + 多页表)。
2.  **地址转换开销更大** (无TLB时三次访存)。
    *   性能高度依赖TLB命中率。
3.  **存储开销增加** (段表 + 各段的页表)。

---

### 5. 与纯分页、纯分段的比较总结

| 特性         | 纯分页 (Paging)             | 纯分段 (Segmentation)               | 段页式 (Segmented Paging)           |
| :--------- | :----------------------- | :------------------------------- | :------------------------------- |
| **逻辑划分**   | 无，对用户透明                  | 按逻辑段划分，用户可见                      | 先按逻辑段划分，段内再分页                |
| **物理分配单位** | 页 (固定大小)                 | 段 (可变大小)                         | 页 (固定大小)                     |
| **地址结构**   | (页号, 页内偏移)               | (段号, 段内偏移)                       | (段号, 段内页号, 页内偏移)            |
| **外部碎片**   | 无                        | 有                                | 无 (物理分配按页)                  |
| **内部碎片**   | 有 (最后一页)                 | 基本无                             | 有 (每个段的最后一页)              |
| **共享**     | 页级共享，不直观                 | 段级共享，直观方便                        | 段级共享，直观方便                   |
| **保护**     | 页级保护，不灵活                 | 段级保护，灵活                          | 段级保护为主，也可页级补充             |
| **地址转换访存** | 2次 (无TLB)                | 2次 (无TLB)                        | 3次 (无TLB)                   |
| **数据结构**   | 每个进程1个页表 (可能多级)       | 每个进程1个段表                         | 每个进程1个段表，每个段1个页表          |
| **系统复杂度**  | 相对简单                     | 中等                               | 较高                          |

---