

*   **4.2 程序的装入和链接 (Program Loading and Linking)**
    *   **核心流程 (Core Process):** 用户程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可以执行的程序。这通常需要经过以下几个步骤 (如图 4-2 所示)：
        *   ![[image-58.png]]
        *   **编译 (Compilation):** 由编译程序 (Compiler) 对用户源程序进行编译，形成若干个**目标模块 (Object Module)**。
        *   **链接 (Linking):** 由链接程序 (Linker) 将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的**装入模块 (Load Module)**。
        *   **装入 (Loading):** 由装入程序 (Loader) 将装入模块装入内存。
    *   **4.2.1 程序的装入 (Program Loading)**
        *   为了阐述方便，先介绍无需链接的单个目标模块的装入过程。该目标模块即为装入模块。将一个装入模块装入内存时，有以下三种装入方式：
        *   **1. 绝对装入方式 (Absolute Loading Mode)**
            *   **适用场景 (Applicable Scenarios):** 计算机系统很小，且仅能运行单道程序时。
            *   **前提 (Prerequisite):** 完全有可能知道程序将驻留在内存的什么位置。
            *   **编译结果 (Compilation Result):** 用户程序经编译后，将产生**绝对地址 (即物理地址)** 的目标代码。
                *   例如：事先已知用户程序驻留在从 R 处开始的位置，则编译程序所产生的目标模块便可从 R 处开始向上扩展。
            *   **装入过程 (Loading Process):** 绝对装入程序便可按照装入模块中的地址，将程序和数据装入内存。
            *   **地址转换 (Address Translation):** 装入模块被装入内存后，由于程序中的相对地址 (逻辑地址) 与实际内存地址完全相同，故不需对程序和数据的地址进行修改。
            *   **绝对地址的来源 (Source of Absolute Addresses):**
                *   可在编译或汇编时给出。
                *   可由程序员直接赋予。
            *   **程序员赋予绝对地址的缺点 (Drawbacks of Programmer-assigned Absolute Addresses):**
                *   要求程序员熟悉内存的使用情况。
                *   一旦程序或数据被修改后，可能要改变程序中的所有地址。
            *   **通常做法 (Common Practice):** 宁可在程序中采用符号地址，然后在编译或汇编时，再将这些符号地址转换为绝对地址。
            *   **局限性 (Limitation):** 只适用于单道程序环境。
        *   **2. 可重定位装入方式 (Relocation Loading Mode)**
            *   **适用场景 (Applicable Scenarios):** 多道程序环境下。
            *   **编译时未知 (Unknown at Compilation Time):** 编译程序不可能预知经编译后所得到的目标模块应放在内存的何处。
            *   **目标模块特点 (Object Module Characteristics):**
                *   用户程序编译所形成的若干个目标模块，它们的起始地址通常都是从 0 开始的。
                *   程序中的其它地址也都是相对于起始地址计算的。
            *   **装入过程 (Loading Process):** 根据内存的具体情况将装入模块装入到内存的适当位置。
            *   **地址重定位 (Address Relocation):** (如图 4-3 所示)
                *   ![[image-59.png]]
                *   采用可重定位装入程序将装入模块装入内存后，会使装入模块中的所有逻辑地址与实际装入内存后的物理地址不同。
                *   **示例:** 用户程序的 1000 号单元处有一条指令 `LOAD 1, 2500` (将 2500 单元中的整数 365 取至寄存器 1)。若将该程序装入内存的 10000 ~ 15000 号单元而不进行地址变换，则在执行 11000 号单元中的指令时，它将仍从 2500 号单元中取数据，导致数据错误。
                *   **正确方法:** 将取数指令中的地址 2500 修改成 12500 (逻辑地址 2500 + 程序在内存中的起始地址 10000)。指令地址也须做同样修改 (逻辑地址 1000 + 起始地址 10000 = 物理地址 11000)。
                *   **重定位 (Relocation):** 把在装入时对目标程序中指令和数据地址的修改过程称为重定位。
            *   **静态重定位 (Static Relocation):** 因为地址变换通常是在进程装入时一次完成的，以后不再改变，故称为静态重定位。
        *   **3. 动态运行时的装入方式 (Dynamic Run-time Loading)**
            *   **可重定位装入的局限 (Limitation of Relocatable Loading):** 可将装入模块装入到内存中任何允许的位置，但并不允许程序运行时在内存中移动位置。
            *   **动态移动的需求 (Need for Dynamic Movement):** 程序在内存中的移动，意味着它的物理位置发生了变化，这时必须对程序和数据的地址 (绝对地址) 进行修改后方能运行。
            *   **实际情况 (Actual Scenarios):** 在运行过程中它在内存中的位置可能经常要改变 (例如，在具有对换功能的系统中，一个进程可能被多次换出、多次换入，每次换入后的位置通常是不同的)。
            *   **采用方式 (Method Adopted):** 动态运行时装入方式。
            *   **地址转换时机 (Timing of Address Translation):** 装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行。
            *   **装入后地址状态 (Address State After Loading):** 装入内存后的所有地址都仍是逻辑地址。
            *   **硬件支持 (Hardware Support):** 为使地址转换不影响指令的执行速度，这种方式需要一个**重定位寄存器 (Relocation Register)** 的支持。 (详见 4.3 节)
    *   **4.2.2 程序的链接 (Program Linking)**
        *   源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。根据进行链接的时间不同，可把链接分成如下三种：
        *   **1. 静态链接方式 (Static Linking)**
            *   **时机 (Timing):** 在程序运行之前。
            *   **过程 (Process):** 先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。
            *   ![[image-61.png]]
            *   **解决问题 (Problems to Solve - 如图 4-4(a) 所示三个目标模块 A, B, C，长度分别为 L, M, N；模块 A 调用模块 B，模块 B 调用模块 C):**
                *   **(1) 对相对地址进行修改:**
                    *   编译程序产生的所有目标模块中，使用的都是相对地址，其起始地址都为 0。
                    *   链接成一个装入模块后，原模块 B 和 C 在装入模块的起始地址不再是 0，而分别是 L 和 L+M。
                    *   此时须修改模块 B 和 C 中的相对地址：
                        *   把原 B 中的所有相对地址都加上 L。
                        *   把原 C 中的所有相对地址都加上 L+M。
                *   **(2) 变换外部调用符号:**
                    *   将每个模块中所用的外部调用符号也都变换为相对地址。
                    *   例如：把 B 的起始地址变换为 L，把 C 的起始地址变换为 L+M (如图 4-4(b) 所示)。
            *   **可执行文件 (Executable File):** 这种先进行链接所形成的一个完整的装入模块，又称为可执行文件。通常都不再把它拆开，要运行时可直接将它装入内存。
        *   **2. 装入时动态链接 (Load-time Dynamic Linking)**
            *   **过程 (Process):** 将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。
            *   **触发条件 (Trigger):** 在装入一个目标模块时，若发生一个外部模块调用事件。
            *   **链接动作 (Linking Action):**
                *   引起装入程序去找出相应的外部目标模块。
                *   将它装入内存。
                *   按照图 4-4 所示的方式修改目标模块中的相对地址。
            *   **优点 (Advantages):**
                *   **(1) 便于修改和更新:**
                    *   静态链接装配在一起的装入模块，若要修改或更新某个目标模块，则需重新打开装入模块，低效且有时不可能。
                    *   动态链接方式下，各目标模块分开存放，修改或更新非常容易。
                *   **(2) 便于实现对目标模块的共享:**
                    *   静态链接时，每个应用模块都必须含有其目标模块的拷贝，无法实现共享。
                    *   装入时动态链接，OS 很容易将一个目标模块链接到几个应用模块上，实现多个应用程序对该模块的共享。
        *   **3. 运行时动态链接 (Run-time Dynamic Linking)**
            *   **动机 (Motivation):** 许多情况下，应用程序在运行时，每次要运行的模块可能不相同。事先无法知道本次要运行哪些模块，若将所有可能运行到的模块全部装入内存并链接，效率低下，因为往往会有部分目标模块根本不运行 (例如错误处理模块)。
            *   **核心思想 (Core Idea):** 对装入时链接方式的一种改进，将对某些模块的链接推迟到程序执行时才进行。
            *   **过程 (Process):**
                *   在执行过程中，当发现一个被调用模块尚未装入内存时，立即由 OS 去找到该模块。
                *   将之装入内存。
                *   将其链接到调用者模块上。
            *   **优点 (Advantages):**
                *   加快程序的装入过程。
                *   可节省大量的内存空间 (凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上)。