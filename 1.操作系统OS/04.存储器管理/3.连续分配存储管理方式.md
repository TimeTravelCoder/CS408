
**核心思想 (Core Idea):** 为了能将用户程序装入内存，必须为它分配一定大小的内存空间。连续分配方式是最早出现的一种存储器分配方式，曾被广泛应用于上世纪 60~80 年代的 OS 中。
**基本特点 (Basic Characteristic):** 为一个用户程序分配一个**连续的内存空间**。即程序中代码或数据的逻辑地址相邻，体现在内存空间分配时物理地址的相邻。
**分类 (Categories):** 连续分配方式可分为四类：
1.  单一连续分配 (Single Contiguous Allocation)
2.  固定分区分配 (Fixed Partition Allocation)
3.  动态分区分配 (Dynamic Partition Allocation)
4.  动态可重定位分区分配 (Dynamic Relocatable Partition Allocation)

---

## 4.3.1 单一连续分配 (Single Contiguous Allocation)

*   **适用环境 (Applicable Environment):** 单道程序环境下。
*   **内存划分 (Memory Partitioning):** 把内存分为**系统区 (System Area)** 和 **用户区 (User Area)** 两部分。
    *   **系统区:** 仅提供给 OS 使用，通常是放在内存的低址部分。
    *   **用户区:** 仅装有一道用户程序，即整个内存的用户空间由该程序独占。
*   **存储器保护 (Memory Protection):**
    *   早期单用户、单任务操作系统中，不少都配置了存储器保护机构，用于防止用户程序对操作系统的破坏。
    *   但在 20 世纪 80 年代所产生的几种常见的单用户操作系统中 (如 CP/M, MS-DOS, RT11 等)，并未采取存储器保护措施。
        *   **原因 (Reason):**
            *   一方面可以节省硬件；
            *   另一方面在单用户环境下，机器由一用户独占，不可能存在其他用户干扰的问题。
        *   **后果 (Consequence):** 即使出现破坏行为，也仅仅是用户程序自己破坏操作系统，其后果并不严重，只会影响该用户程序的运行，且操作系统也很容易通过系统的再启动而重新装入内存。

---

## 4.3.2 固定分区分配 (Fixed Partition Allocation)

*   **背景 (Background):** 20 世纪 60 年代出现的多道程序系统 (如 IBM 360 的 MFT 操作系统)。
*   **目标 (Goal):** 为了能在内存中装入多道程序，且使这些程序之间又不会发生相互干扰。
*   **方法 (Method):** 将整个用户空间划分为若干个**固定大小的区域**，在每个分区中只装入一道作业。
*   **并发运行 (Concurrent Execution):** 如果内存中有 N 个用户分区，便允许 N 个程序并发运行。
*   **作业调度 (Job Scheduling):** 当有空闲分区时，便可以再从外存的后备作业队列中选择一个适当大小的作业，装入该分区。当该作业结束时，又可再从后备作业队列中找出另一作业调入该分区。
*   **最早、最简单的分区式存储管理方式。**

### 1. 划分分区的方法 (Methods for Partitioning)

*   **(1) 分区大小相等 (Equal-sized Partitions):**
    *   **缺点 (Drawback):** 缺乏灵活性。
        *   程序太小时，会造成内存空间的浪费。
        *   程序太大时，一个分区又不足以装入该程序，致使该程序无法运行。
    *   **适用场景 (Applicable Scenarios):** 利用一台计算机同时控制多个相同对象的场合 (因为这些对象所需的内存空间大小往往相同)。这种划分方式比较方便和实用，所以被广泛采用。
        *   例如：炉温群控系统利用一台计算机去控制多台相同的冶炼炉。
*   **(2) 分区大小不等 (Unequal-sized Partitions):**
    *   **目的 (Purpose):** 增加存储器分配的灵活性。
    *   **划分方法 (Partitioning Method):** 将存储器分区划分为若干个大小不等的分区。最好能对常在该系统中运行的作业大小进行调查，根据用户的需要来划分。
    *   **常见配置 (Common Configuration):** 把内存区划分成含有多个较小的分区、适量的中等分区及少量的大分区，这样，便可根据程序的大小，为之分配适当的分区。

### 2. 内存分配 (Memory Allocation)

*   **数据结构 (Data Structure):** 为了便于内存分配，通常将分区按其大小进行排队，并为之建立一张**分区使用表 (Partition Usage Table)** (如图 4-5(a) 所示)。
    *   ![[image-62.png]]
    *   **表项内容 (Table Entry Contents):** 每个分区的起始地址、大小及状态 (是否已分配)。
*   **分配过程 (Allocation Process):**
    *   当有一用户程序要装入时，由内存分配程序依据用户程序的大小检索该表。
    *   从中找出一个能满足要求的、尚未分配的分区。
    *   将之分配给该程序。
    *   然后将该表项中的状态置为“已分配”。
*   **分配失败 (Allocation Failure):** 若未找到大小足够的分区，则拒绝为该用户程序分配内存 (如图 4-5(b) 存储空间分配情况)。
    *   ![[image-63.png]]
*   **现状 (Current Status):** 固定分区分配由于每个分区的大小固定，必然会造成存储空间的浪费，因而现在已很少将它用于通用的 OS 中。但在某些用于控制多个相同对象的控制系统中，由于每个对象的控制程序大小相同，是事先已编好的，其所需的数据也是一定的，故仍采用固定分区式存储管理方式。

---

## 4.3.3 动态分区分配 (Dynamic Partition Allocation)

*   **别名 (Alias):** 可变分区分配 (Variable Partition Allocation)。
*   **核心思想 (Core Idea):** 根据进程的实际需要，动态地为之分配内存空间。
*   **涉及内容 (Aspects Involved):**
    *   分区分配中所用的数据结构。
    *   分区分配算法。
    *   分区的分配与回收操作。

### 1. 动态分区分配中的数据结构 (Data Structures in Dynamic Partition Allocation)

*   **目的 (Purpose):** 实现动态分区分配，系统中必须配置相应的数据结构，用以描述空闲分区和已分配分区的情况，为分配提供依据。
*   **常用数据结构 (Common Data Structures):**
    *   **(1) 空闲分区表 (Free Partition Table):** (如图 4-6 所示)
        *   ![[image-64.png]]
        *   在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。
        *   每个空闲分区占一个表目。
        *   表目中包括分区号、分区大小和分区始址等数据项。
    *   **(2) 空闲分区链 (Free Partition Chain):** (如图 4-7 所示)
        *   ![[image-65.png]]
        *   为了实现对空闲分区的分配和链接。
        *   在每个分区的起始部分设置一些用于控制分区分配的信息 (如图中前向指针、状态、大小)。
        *   以及用于链接各分区所用的前向指针。
        *   在分区尾部则设置一后向指针。
        *   通过前、后向链接指针，可将所有的空闲分区链接成一个**双向链**。
        *   为了检索方便，在分区尾部重复设置状态位和分区大小表目。
        *   当分区被分配出去以后，把状态位由“0”(空闲) 改为“1”(已分配)，此时，前、后向指针已无意义。

### 2. 动态分区分配算法 (Dynamic Partition Allocation Algorithms)

*   为把一个新作业装入内存，须按照一定的分配算法，从空闲分区表或空闲分区链中选出一分区分配给该作业。
*   内存分配算法对系统性能有很大的影响，因此有许多研究。
*   后续小节将介绍传统的四种顺序式搜索算法和三种较新的索引式搜索算法。

### 3. 分区分配操作 (Partition Allocation Operation)

*   主要操作是分配内存和回收内存。
    *   **1) 分配内存 (Allocating Memory):** (如图 4-8 内存分配流程)
        *   ![[image-66.png]]
        *   系统应利用某种分配算法，从空闲分区链(表)中找到所需大小的分区。
        *   设请求的分区大小为 `u.size`，表中每个空闲分区的大小可表示为 `m.size`。
        *   **情况一 (Small Remainder):** 若 `m.size - u.size <= size` (size 是事先规定的不再切割的剩余分区的大小)，说明多余部分太小，可不再切割，将整个分区分配给请求者。
        *   **情况二 (Large Remainder):** 否则 (即多余部分超过 size)，便从该分区中按请求的大小划分出一块内存空间分配出去，余下的部分仍留在空闲分区链(表)中。
        *   然后，将分配区的首址返回给调用者。

    *   **2) 回收内存 (Reclaiming Memory):** (如图 4-9 内存回收时的情况)
        *   ![[image-67.png]]
        *   当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链(表)中找到相应的插入点。
        *   此时可能出现以下四种情况之一：
            *   **(a) 回收区与插入点的前一个空闲分区 F₁ 相邻接:** 应将回收区与前一分区 F₁ 合并，不必为回收分区分配新表项，只需修改其前一分区 F₁ 的大小。
            *   **(b) 回收区与插入点的后一个空闲分区 F₂ 相邻接:** 也可将两分区合并，形成新的空闲分区，但用回收区的首址作为新空闲区的首址，大小为两者之和。
            *   **(c) 回收区同时与插入点的前、后两个分区邻接:** 此时将三个分区合并，使用 F₁ 的表项和 F₁ 的首址，取消 F₂ 的表项，大小为三者之和。
            *   **(d) 回收区既不与 F₁ 邻接，又不与 F₂ 邻接:** (如图 4-10 内存回收流程) 此时应为回收区单独建立一个新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。
                *   ![[image-68.png]]

---

## 4.3.4 基于顺序搜索的动态分区分配算法 (Sequential Search Based Dynamic Partition Allocation Algorithms)

*   通常是将系统中的空闲分区链接成一个链。
*   **顺序搜索 (Sequential Search):** 依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区。
*   **四种算法 (Four Algorithms):**
    1.  首次适应算法 (First Fit, FF)
    2.  循环首次适应算法 (Next Fit, NF)
    3.  最佳适应算法 (Best Fit, BF)
    4.  最坏适应算法 (Worst Fit, WF)

### 1. 首次适应 (First Fit, FF) 算法

*   **链表组织 (List Organization):** 要求空闲分区链以**地址递增**的次序链接。
*   **分配过程 (Allocation Process):**
    *   从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止。
    *   然后按照作业的大小，从该分区中划出一块内存空间，分配给请求者。
    *   余下的空闲分区仍留在空闲链中。
*   **失败情况 (Failure Case):** 若从链首直至链尾都不能找到一个能满足要求的分区，则表明系统中已没有足够大的内存分配给该进程，内存分配失败，返回。
*   **优点 (Advantage):** 倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区。这为以后到达的大作业分配大的内存空间创造了条件。
*   **缺点 (Disadvantage):** 低址部分不断被划分，会留下许多难以利用的、很小的空闲分区，称为**碎片 (Fragments)**。而每次查找又都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销。

### 2. 循环首次适应 (Next Fit, NF) 算法

*   **目的 (Purpose):** 避免 FF 算法的缺点 (低址部分留下小碎片和查找开销大)。
*   **分配过程 (Allocation Process):**
    *   不再是每次都从链首开始查找，而是从**上次找到的空闲分区的下一个空闲分区**开始查找。
    *   直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。
*   **实现 (Implementation):**
    *   设置一起始查寻指针，用于指示下一次起始查寻的空闲分区。
    *   采用循环查找方式 (如果最后一个空闲分区的大小仍不能满足要求，则应返回到第一个空闲分区，比较其大小是否满足要求)。
    *   找到后，应调整起始查寻指针。
*   **优点 (Advantages):**
    *   使内存中的空闲分区分布得更均匀。
    *   减少了查找空闲分区时的开销。
*   **缺点 (Disadvantage):** 会缺乏大的空闲分区。

### 3. 最佳适应 (Best Fit, BF) 算法

*   **核心思想 (“最佳”):** 每次为作业分配内存时，总是把能满足要求、又是**最小的空闲分区**分配给作业，避免“大材小用”。
*   **实现 (Implementation):**
    *   为了加速寻找，该算法要求将所有的空闲分区按其**容量以从小到大的顺序**形成一空闲分区链。
    *   这样，第一次找到的能满足要求的空闲区必然是最佳的。
*   **评价 (Evaluation):**
    *   孤立地看，最佳适应算法似乎是最佳的。
    *   但在宏观上却不一定：因为每次分配后所切割下来的剩余部分总是最小的，这样，在存储器中会留下许多难以利用的碎片。

### 4. 最坏适应 (Worst Fit, WF) 算法

*   **核心思想 (Opposite to BF):** 在扫描整个空闲分区表或链表时，总是挑选一个**最大的空闲区**，从中分割一部分存储空间给作业使用。
*   **目的 (Purpose):** 至于存储器中缺乏大的空闲分区。
*   **评价 (Evaluation):**
    *   这样的算法未必是最坏的。
    *   **优点 (Advantage):** 可使剩下的空闲区不至于太小，产生碎片的可能性最小，对中、小作业有利。
    *   **查找效率 (Search Efficiency):** 最坏适应分配算法查找效率很高。该算法要求，将所有的空闲分区，按其容量以从大到小的顺序形成一空闲分区链，查找时，只要看第一个分区能否满足作业要求即可。

---

## 4.3.5 基于索引搜索的动态分区分配算法 (Index Search Based Dynamic Partition Allocation Algorithms)

*   **顺序搜索的局限 (Limitation of Sequential Search):** 比较适用于不太大的系统。当系统很大时，系统中的内存分区可能会很多，相应的空闲分区链就可能很长，这时采用顺序搜索分区方法可能会很慢。
*   **索引搜索 (Index Search):** 为了提高搜索空闲分区的速度，在大、中型系统中往往会采用基于索引搜索的动态分区分配算法。
*   **常用算法 (Common Algorithms):**
    1.  快速适应算法 (Quick Fit)
    2.  伙伴系统 (Buddy System)
    3.  哈希算法 (Hash Algorithm)

### 1. 快速适应 (Quick Fit) 算法

*   **别名 (Alias):** 分类搜索法 (Categorized Search Method)。
*   **核心思想 (Core Idea):** 将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表。
*   **数据结构 (Data Structures):**
    *   系统中存在多个空闲分区链表。
    *   在内存中设立一张**管理索引表 (Management Index Table)**，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。
*   **分类依据 (Basis for Categorization):** 根据进程常用的空间大小进行划分 (如 2KB, 4KB, 8KB 等)。对于其它大小的分区 (如 7KB)，既可以放在 8KB 的链表中，也可以放在一个特殊的空闲区链表中。
*   **搜索过程 (Search Process - 两步):**
    *   **第一步:** 根据进程的长度，从索引表中去寻找到能容纳它的最小空闲区链表。
    *   **第二步:** 从链表中取下第一块进行分配即可。
*   **优点 (Advantages):**
    *   查找效率高。
    *   在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。
*   **缺点 (Disadvantages):**
    *   为了有效合并分区，在分区归还主存时的算法复杂，系统开销较大。
    *   该算法在分配空闲分区时，是以进程为单位的，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少地存在一定的浪费。这是典型的以空间换时间的做法。

### 2. 伙伴系统 (Buddy System)

*   **分区大小规定 (Partition Size Rule):** 无论已分配分区或空闲分区，其大小均为 **2 的 k 次幂** (k 为整数, 1 ≤ k ≤ m)。通常 2<sup>m</sup> 是整个可分配内存的大小 (即最大分区的大小)。
*   **系统初始化 (System Initialization):** 假设系统的可利用空间容量为 2<sup>m</sup> 个字，则系统开始运行时，整个内存区是一个大小为 2<sup>m</sup> 的空闲分区。
*   **分区分类 (Partition Categorization):** 在系统运行过程中，由于不断地划分，将会形成若干个不连续的空闲分区。将这些空闲分区按分区的大小进行分类。
*   **数据结构 (Data Structure):** 对于具有相同大小的所有空闲分区，单独设立一个**空闲分区双向链表**。这样，不同大小的空闲分区形成了 k 个空闲分区链表。
*   **分配过程 (Allocation Process):**
    *   当需要为进程分配一个长度为 n 的存储空间时，首先计算一个 i 值，使 2<sup>i-1</sup> < n ≤ 2<sup>i</sup>。
    *   然后在空闲分区大小为 2<sup>i</sup> 的空闲分区链表中查找。
    *   **若找到:** 即把该空闲分区分配给进程。
    *   **若未找到 (2<sup>i</sup> 分区已耗尽):** 则在分区大小为 2<sup>i+1</sup> 的空闲分区链表中寻找。
        *   若存在 2<sup>i+1</sup> 的一个空闲分区，则把该空闲分区**分裂**为相等的两个分区，这两个分区称为一对**伙伴 (buddies)**。其中一个分区用于分配，而把另一个加入分区大小为 2<sup>i</sup> 的空闲分区链表中。
        *   若大小为 2<sup>i+1</sup> 的空闲分区也不存在，则需要查找大小为 2<sup>i+2</sup> 的空闲分区，若找到则也对其进行两次分割：
            *   第一次，将其分割为大小为 2<sup>i+1</sup> 的两个分区，一个用于分配，一个加入到大小为 2<sup>i+1</sup> 的空闲分区链表中。
            *   第二次，将第一次用于分配的空闲区分割为 2<sup>i</sup> 的两个分区，一个用于分配，一个加入到大小为 2<sup>i</sup> 的空闲分区链表中。
        *   以此类推。在最坏的情况下，可能需要对 2<sup>m</sup> 的空闲分区进行 k 次分割才能得到所需分区。
*   **回收过程 (Reclamation Process):**
    *   与一次分配可能要进行多次分割一样，一次回收也可能要进行多次**合并**。
    *   如回收大小为 2<sup>i</sup> 的空闲分区时，若事先已存在 2<sup>i</sup> 的空闲分区，则应将其与伙伴分区合并为大小为 2<sup>i+1</sup> 的空闲分区。
    *   若事先已存在 2<sup>i+1</sup> 的空闲分区，又应继续与其伙伴分区合并为大小为 2<sup>i+2</sup> 的空闲分区，依此类推。
*   **伙伴地址计算 (Buddy Address Calculation):**
    *   对于一个大小为 2<sup>k</sup>，地址为 x 的内存块，其伙伴块的地址 $buddy_k(x)$ 通式为：
        *   $buddy_k(x) = x + 2^k$  (若 `x MOD 2^(k+1) == 0`)
        *   $buddy_k(x) = x - 2^k$  (若 `x MOD 2^(k+1) == 2^k`)
*   **性能评价 (Performance Evaluation):**
    *   **时间性能 (Time Performance):** 取决于查找空闲分区的位置和分割、合并空闲分区所花费的时间。在回收空闲分区时，需要对空闲分区进行合并，所以其时间性能比快速适应算法差，但由于它采用了索引搜索算法，比顺序搜索算法好。
    *   **空间性能 (Space Performance):** 由于对空闲分区进行合并，减少了小的空闲分区，提高了空闲分区的可使用率，故优于快速适应算法，比顺序搜索法略差。
*   **当前应用 (Current Application):** 在当前的操作系统中，普遍采用的是基于离散分配方式的分页和分段机制的虚拟内存机制，该机制较伙伴算法更为合理和高效。但在多处理机系统中，伙伴系统仍不失为一种有效的内存分配和释放的方法，目前仍被广泛使用。

### 3. 哈希算法 (Hash Algorithm)

*   **背景 (Background):** 上述分类搜索算法和伙伴系统算法中，都是将空闲分区根据分区大小进行分类，对于每一类具有相同大小的空闲分区，单独设立一个空闲分区链表。在为进程分配空间时，需要在一张管理索引表中查找到所需空间大小所对应的表项，从中得到对应的空闲分区链表表头指针，从而通过查找得到一个空闲分区。如果对空闲分区分类较细，则相应索引表的表项也就较多，因此会显著地增加搜索索引表的表项的时间开销。
*   **核心思想 (Core Idea):** 利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表。该表的每一个表项记录了一个对应的空闲分区链表表头指针。
*   **分配过程 (Allocation Process):** 当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。

---

## 4.3.6 动态可重定位分区分配 (Dynamic Relocatable Partition Allocation)

### 1. 紧凑 (Compaction / Compressing)

*   **问题 (Problem):** 连续分配方式的一个重要特点是，一个系统或用户程序必须被装入一片连续的内存空间中。当一台计算机运行了一段时间后，它的内存空间将会被分割成许多小的分区，而缺乏大的空闲空间。即使这些分散的许多小分区的容量总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存。
    *   例如：图 4-11(a) 示出了在内存中现有四个互不邻接的小分区，它们的容量分别为 10KB、30KB、14KB 和 26KB，其总容量是 80KB。但如果现在有一个作业到达，要求获得 40KB 的内存空间，由于必须为它分配一个连续空间，故此作业无法装入。这种不能被利用的小分区即是前已提及的“碎片”，或称为“零头”。
    *   ![[image-69.png]]
*   **解决方法 (Solution):** 将内存中的所有作业进行移动，使它们全都相邻接。这样，即可把原来分散的多个空闲小分区拼接成一个大分区，可将一个作业装入该区。这种通过移动内存中作业的位置，把原来多个分散的小分区拼接成一个大分区的方法，称为“拼接”或“紧凑” (见图 4-11(b))。
*   **引入新问题 (New Problems Introduced):** 虽然“紧凑”能获得大的空闲空间，但也带来了新的问题，即经过紧凑后的用户程序在内存中的位置发生了变化，此时若不对程序和数据的地址加以修改 (变换)，则程序必将无法执行。
*   **重定位需求 (Relocation Need):** 为此，在每次“紧凑”后，都必须对移动了的程序或数据进行**重定位**。
*   **效率问题 (Efficiency Issue):** 为了提高内存的利用率，系统在运行过程中是经常需要进行“紧凑”的，每“紧凑”一次，就要对移动了的程序或数据的地址进行修改，这不仅是一件相当麻烦的事情，而且还大大地影响到系统的效率。
*   **动态重定位的优势 (Advantage of Dynamic Relocation):** 下面要介绍的动态重定位方法将能很好地解决此问题。

### 2. 动态重定位 (Dynamic Relocation)

*   **回顾 (Recall):** 在 4.2.1 节中所介绍的动态运行时装入的方式中，作业装入内存后的所有地址仍然都是相对 (逻辑) 地址。而将相对地址转换为绝对 (物理) 地址的工作被推迟到程序指令要真正执行时进行。
*   **硬件支持 (Hardware Support):** 为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，即须在系统中增设一个**重定位寄存器 (Relocation Register)**，用它来存放程序 (数据) 在内存中的起始地址。
*   **地址变换过程 (Address Translation Process):** 程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的 (如图 4-12 动态重定位示意图)。
    *   ![[image-70.png]]
*   **“紧凑”时的优势 (Advantage during Compaction):** 地址变换过程是在程序执行期间，随着对每条指令或数据的访问自动进行的，故称为动态重定位。当系统对内存进行了“紧凑”，而使若干程序从内存的某处移至另一处时，不需对程序做任何修改，只要用该程序在内存的新起始地址去置换原来的起始地址即可。

### 3. 动态可重定位分区分配算法 (Dynamic Relocatable Partition Allocation Algorithm)

*   **与动态分区分配的异同 (Similarities and Differences with Dynamic Partition Allocation):** 基本上相同，差别仅在于：在这种分配算法中，增加了**紧凑 (Compaction)** 的功能。
*   **触发紧凑的条件 (Condition to Trigger Compaction):** 通常，当该算法不能找到一个足够大的空闲分区以满足用户需求时。
*   **紧凑后的分配 (Allocation after Compaction):** 如果所有的小的空闲分区的容量总和大于用户的要求，这时便须对内存进行“紧凑”，将经“紧凑”后所得到的的大空闲分区分配给用户。
*   **分配失败 (Allocation Failure):** 如果所有的小的空闲分区的容量总和仍小于用户的要求，则返回分配失败信息 (如图 4-13 动态分区分配算法流程图)。
    *   ![[image-71.png]]

---