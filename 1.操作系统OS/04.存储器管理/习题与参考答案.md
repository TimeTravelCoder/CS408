好的，我将尝试为你提供本章（第四章 存储器管理）常见习题的思路和答案。请注意，由于没有具体的习题列表，我会根据本章涵盖的核心知识点来设计一些典型问题并给出解答。这些答案旨在帮助理解，具体表述可能需要根据你教材的精确用词进行调整。

---

## 第四章 存储器管理 - 习题参考答案与解析

**1. 为什么要配置层次式存储器？**

*   **原因/目的**：当前技术条件下，单一类型的存储器难以同时满足计算机系统对存储器的三个核心要求：**速度快、容量大、价格便宜**。
*   **层次式存储器的原理**：利用程序访问的**局部性原理**（时间局部性和空间局部性），将不同速度、容量和价格的存储器按层次组织起来。CPU经常访问的数据和指令放在速度快、容量小、价格高的存储层次（如寄存器、高速缓存），不常用的放在速度慢、容量大、价格低的存储层次（如主存、辅存）。
*   **优点**：通过合理的调度和数据迁移，使得整个存储系统的平均访问速度接近高速存储器，而平均每比特成本接近低速存储器，同时获得了较大的存储容量。

**2. 可采用哪几种方式将程序装入内存？它们分别适用于何种场合？**

程序装入内存主要有以下三种方式：

*   **绝对装入方式 (Absolute Loading Mode)**：
    *   **过程**：在编译或汇编时，程序中的逻辑地址就与实际的物理内存地址完全一致。装入程序直接按照这些绝对地址将程序和数据装入内存。
    *   **适用场合**：早期的单道批处理系统，或者某些内存地址固定的嵌入式系统、监控程序等。当程序在内存中的存放位置是事先确定的，且不会改变时适用。
    *   **缺点**：灵活性差，程序在内存中的位置固定，不利于内存共享和多道程序设计。

*   **可重定位装入方式 (Relocation Loading Mode) / 静态重定位**：
    *   **过程**：程序编译链接后形成的是逻辑地址（通常从0开始）。在程序装入内存时，装入程序根据当前内存的可用情况，选择一个起始位置，然后将程序中的所有逻辑地址（指令地址、数据地址）加上这个起始地址（重定位因子），转换为物理地址。这个地址转换在装入时一次完成，之后不再改变。
    *   **适用场合**：早期的多道批处理系统，在程序装入内存后其位置不再改变的情况。
    *   **优点**：比绝对装入灵活，程序可以装入到内存的不同位置。
    *   **缺点**：程序一旦装入内存，其物理地址就固定了，不利于程序在内存中的移动（如内存紧凑）。

*   **动态运行时装入方式 (Dynamic Run-time Loading) / 动态重定位**：
    *   **过程**：程序编译链接后仍然是逻辑地址。地址转换推迟到程序真正要执行访问内存的指令时才进行。这需要硬件地址变换机构（如基址寄存器、重定位寄存器）的支持。程序在内存中的所有地址仍然是逻辑地址，在CPU执行指令时，通过硬件将逻辑地址实时转换为物理地址。
    *   **适用场合**：现代多道程序设计系统，特别是需要支持内存紧凑、程序换入换出（虚拟存储）的系统。
    *   **优点**：灵活性最高，程序可以在内存中移动而无需修改程序本身，便于实现内存共享和高效的内存利用。
    *   **缺点**：需要额外的硬件支持，地址转换过程在运行时进行，可能略微增加指令执行时间（但通常由硬件快速完成）。

**3. 何谓静态链接？静态链接时需要解决两个什么问题？**

*   **静态链接 (Static Linking)**：在程序运行之前，由链接程序 (Linker) 将编译后形成的所有目标模块 (Object Modules) 以及它们所需要的库函数链接在一起，形成一个单一的、完整的可执行装入模块 (Load Module) 的过程。这个链接过程在程序装入内存前完成，链接后的模块在运行时不再改变其内部结构。
*   **静态链接时需要解决的两个主要问题**：
    1.  **对相对地址进行修改 (Resolve Relative Addresses / Relocation)**：
        *   **问题**：每个目标模块在编译时都是独立进行的，其内部地址通常是从0开始的相对地址（相对于本模块的起始）。当多个模块链接在一起形成一个大的装入模块时，原来各模块的起始地址就不再是0了。
        *   **解决**：链接程序需要修改每个模块中的相对地址。例如，如果模块A长度为L_A，模块B链接在模块A之后，则模块B中所有原来相对于模块B起始的地址都需要加上L_A，使其成为相对于整个装入模块起始的地址。
    2.  **变换外部调用符号 (Resolve External Symbol References)**：
        *   **问题**：一个目标模块可能会调用定义在其他目标模块中的函数或访问其他模块中的全局变量（这些被称为外部符号）。在编译单个模块时，这些外部符号的地址是未知的。
        *   **解决**：链接程序需要找到这些外部符号在其他模块中的实际定义地址（在链接后形成的装入模块中的相对地址），并将调用处对这些符号的引用替换为其实际地址。这通常通过符号表来实现。

**4. 何谓装入时动态链接？装入时动态链接方式有何优点？**

*   **装入时动态链接 (Load-time Dynamic Linking)**：指将用户源程序编译后所得到的一组目标模块，在程序装入内存时，采用边装入边链接的链接方式。即在装入一个目标模块时，若发生一个外部模块调用事件，链接程序会去查找相应的外部目标模块，将其装入内存，并按照静态链接的方式修改目标模块中的相对地址和解析外部符号。
*   **装入时动态链接的优点**：
    1.  **便于修改和更新 (Easier Modification and Updates)**：如果一个被多个程序共享的库模块需要更新，只需更新该库模块本身，而不需要重新链接所有使用了该库的应用程序。下次应用程序装入时，会自动链接到新的库模块。
    2.  **便于实现目标模块的共享 (Facilitates Sharing of Object Modules)**：
        *   在静态链接中，每个应用程序都会包含其所需库模块的一份拷贝，造成内存和磁盘空间的浪费。
        *   在装入时动态链接中，如果多个正在运行的程序需要同一个库模块，该库模块在内存中可以只存在一份副本（如果库是可重入的），链接程序可以将多个应用程序链接到这同一份副本上，从而节省内存。
    3.  **可以减少程序装入时间和初始内存占用**：并非所有模块都在程序启动时立即需要，这种方式允许按需装入模块。

**5. 何谓运行时动态链接？运行时动态链接方式有何优点？**

*   **运行时动态链接 (Run-time Dynamic Linking)**：将对某些目标模块的链接推迟到程序执行过程中，当这些模块真正被调用到时才进行链接和装入。
*   **运行时动态链接的优点**：
    1.  **加快程序的装入过程 (Faster Program Loading)**：程序启动时不需要装入和链接所有模块，只装入主模块和立即需要的模块，从而减少了初始启动时间。
    2.  **节省大量内存空间 (Significant Memory Savings)**：只有在模块被实际调用时才将其装入内存并链接。对于那些在一次运行中可能根本不会被用到的模块（如错误处理模块、不常用的功能模块），它们就不会占用内存空间。这对于大型复杂应用程序尤其有效。
    3.  **更灵活的模块管理**：可以在程序运行时根据需要加载、卸载或替换模块。
    4.  **便于修改和更新**：与装入时动态链接类似，更新共享库模块更方便。

**6. 在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？**

在动态分区分配方式中，为了管理空闲分区，通常会将它们组织成一个或多个链表（空闲分区链）。链接方式可以有多种，常见的是使用**双向链表**，因为在合并和分裂分区时操作更方便。每个空闲分区（或其起始处的一个小管理块）通常包含以下信息：
*   **分区大小 (Size)**
*   **起始地址 (Start Address)** (有时隐含在链表结构中)
*   **前向指针 (Previous Pointer)**：指向链表中的前一个空闲分区。
*   **后向指针 (Next Pointer)**：指向链表中的后一个空闲分区。
*   **状态位 (Status)**：标记该块是空闲还是已分配（虽然在空闲链中都是空闲，但管理块可能用于已分配区和空闲区）。

**链接方式**：
*   **按地址有序链**：空闲分区按照其在内存中的起始地址从小到大排序链接。这有利于回收分区时检查和合并相邻空闲分区。
*   **按大小有序链**：可以按空闲分区大小升序或降序链接，便于某些分配算法（如最佳适应、最坏适应）的查找。
*   **其他特殊结构**：如索引表（如快速适应算法中的多链表结构）。

最基本的是将所有空闲分区通过指针串联起来，形成一个空闲分区链。当分配或回收时，对这个链进行操作。

**7. 为什么要引入动态重定位？如何实现？**

*   **为什么要引入动态重定位？**
    1.  **提高内存利用率**：允许程序在内存中的位置发生改变。当内存中出现许多外部碎片时，可以通过**内存紧凑 (Compaction)** 将所有已分配的区域移动到内存的一端，从而合并小的空闲区形成大的连续空闲区。如果没有动态重定位，程序移动后地址会失效。
    2.  **支持程序的换入换出**：在虚拟存储系统中，程序（或其一部分）可能被换出到外存，之后又被换回到内存的不同位置。动态重定位使得这种操作成为可能。
    3.  **编程灵活性**：程序员无需关心程序在内存中的绝对位置。

*   **如何实现动态重定位？**
    动态重定位的实现依赖于**硬件地址变换机构**。最常见的方式是使用**重定位寄存器 (Relocation Register)**，也称为**基址寄存器 (Base Register)**。
    1.  **程序中的地址**：程序在编译链接后，其内部使用的地址仍然是逻辑地址（通常从0开始）。
    2.  **装入内存**：程序装入内存时，操作系统会为其分配一个起始物理地址。这个起始地址被加载到重定位寄存器中。
    3.  **地址转换**：当CPU执行指令需要访问内存时，它生成的仍然是逻辑地址。这个逻辑地址在送往内存总线之前，会与重定位寄存器中的值相加，得到实际的物理地址。
        `物理地址 = 逻辑地址 + 重定位寄存器中的值 (基址)`
    4.  这个加法操作由硬件自动、快速完成。
    *   为了保护，通常还会配合一个**界限寄存器 (Limit Register)**，存放程序的长度。CPU生成的逻辑地址会先与界限寄存器的值比较，若逻辑地址大于或等于界限值，则发生地址越界中断。

**8. 什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？**

基于顺序搜索的动态分区分配算法是指在为一个新的作业（或进程）分配内存时，按一定顺序搜索空闲分区链（或表），直到找到第一个满足大小要求的空闲分区为止。

它可分为以下几种：

*   **首次适应算法 (First Fit, FF)**：
    *   **策略**：从空闲分区链的链首开始查找，选择第一个大小能满足请求的空闲分区进行分配。
    *   **优点**：算法简单，开销小。倾向于保留内存高址部分的大空闲区。
    *   **缺点**：可能会在内存低址部分留下许多难以利用的小碎片。

*   **循环首次适应算法 (Next Fit, NF)**：
    *   **策略**：从上次查找结束的位置开始继续查找（而不是每次都从链首开始），选择第一个大小能满足请求的空闲分区。查找到链尾时再回到链首。
    *   **优点**：空闲分区的分布更均匀，查找开销相对FF可能有所减少（避免了总从头开始）。
    *   **缺点**：可能缺乏大的空闲分区，因为所有部分都可能被分割。

*   **最佳适应算法 (Best Fit, BF)**：
    *   **策略**：从所有空闲分区中，选择那个大小能满足请求且是最小的空闲分区进行分配。
    *   **优点**：试图保留大的空闲区，避免“大材小用”。
    *   **缺点**：容易产生非常多、非常小的难以利用的外部碎片。需要搜索整个空闲链（或按大小排序的链）。

*   **最坏适应算法 (Worst Fit, WF)**：
    *   **策略**：从所有空闲分区中，选择那个大小能满足请求且是最大的空闲分区进行分配。
    *   **优点**：试图使分割后剩下的空闲区尽可能大，从而减少产生过多小碎片的可能性，对中小型作业有利。
    *   **缺点**：如果总有大作业进来，很快就会没有大空闲区。需要搜索整个空闲链（或按大小排序的链）。

**9. 在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理这些情况？**

在采用首次适应算法（通常配合按地址有序的空闲链）回收一块内存时，设回收区为R，其前一个相邻块为F1，后一个相邻块为F2，可能出现以下四种情况：

1.  **回收区R的前后都没有空闲分区 (R与F1、F2都不相邻接空闲区)**：
    *   **处理**：将回收区R作为一个新的独立空闲分区，插入到空闲分区链的适当位置（按地址有序）。
2.  **回收区R的前面是空闲分区F1，后面不是 (R与F1相邻接空闲，与F2不相邻接空闲或无F2)**：
    *   **处理**：将回收区R与前面的空闲分区F1合并。修改F1的长度为 `原F1长度 + R长度`。不需要在空闲链中新增表项。
3.  **回收区R的前面不是空闲分区，后面是空闲分区F2 (R与F2相邻接空闲，与F1不相邻接空闲或无F1)**：
    *   **处理**：将回收区R与后面的空闲分区F2合并。修改F2的起始地址为R的起始地址，F2的长度为 `R长度 + 原F2长度`。在空闲链中，R的位置被F2（新的大F2）取代。
4.  **回收区R的前后都是空闲分区F1和F2 (R与F1、F2都相邻接空闲)**：
    *   **处理**：将F1、R、F2三个区域合并成一个大的空闲分区。修改F1的长度为 `原F1长度 + R长度 + 原F2长度`。并将F2从空闲链中删除。

**10. 什么是基于索引搜索的动态分区分配算法？它可分为哪几种？**

基于索引搜索的动态分区分配算法是为了提高在大量空闲分区中查找合适分区的效率，它不再简单地顺序扫描整个空闲链，而是预先对空闲分区进行某种组织或分类，并建立索引。

主要有以下几种：

*   **快速适应算法 (Quick Fit)**：
    *   **策略**：将空闲分区按其大小进行分类，为每一类具有相同大小（或相近大小范围）的空闲分区分别设立一个空闲分区链。同时，在内存中设立一张管理索引表，每个表项对应一种大小的空闲区，并记录该类空闲链的链首指针。
    *   **分配**：当需要分配内存时，根据请求的大小，直接从索引表中找到对应大小（或稍大）的空闲链，取下第一块即可。
    *   **优点**：查找速度快，分配效率高。
    *   **缺点**：回收时合并空闲区可能较复杂（需要将合并后的分区重新归类到正确的链中）；可能产生较多无法合并的小碎片（因为分区只在特定大小的链中）。

*   **伙伴系统 (Buddy System)**：
    *   **策略**：内存大小通常为2的幂。所有空闲块的大小也都是2的幂。当需要分配一块大小为m的内存时，系统找到一个大小为2^k的最小空闲块，满足 `2^(k-1) < m <= 2^k`。如果找到的块正好是2^k，则分配；如果找到的是一个更大的块2^j (j>k)，则将其对半分裂成两个2^(j-1)的“伙伴”块，一个用于分配（或继续分裂），另一个加入相应大小的空闲链。
    *   **回收**：回收一块内存时，检查其“伙伴”块是否也空闲。如果是，则合并成一个两倍大小的块，并继续尝试与新块的伙伴合并，直到伙伴不空闲或已达到最大块。
    *   **优点**：分配和回收速度快（分裂和合并操作相对固定）；能较好地控制外部碎片（虽然仍会有）。
    *   **缺点**：由于块大小必须是2的幂，会产生内部碎片（如果请求大小不是2的幂）。

*   **哈希算法**：
    *   **策略**：与快速适应类似，也是根据空闲分区的大小分类，但使用哈希函数将不同大小的空闲区映射到哈希表的不同表项中，每个表项是一个空闲链的头指针。
    *   **优点**：如果哈希函数设计良好，查找效率高。
    *   **缺点**：哈希冲突处理；回收合并的复杂性。

**11. 令buddy_k(x)为大小为2^k、地址为x的块的伙伴系统地址，试写出buddy_k(x)的通用表达式。**

一个大小为 `2^k`、起始地址为 `x` 的块，其伙伴块的地址可以通过对 `x` 的第 `k` 位（从右往左数，第0位是最低位）进行异或操作得到。

更通用的表达式为：
`buddy_k(x) = x XOR 2^k`

或者，可以根据 `x` 相对于 `2^(k+1)` 的对齐情况来判断：
*   如果 `x MOD 2^(k+1) == 0` (即 `x` 是一个 `2^(k+1)` 对齐的地址，它是左伙伴)，则其伙伴地址为 `x + 2^k`。
*   如果 `x MOD 2^(k+1) == 2^k` (即 `x` 是一个 `2^k` 偏移的地址，它是右伙伴)，则其伙伴地址为 `x - 2^k`。

这两个条件可以统一用 `x XOR 2^k` 来表示。

**12. 分区存储管理中常用哪些分配策略？比较它们的优缺点。**

见问题8的答案中对首次适应、循环首次适应、最佳适应、最坏适应算法的描述及其优缺点。

**13. 为什么要引入对换？对换可分为哪几种类型？**

*   **为什么要引入对换 (Swapping)？**
    1.  **提高内存利用率和系统吞吐量**：当内存不足以容纳所有希望运行的进程时，可以将内存中暂时不能运行的进程（如阻塞态进程）或优先级较低的进程换出到外存（通常是磁盘的对换区），从而腾出内存空间给新的或更急需运行的进程。
    2.  **解决内存紧张问题**：当系统内存严重不足，无法满足新进程的分配请求时，通过换出一些进程来缓解。
    3.  **支持更大的多道程序度**：使得系统中可以并发运行的程序数量超过物理内存直接能容纳的数量。

*   **对换可分为哪几种类型？**
    1.  **整体对换 / 进程对换 (Entire Process Swapping)**：
        *   **单位**：以整个进程的地址空间为单位进行换入换出。
        *   **应用**：早期的分时系统或批处理系统中用于中级调度，或者在内存极度紧张时使用。
    2.  **页面对换 / 分段对换 (Page/Segment Swapping) / 部分对换**：
        *   **单位**：以进程的一个或多个页面（在分页系统中）或一个或多个段（在分段系统中）为单位进行换入换出。
        *   **应用**：这是现代虚拟存储系统的核心机制。不是整个进程被换出，而是只换出暂时不用的部分（页或段）。

**14. 对文件区管理的目标和对对换空间管理的目标有何不同？**

*   **文件区管理的目标**：
    1.  **提高文件存储空间的利用率**：尽量减少因文件存储而产生的磁盘碎片（内部和外部），最大化磁盘可用空间。
    2.  **提高对文件的访问速度**：对于经常访问的文件，其数据块尽量连续存放，减少磁头寻道时间。
    3.  **提供方便的用户接口和文件组织结构**：如目录结构、文件名等。
    4.  **保证文件数据的安全性和可靠性**：如访问控制、备份恢复等。
    *   **分配策略**：由于文件通常长期存储且大小不一，常采用**离散分配**方式（如链接分配、索引分配）来提高空间利用率，但可能牺牲部分访问速度。对访问速度要求高的文件系统会尝试连续分配或extent。

*   **对换空间管理的目标**：
    1.  **提高进程换入和换出的速度**：这是首要目标。对换操作的效率直接影响系统响应时间和吞吐量。
    2.  **尽可能减少对换操作本身引起的系统开销**。
    3.  **对换空间的利用率**：虽然也重要，但通常次于速度。
    *   **分配策略**：为了追求速度，对换空间通常采用**连续分配**策略，或者分配较大的连续块。因为进程（或其大部分）换入换出时，顺序读写比随机读写快得多。对换区通常是磁盘上的一块专用、连续或预先格式化好的区域。对碎片的容忍度较低，因为这会影响I/O效率。

**15. 为实现对换，系统应具备哪几方面的功能？**

1.  **对换空间的管理**：
    *   能够分配和回收外存（对换区）中的空间。
    *   记录哪些对换区空间是空闲的，哪些已被占用，以及被哪个进程（或其部分）占用。
    *   需要高效的分配算法以保证换出速度。
2.  **进程的换出**：
    *   **选择换出进程/页/段**：根据某种策略（如LRU、LFU、优先级、是否阻塞等）选择要换出的对象。
    *   **分配对换空间**：为选定的对象在对换区分配空间。
    *   **执行换出操作**：启动磁盘I/O，将选定对象从内存复制到外存的对换区。
    *   **更新状态**：更新进程（或页表/段表）的状态，标记其已不在内存中，并记录其在外存的位置。
    *   **回收内存**：回收被换出对象所占用的内存空间。
3.  **进程的换入**：
    *   **选择换入进程/页/段**：当内存有空闲或需要调入一个 ранее 换出的对象时。
    *   **分配内存空间**：为要换入的对象在内存中分配空间。
    *   **定位外存副本**：根据记录找到该对象在对换区的位置。
    *   **执行换入操作**：启动磁盘I/O，将对象从外存复制到分配的内存空间。
    *   **更新状态**：更新进程（或页表/段表）的状态，标记其已在内存中，并记录其在内存的位置。

**16. 在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？**

*   在传统的**整体对换/进程对换**中，通常是的，目标是将整个进程的地址空间（代码、数据、堆栈等）从内存移到外存，或者反之。
*   **原因**：
    *   **简化管理**：以整个进程为单位进行管理和调度（中级调度）相对简单。
    *   **完全腾出内存**：将整个进程换出可以确保释放其占用的所有内存，以便为其他进程腾出足够的连续空间（在分段或动态分区系统中尤其如此）。
    *   **早期系统限制**：早期的系统可能没有更细粒度的内存管理和地址映射机制（如分页）来支持部分对换。

*   **例外/现代做法**：
    *   在现代支持**虚拟存储**的系统中，通常不进行整个进程的对换，而是采用**页面对换**或**段页式系统中的页面对换**。这意味着只有进程中当前不活跃的页面会被换出，而不是整个进程。
    *   **共享段/页面的处理**：如果进程包含共享代码或数据段/页面，这些共享部分只有在没有任何进程引用它们时才可能被换出（或者有特殊处理，如写时复制的页面）。在整体对换时，共享部分的处理需要小心，避免重复换出或错误回收。

**17. 基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？**

基于离散分配时所用的基本单位不同，主要可将离散分配方式分为：

1.  **分页式存储管理 (Paging)**：
    *   **基本单位**：**页 (Page)**。进程的逻辑地址空间和物理内存都划分为固定大小的页和物理块。
2.  **分段式存储管理 (Segmentation)**：
    *   **基本单位**：**段 (Segment)**。进程的逻辑地址空间按逻辑模块划分为大小可变的段。每个段在物理内存中占用一块连续区域，但段与段之间可以不连续。
3.  **段页式存储管理 (Segmented Paging)**：
    *   **基本单位的组合**：先将进程逻辑地址空间划分为段，再将每个段划分为固定大小的页。物理内存分配以页为单位。

**18. 什么是页面？什么是物理块？页面的大小应如何确定？**

*   **页面 (Page)**：在分页存储管理中，进程的**逻辑地址空间**被划分成的若干个大小固定的部分。
*   **物理块 (Physical Block / Frame)**：在分页存储管理中，**物理内存**被划分成的与页面大小相等的若干个存储块。
*   **页面的大小应如何确定？**
    页面大小的选择是一个权衡问题，需要考虑以下因素：
    1.  **内部碎片**：页面越小，内部碎片的平均大小越小，内存利用率越高。页面越大，最后一个页面中未被使用的部分可能越多，内部碎片越大。
    2.  **页表大小**：页面越小，对于同样大小的进程，需要的页数越多，导致页表项越多，页表占用的内存空间越大。页面越大，页表越小。
    3.  **I/O效率**：页面是磁盘I/O的基本单位。磁盘I/O包括寻道、旋转延迟和数据传输时间。页面太小，每次I/O传输的数据量少，相对而言寻道和延迟的开销占比会很大，I/O效率低。页面较大，可以一次传输更多数据，平摊了固定开销，I/O效率较高。
    4.  **命中率（与虚拟存储相关）**：页面大小影响程序的局部性表现。如果页面太大，可能包含很多不相关的代码/数据，降低了局部性；如果太小，一个逻辑上紧密的单元可能跨越多个页，增加缺页次数。
    *   **实际选择**：现代操作系统中，页面大小通常是2的幂（便于地址转换），常见的有4KB, 8KB, 甚至2MB/1GB (大页面/巨页)。选择是一个综合平衡的结果，目前4KB仍是主流，但大页面的使用也越来越普遍。

**19. 什么是页表？页表的作用是什么？**

*   **页表 (Page Table)**：在分页存储管理系统中，操作系统为**每个进程**建立的一张数据结构，用于记录该进程的逻辑页面与物理内存块之间的映射关系。
*   **页表的作用**：
    1.  **实现地址转换 (Address Translation)**：其核心作用是将程序中的逻辑地址（具体是逻辑页号）转换为物理地址（具体是物理块号）。CPU生成的逻辑地址中的页号作为索引在页表中查找，找到对应的物理块号，再与页内偏移组合形成最终的物理地址。
    2.  **实现离散分配**：通过页表，进程的各个页面可以存放在物理内存中任意不相邻的空闲物理块中，从而实现了内存的离散分配。
    3.  **支持虚拟存储**：页表项中通常包含“存在位/有效位”，用于指示一个页面当前是否在物理内存中。如果不在，访问时会触发缺页中断，操作系统可以将该页从外存调入。
    4.  **实现内存保护**：页表项中可以包含保护位（如读/写/执行权限），用于控制对页面的访问权限。

**20. 为实现分页存储管理，需要哪些硬件支持？**

1.  **地址变换机构 (MMU - Memory Management Unit)**：
    *   能够将CPU生成的逻辑地址自动划分为页号和页内偏移。
    *   能够根据页号查找页表。
    *   能够将页表中查到的物理块号与页内偏移组合成物理地址。
2.  **页表寄存器 (Page Table Register - PTR)**：
    *   至少包含当前运行进程的页表的**基地址 (Page Table Base Address - PTBR)**。
    *   有时还包含页表的**长度 (Page Table Length Register - PTLR)**，用于检查页号是否越界。
3.  **(可选但强烈推荐) 转换旁路缓冲/快表 (Translation Lookaside Buffer - TLB)**：
    *   一个高速的、小容量的硬件缓存，用于存放最近使用过的页表项（页号到物理块号的映射）。
    *   用于加速地址转换过程，避免每次都访问内存中的页表。
4.  **中断机制**：
    *   用于处理地址越界、缺页中断、保护性中断等与分页管理相关的异常情况。

**21. 在分页系统中是如何实现地址变换的？**

基本步骤如下（假设无TLB）：

1.  CPU生成一个逻辑地址，将其分为**页号P**和**页内偏移W**。
2.  硬件从页表寄存器 (PTR) 中获取当前进程的页表基地址 (PTBR)。
3.  **越界检查 (可选，若有PTLR)**：如果PTR中包含页表长度PTLR，则检查 `P < PTLR`。若否，则产生地址越界中断。
4.  计算页表项在内存中的地址：`页表项地址 = PTBR + P * 大小(每个页表项)`。
5.  硬件访问内存，从计算出的地址读取相应的页表项。
6.  从页表项中提取**物理块号F**。
7.  **(可选) 存在位检查**：检查页表项中的存在位。如果页不在内存，产生缺页中断。
8.  **(可选) 保护检查**：根据操作类型和页表项中的保护位进行权限检查。若违例，产生保护中断。
9.  形成物理地址：`物理地址 = F * 页面大小 + W` (或直接将F和W拼接，如果F是块号，W是块内偏移)。
10. 使用该物理地址访问内存。

**22. 具有快表时是如何实现地址变换的？**

1.  CPU生成一个逻辑地址，将其分为**页号P**和**页内偏移W**。
2.  硬件首先用页号P**并行查找快表 (TLB)**。
3.  **TLB命中 (Hit)**：
    *   如果在TLB中找到了与P匹配的条目，则直接从TLB中取出对应的**物理块号F**和保护信息。
    *   进行保护检查。
    *   形成物理地址：`物理地址 = F * 页面大小 + W`。
    *   访问内存。 (地址转换速度快)
4.  **TLB未命中 (Miss)**：
    *   如果TLB中没有找到P，则需要访问内存中的页表（慢表），过程同问题21中的步骤2-8：
        *   获取页表基址。
        *   计算页表项地址，读取页表项，获取物理块号F和保护信息。
        *   进行存在位和保护检查。
    *   **更新TLB**：将从慢表中获取的 (P, F) 映射关系及相关信息存入TLB的一个条目中（可能需要替换掉一个旧条目）。
    *   形成物理地址：`物理地址 = F * 页面大小 + W`。
    *   访问内存。

**23. 较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。**

1.  **方便编程 (Convenience of Programming)**：
    *   允许程序员将程序按逻辑功能划分为多个段（如主程序段、子程序段、数据段、栈段）。
    *   每个段可以独立编写、编译，并从0开始编址，使得程序结构清晰，易于管理和维护。
    *   程序员可以使用段名（或段号）和段内偏移进行寻址，更符合逻辑思维。
2.  **信息共享 (Information Sharing)**：
    *   以具有完整逻辑意义的段为单位进行共享（如共享一个库函数段或一个公共数据段），更自然、更高效。
    *   多个进程的段表可以指向内存中同一个共享段的副本，节省内存。
    *   易于实现可重入代码的共享。
3.  **信息保护 (Information Protection)**：
    *   可以为每个逻辑段独立设置访问权限（如只读、可读写、可执行），保护的粒度与信息的逻辑属性一致。
    *   例如，代码段可设为只读执行，数据段可设为可读写。
4.  **动态增长 (Dynamic Growth)**：
    *   某些段（如栈段、堆段）在程序运行时其大小可能会发生变化。分段管理允许段在逻辑上动态增长或收缩。
5.  **动态链接 (Dynamic Linking)**：
    *   可以将程序中对某些模块（段）的链接推迟到运行时，当模块被实际调用时才进行链接和装入。段是动态链接的理想单位。

**24. 在具有快表的段页式存储管理方式中，如何实现地址变换？**

在具有快表的段页式系统中，TLB通常存储 (段号S, 段内页号P) 到 物理块号F 的直接映射。

1.  CPU生成逻辑地址，分为**段号S**、**段内页号P**和**页内偏移W**。
2.  硬件首先用 (S, P) 组合作为键，**并行查找快表 (TLB)**。
3.  **TLB命中 (Hit)**：
    *   如果在TLB中找到匹配的 (S, P) 条目，则直接从TLB中取出对应的**物理块号F**和保护信息。
    *   进行保护检查 (通常是段级和页级保护的综合结果)。
    *   形成物理地址：`物理地址 = F * 页面大小 + W`。
    *   访问内存。
4.  **TLB未命中 (Miss)**：
    *   如果TLB中未找到 (S, P) 的映射，则需要执行完整的段表和页表两级查找：
        a.  **访问段表** (同段页式地址转换的步骤2)：
            *   获取段表基址，用S查段表，得到该段的页表基址和页表长度。
            *   进行段号越界检查和段级保护检查。
        b.  **访问页表** (同段页式地址转换的步骤3)：
            *   用P查该段的页表，得到物理块号F。
            *   进行段内页号越界检查、页级保护检查和存在位检查。
    *   **更新TLB**：将从段表和页表查找得到的 (S, P) -> F 的映射关系及相关信息存入TLB的一个条目中。
    *   形成物理地址：`物理地址 = F * 页面大小 + W`。
    *   访问内存。

**25. 为什么说分段系统比分页系统更易于实现信息的共享和保护？**

*   **信息共享**：
    *   **分段系统**：共享以**逻辑段**为单位。一个段通常包含一个完整的逻辑实体（如一个函数库、一个数据结构）。共享时，只需让多个进程的段表项指向内存中同一个段的副本即可。这与程序员共享的意图（共享某个功能或数据）高度一致。
    *   **分页系统**：共享以**页**为单位。一个逻辑实体可能跨越多个页，且一个页中可能既包含共享部分也包含非共享部分。要共享一个逻辑实体，需要共享其所有相关的页，管理起来较复杂，且可能共享了不必要的内容。
*   **信息保护**：
    *   **分段系统**：保护以**逻辑段**为单位。可以为每个段根据其逻辑属性（如代码段、数据段）设置不同的访问权限（读、写、执行）。这与信息的逻辑用途和安全需求相符。
    *   **分页系统**：保护以**页**为单位。如果一个页中混合了不同保护属性的内容（如只读代码和可写数据），则难以对整个页实施单一且恰当的保护。要么过于宽松，要么过于严格。

**26. 分页和分段存储管理有何区别？**

见问题14中对文件区管理和对换空间管理目标的对比表格的思路，可以将对比项换成分页和分段的特性：

| 特性             | 分页 (Paging)                                  | 分段 (Segmentation)                                  |
| :--------------- | :--------------------------------------------- | :--------------------------------------------------- |
| **基本单位**     | 页 (Page)                                      | 段 (Segment)                                         |
| **单位性质**     | 信息的物理单位                                 | 信息的逻辑单位                                       |
| **单位大小**     | 固定大小                                       | 可变大小                                             |
| **地址空间**     | 一维线性                                       | 二维 (段号, 段内偏移)                                |
| **用户可见性**   | 透明                                           | 可见 (至少概念上)                                    |
| **产生原因**     | 解决外部碎片，提高内存利用率                     | 方便编程、共享、保护                                 |
| **碎片类型**     | 内部碎片                                       | 外部碎片                                             |
| **地址转换**     | 页表                                           | 段表                                                 |
| **共享与保护**   | 以页为单位，不直观，不灵活                     | 以段为单位，直观，灵活                               |

**27. 试全面比较连续分配和离散分配方式。**

| 特性                   | 连续分配方式 (Contiguous Allocation)                                                                    | 离散分配方式 (Non-contiguous Allocation - 主要指分页、分段、段页式)                                       |
| :--------------------- | :------------------------------------------------------------------------------------------------------ | :---------------------------------------------------------------------------------------------------- |
| **内存分配单位**       | 整个进程（单一连续区）或固定/可变大小的分区。进程在内存中占用一块连续的地址空间。                                | 页、段或段内页。进程的各个逻辑部分可以存放在内存中不相邻的区域。                                               |
| **地址要求**           | 要求为每个进程分配一块**连续的**物理内存空间。                                                              | 不要求进程在物理内存中连续存放，只需为其逻辑单元（页/段）分配物理空间即可。                                   |
| **内存利用率**         | **可能较低**。                                                                                          | **通常较高**。                                                                                            |
|   * 外部碎片           | 在动态分区分配中会产生外部碎片，导致内存利用率下降。固定分区则无外部碎片但有内部碎片。                               | 分页和段页式基本消除了外部碎片。纯分段仍有外部碎片。                                                           |
|   * 内部碎片           | 固定分区分配会产生内部碎片。动态分区理想情况下无内部碎片（按需分配），但实际分配算法可能导致少量。                        | 分页和段页式会产生内部碎片（在每个进程/段的最后一页）。纯分段无内部碎片。                                        |
| **管理复杂度**         | **相对较低**（尤其是单一连续和固定分区）。动态分区需要管理空闲链和分配算法。                                       | **相对较高**。需要维护页表、段表等数据结构，地址转换机制更复杂。                                                |
| **对进程大小的限制**   | 进程大小受限于内存中最大的连续空闲区（动态分区）或最大分区大小（固定分区）。                                       | 进程的逻辑大小可以远大于物理内存中任何单个连续空闲区的大小，甚至大于物理内存总大小（通过虚拟存储）。                     |
| **程序在内存中的移动** | **困难**。移动程序需要修改其所有绝对地址（除非有动态重定位）。                                                       | **容易**。只需修改页表/段表中的映射关系，程序本身代码无需修改。便于实现内存紧凑（针对段）和页面/段的换入换出。             |
| **共享实现**           | **困难或受限**。共享数据或代码需要特殊处理，且不易实现。                                                           | **更容易实现**。特别是分段和段页式，以逻辑段为单位共享非常自然。分页也可以实现页级共享。                               |
| **保护实现**           | 通常通过基址/界限寄存器实现对整个进程地址空间的保护。                                                              | 可以实现更细粒度的保护（页级或段级），并根据逻辑属性设置不同权限。                                                 |
| **典型代表**           | 单一连续分配、固定分区分配、动态分区分配。                                                                     | 分页式存储管理、分段式存储管理、段页式存储管理。                                                               |
