
# **第一章 操作系统引论**

## **1.0 操作系统 (Operating System, OS) 概述**

* **定义**: 配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。
* **主要作用**:
    1.  管理硬件设备，提高其利用率和系统吞吞吐量。
    2.  为用户和应用程序提供一个简单、易用的接口。
* **地位**: 现代计算机系统中最基本、最重要的系统软件。其他系统软件（如编译程序、数据库管理系统）和应用软件都依赖于OS的支持。
* **应用范围**: 现代计算机系统、多处理机系统、计算机网络中都必须配置。

## **1.1 操作系统的目标和作用**

* **目标与应用环境相关**:
    * 查询系统OS: 良好的人机交互性。
    * 工业控制、武器控制、多媒体OS: 实时性。
    * 微机OS: 使用的方便性。

### **1.1.1 操作系统的目标**

主要目标有四个：方便性、有效性、可扩充性和开放性。

1.  **方便性 (Convenience)**
    * 无OS的计算机（裸机）极难使用，需用机器语言编程。
    * 有OS的计算机：
        * 可用编译命令将高级语言程序翻译成机器代码。
        * 可通过OS提供的命令操纵计算机。
    * 极大方便用户，使计算机易学易用。
    * 图形用户界面 (GUI) 是提高方便性的重要手段。
2.  **有效性 (Effectiveness)**
    * **第一层含义**: 提高系统资源的利用率。
        * 早期无OS时，处理机、I/O设备常空闲，资源利用率低。
        * 提高资源利用率是OS发展的主要动力。
    * **第二层含义**: 提高系统的吞吐量。
        * OS通过合理组织工作流程，加速程序运行，缩短周期。
    * **历史权衡**: 早期计算机昂贵，有效性更重要。随着硬件成本下降，微机OS更重视方便性。
3.  **可扩充性 (Extensibility)**
    * OS必须能适应计算机硬件、体系结构及应用发展的要求。
    * 与OS结构紧密相关，推动OS结构发展：
        * 早期无结构 -> 模块化结构 -> 层次化结构 -> 微内核结构。
    * 微内核结构便于增添新功能/模块，修改现有功能/模块。
4.  **开放性 (Openness)**
    * 指系统能遵循世界标准规范，特别是开放系统互连OSI国际标准。
    * 遵循标准的软硬件能彼此兼容，方便互连。
    * 随着计算机普及和Internet发展，由单机环境转向网络环境，对OS开放性要求更高。
    * 是衡量新系统/软件能否广泛应用的关键因素。

### **1.1.2 操作系统的作用**

可以从用户、资源管理、资源抽象等角度分析。

1.  **OS作为用户与计算机硬件系统之间的接口**
    * OS位于用户与硬件之间，用户通过OS使用计算机。
    * 用户在OS帮助下方便、快捷、可靠地操纵硬件和运行程序。
    * **用户使用计算机的三种方式 (接口类型，如图1-1)**:
        * ![[image-369.png]]]]
        * **命令方式**: 用户通过键盘输入命令。
        * **系统调用方式**: 应用程序通过系统调用请求OS服务。
        * **图标—窗口方式 (GUI)**: 用户通过图形界面操作。
2.  **OS作为计算机系统资源的管理者**
    * 计算机系统资源分为四类：
        * 处理机 (Processor)
        * 存储器 (Memory)
        * I/O设备 (I/O Devices)
        * 文件 (Files, 包括数据和程序)
    * OS的主要功能即对这四类资源进行有效管理：
        * **处理机管理**: 分配和控制处理机。
        * **存储器管理**: 内存的分配与回收。
        * **I/O设备管理**: I/O设备的分配(回收)与操纵。
        * **文件管理**: 文件的存取、共享和保护。
    * 在多用户环境下，OS需对资源请求进行授权，协调用户对共享资源的使用。
3.  **OS实现了对计算机资源的抽象**
    * **裸机**: 提供物理接口，用户需了解硬件细节，难用。
    * **第一层抽象 (I/O设备管理软件)**: 在裸机上覆盖I/O设备管理软件（如图1-2）。
        * ![[image-370.png]]
        * 隐藏I/O设备操作细节。
        * 向上将I/O设备抽象为一组数据结构和I/O操作命令 (如read, write)。
        * 用户看到的机器功能更强、更方便（称为扩充机器或虚拟机）。
    * **第二层抽象 (文件管理软件)**: 在I/O管理软件上覆盖文件管理软件。
        * 隐藏文件操作细节。
        * 向上提供文件存取的数据结构和命令。
        * 用户看到的机器功能进一步增强。
    * **更高层抽象 (窗口软件)**: 面向用户的窗口系统。
    * **结论**: OS是铺设在硬件上的多层软件集合，不仅增强功能，还隐藏硬件操作细节，实现多层次抽象模型。抽象层次越高，接口功能越强，用户使用越方便。

### **1.1.3 推动操作系统发展的主要动力**

1.  **不断提高计算机资源利用率**:
    * 早期：多道批处理系统。
    * 60-70年代：SPOOLing系统（提高I/O和CPU利用率），虚拟存储器技术（改善存储器利用率）。
    * 网络环境：网络文件系统、数据库系统，实现全网共享。
2.  **方便用户**:
    * 解决资源利用率问题后，用户上机、调试不便成为主要矛盾。
    * 60年代：分时系统，实现人机交互。
    * 90年代初：图形用户界面 (GUI) 出现，极大方便用户。
3.  **器件的不断更新换代**:
    * IT技术（尤其微机芯片）发展，推动OS功能和性能提升。
    * 微机芯片从8位 -> 16位 -> 32位 -> 64位，相应微机OS也发展。
    * 外部设备迅速发展，OS支持的外部设备种类增多（光盘、移动硬盘、扫描仪等）。
4.  **计算机体系结构的不断发展**:
    * 单处理机系统 -> 多处理机系统 (对应产生多处理机OS)。
    * 计算机网络出现 (对应产生网络操作系统)。
5.  **不断提出新的应用需求**:
    * 工业控制需求 -> 实时OS。
    * 娱乐需求 (音乐、电影、游戏) -> OS增添多媒体功能。
    * 信息安全需求 -> OS增强安全性功能。
    * VLSI发展，智能设备普及 -> 嵌入式操作系统。

## **1.2 操作系统的发展过程**

* 50年代中期: 简单批处理OS。
* 60年代中期: 多道程序批处理系统、分时系统、实时OS。
* 70-90年代 (VLSI和体系结构大发展): 微型机、多处理机、计算机网络诞生，相应产生微机OS、多处理机OS、网络OS。

### **1.2.1 未配置操作系统的计算机系统 (第一代计算机：1945年 - 50年代中期)**

用户采用人工操作方式。

1.  **人工操作方式**
    * 程序员将穿孔纸带(或卡片)装入输入机，输入程序和数据，然后启动运行。
    * **缺点**:
        * 用户独占全机。
        * CPU等待人工操作 (装带、卸带等)，资源空闲。
    * 人机矛盾、CPU与I/O设备速度不匹配的矛盾突出。
2.  **脱机输入/输出 (Off-Line I/O) 方式 (50年代末)**
    * 目的：解决人机矛盾及CPU与I/O速度不匹配问题。
    * 过程：
        * 输入：在外围机控制下，将纸带/卡片数据输入到磁带。
        * 处理：CPU从磁带高速调入数据/程序。
        * 输出：CPU将结果高速输出到磁带，再由外围机将磁带数据输出到打印机等。
    * 程序和数据的输入/输出均在脱离主机（外围机）控制下完成。
    * **优点**:
        * 减少了CPU的空闲时间。
        * 提高了I/O速度（磁带比纸带快）。
    * **联机输入/输出 (On-Line I/O)**: 主机直接控制输入/输出。

### **1.2.2 单道批处理系统 (Simple Batch Processing System)**

* 背景：第二代晶体管计算机（50年代中期），计算机昂贵，需提高利用率。
* 目标：实现作业连续处理，减少机器空闲。
* **处理过程 (如图1-4)**:
    * ![[image-371.png]]
    1.  一批作业以脱机方式输入到磁带上。
    2.  系统中配置监督程序 (Monitor)。
    3.  Monitor控制作业逐个调入内存并执行。
    4.  一个作业完成后，控制权交还Monitor，再调入下一个作业。
* 内存中始终只有一道作业，故称单道。
* **缺点 (如图1-5)**:
    * ![[image-373.png]]
    * 资源未充分利用：当程序发出I/O请求时，CPU等待，I/O设备低速，CPU利用率低。
    * 内存浪费：大作业少，中小型作业多，内存常有空闲。
    * I/O设备未充分利用。

### **1.2.3 多道批处理系统 (Multiprogrammed Batch Processing System)**

* 背景：20世纪60年代中期，IBM 360 (第三代计算机)，OS/360是第一个多道批处理系统。
* 目的：进一步提高资源利用率和系统吞吐量。
* **基本概念**:
    1.  用户作业先存放在外存，形成“后备队列”。
    2.  作业调度程序按算法从后备队列选择若干作业调入内存。
    3.  这些作业共享CPU和系统资源。
    4.  当一个程序A因I/O暂停时，CPU可调度另一程序B运行，如此交替。
    5.  使CPU保持“忙碌”状态 (如图1-6)。
        * ![[image-374.png]]
* **优缺点**:
    * **优点**:
        1.  **资源利用率高**: CPU、内存、I/O设备利用率均提高。
        2.  **系统吞吐量大**: CPU和资源保持“忙碌”，作业切换开销小。
    * **缺点**:
        1.  **平均周转时间长**: 作业需排队处理。
        2.  **无交互能力**: 用户提交作业后不能干预。
* **需要解决的问题**:
    1.  处理机争用。
    2.  内存分配和保护。
    3.  I/O设备分配。
    4.  文件组织和管理。
    5.  作业管理。
    6.  用户与系统接口。
    * 解决这些问题的软件集合构成了操作系统。
* **操作系统定义 (基于此)**: 一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。

### **1.2.4 分时系统 (Time Sharing System)**

* 推动力：满足用户对人机交互的需求。
* **用户需求**:
    1.  **人机交互**: 程序员调试程序时希望能像早期一样独占并直接控制机器。
    2.  **共享主机**: 60年代计算机昂贵，需多人共享，且希望有独占感和交互性。
* **定义**: 一台主机连接多个终端（显示器+键盘），允许多个用户通过各自终端以交互方式使用计算机，共享主机资源。
* **关键问题实现**:
    1.  **及时接收**:
        * 配置多路卡，主机周期性扫描各终端（如每30ms）。
        * 为每个终端设缓冲区暂存输入。
    2.  **及时处理**:
        * 作业直接调入内存。
        * 采用**轮转运行方式 (Round Robin)**:
            * **时间片 (Time Slice)**: 很短的时间段 (如30ms)。
            * 每个作业每次运行一个时间片，然后暂停，调度下一个作业。
            * 保证短时间内所有作业都运行一次，用户请求得到及时响应。
* **特征**:
    1.  **多路性 (Multiplexity)**: 多终端同时连接主机，多用户共享。提高资源利用率，降低费用。
    2.  **独立性 (Independence)**: 用户在各自终端操作，互不干扰，感觉独占主机。
    3.  **及时性 (Timeliness)**: 用户请求在短时间内获得响应 (通常1-3秒)。
    4.  **交互性 (Interactivity)**: 用户可通过终端与系统进行广泛人机对话（文件编辑、数据处理、访问系统资源等）。

### **1.2.5 实时系统 (Real Time System)**

* **实时定义**: "及时"。实时计算指其正确性不仅取决于逻辑结果，还取决于产生结果的时间。
* **实时系统定义**: 能及时响应外部事件请求，在规定时间内完成处理，并控制所有实时任务协调运行。
* **类型**:
    1.  **工业(武器)控制系统**: 实时采集数据、处理、控制执行机构。如火炮控制、飞机自动驾驶。
    2.  **信息查询系统**: 远程终端请求，系统检索处理并及时应答。如订票系统。
    3.  **多媒体系统**: 播放音视频，保证视听感受。
    4.  **嵌入式系统**: 芯片嵌入设备，进行控制或信息处理。
* **实时任务类型**:
    1.  **周期性与非周期性实时任务**: 前者按指定周期循环执行，后者无明显周期但有截止时间 (Deadline)。
        * 截止时间可分：开始截止时间、完成截止时间。
    2.  **硬实时任务 (Hard Real-time Task, HRT)**: 必须满足截止时间，否则后果严重 (如工业控制)。
    3.  **软实时任务 (Soft Real-time Task, SRT)**: 偶尔错过截止时间影响不大 (如信息查询、多媒体)。
* **实时系统与分时系统特征比较**:
    * ![[image-7.png]]

### **1.2.6 微机操作系统的发展**

配置在微型机上的OS。可按字长分，也可按运行方式分。

1.  **单用户单任务操作系统**
    * 只允许一个用户上机，用户程序作为一个任务运行。
    * 代表：CP/M (8位Intel 8080)，MS-DOS (16位IBM-PC, Intel 80286)。
        * CP/M (Digital Research): 1974年出现，1977年重写，1979年2.2版支持硬盘。
        * MS-DOS (Microsoft): 1981年随IBM-PC推出。1983年2.0版支持硬盘、树形目录。1.0到3.3版均为单用户单任务，内存限640KB。
        * 80年代到90年代初，MS-DOS是16位机主流。
2.  **单用户多任务操作系统**
    * 只允许一个用户上机，但用户程序可分多个任务并发执行。
    * 32位微机OS多为此类。代表：Windows系列。
        * Windows 1.0 (1985), Windows 2.0 (1987): 16位平台，支持不佳。
        * Windows 3.0 (1990), Windows 3.1: 针对386/486 (32位)，引入GUI，支持多任务和扩展内存。成为主流。
        * Windows 95 (1995): 全32位，兼容16位应用，集成Internet功能。
        * Windows 98 (1998): Win95改进版，最后兼容16位应用的Windows。集成IE，增强多媒体支持。
        * Windows XP (2001): 家用和商业工作站版，广泛使用。
        * (Windows NT系列，如Vista, Win7, Win8, Win10, Server 2008/2012等，内核版本NT6.X，此处未详述)
3.  **多用户多任务操作系统**
    * 允许多用户通过终端使用同一机器，每个用户程序可分多个任务并发执行。
    * 大中小型机OS多为此类，32位微机上也有。代表：UNIX OS。
        * UNIX OS (Bell Labs, 1969-1970): UNIX V7 (1979)广泛应用。
        * 移植到微机：Xenix (Motorola MC680xx, Intel 8080)。
        * **Solaris OS (SUN)**: 1982年SUN OS 1.0 (Motorola 680X0)。1988年SUN OS 4.0 (SPARC平台，开始支持Intel 80X86)。1992年Solaris 2.0。1998年后推出64位Solaris 2.7, 2.8。网络、互操作、兼容、配置管理优秀。
        * **Linux OS (Linus Torvalds)**: 1991年针对Intel 80386开发，发布第一个版本。源码公开，通过Internet合作发展迅速。功能全面，大量UNIX软件移植，可在主流微机 (Intel 80X86 Pentium等)运行。

## **1.3 操作系统的基本特性**

多道批处理、分时、实时OS除各自特性外，还共同具有：并发、共享、虚拟、异步。

### **1.3.1 并发 (Concurrence)**

* **并行性 (Parallelism)**: 两个或多个事件在**同一时刻**发生 (需多处理机)。
* **并发性 (Concurrency)**: 两个或多个事件在**同一时间间隔**内发生。
    * 多道程序环境下，宏观上多个程序同时运行。
    * 单处理机系统中，微观上程序分时交替执行。
    * 例：1秒内，0-15ms程序A，15-30ms程序B，30-45ms程序C，45-60ms程序D。宏观并发，微观交替。
* 多处理机系统中，并发执行的程序可分配到不同处理机上，实现并行执行。
* **引入进程 (Process)**:
    * 无进程系统中，一个应用的计算和I/O部分只能顺序执行。
    * 为计算和I/O分别建进程后，可并发执行。
    * **进程**: 系统中能独立运行并作为资源分配的基本单位，由一组机器指令、数据、堆栈组成，是一个能独立运行的活动实体。多进程可并发执行和交换信息。
    * 进程和并发是现代OS最重要基本概念。

### **1.3.2 共享 (Sharing) / 资源复用**

* 指系统中资源可供内存中多个并发执行的进程共同使用。
* 与一般共享不同，OS环境下的共享限定了时间（进程在内存期间）和地点（内存中）。
* 管理复杂，因资源远少于需求，会产生争用。
* **两种共享方式**:
    1.  **互斥共享方式 (Mutual Exclusion)**:
        * 某些资源（如打印机、磁带机）一段时间内只允许一个进程访问。
        * 这类资源称为**临界资源 (Critical Resource)** 或独占资源。
        * 系统需建立机制保证进程对临界资源的互斥访问。
        * 多数物理设备、栈、变量、表格属临界资源。
    2.  **同时访问方式 (Simultaneous Access)**:
        * 某些资源允许一段时间内由多个进程“同时”访问（单处理机上实际是交替访问）。
        * 典型：磁盘设备，可重入代码编写的文件。
* **并发和共享的关系**:
    * 互为存在条件。无并发则无资源共享问题。
    * 无有效资源共享管理，会影响并发执行程度，甚至无法并发。

### **1.3.3 虚拟 (Virtual)**

* 通过某种技术将一个物理实体变为若干个逻辑上的对应物。
* 物理实体是实的（实际存在），逻辑对应物是虚的（用户感觉上）。
* 实现虚拟的技术称虚拟技术。OS中主要利用时分复用和空分复用。
1.  **时分复用技术**: 利用某设备为一个用户服务的空闲时间，转去为其他用户服务。
    * **虚拟处理机技术**: 多道程序设计，为每道程序建进程，并发执行。单处理机通过时分复用，使每个终端用户感觉有一个处理机专门服务。称为虚拟处理器。
    * **虚拟设备技术 (SPOOLing)**: 将一台物理I/O设备虚拟为多台逻辑I/O设备，允许多用户“同时”使用。如打印机（临界资源）通过SPOOLing变为多台逻辑打印机。
2.  **空分复用技术**: 利用存储器的空闲空间分区域存放和运行其他多道程序。
    * **虚拟磁盘技术**: (未在此处详细展开，但原理类似)
    * **虚拟存储器技术**:
        * 单纯空分复用只能提高内存利用率，不能逻辑上扩充容量。
        * 虚拟存储器技术实现内存分时复用，使一道程序仅部分在内存即可运行。
        * 如100MB程序在30MB内存运行，实质是程序各部分分时进入内存。
* **代价**: 虚拟实现的N个逻辑设备，其平均速度或空间约是物理设备的1/N。

### **1.3.4 异步 (Asynchronism)**

* 多道程序环境下，进程执行以“停停走走”方式运行，而非一气呵成。
* 进程何时获CPU、何时因资源请求暂停、以何速度推进等，均不可预知。
* 原因：资源等因素限制。
* 尽管异步，只要OS配置完善的进程同步机制且运行环境相同，作业多次运行结果应相同。
* 异步运行是允许的，是OS重要特征。

## **1.4 操作系统的主要功能**

* 引入OS目的：为多道程序提供良好运行环境，保证高效、有序运行，最大化资源利用，方便用户。
* 传统OS基本功能：处理机管理、存储器管理、设备管理、文件管理、用户接口。

### **1.4.1 处理机管理功能**

* 在多道程序系统中，处理机分配和运行以进程为基本单位。
* 主要功能：
    1.  **进程控制**: 为作业创建进程、撤销已结束进程，控制进程状态转换。设置线程的OS还包括线程创建和管理。
    2.  **进程同步**: 对并发进程进行协调。
        * **进程互斥**: 诸进程访问临界资源时互斥。
        * **进程同步**: 协作完成共同任务的进程间协调执行次序。
    3.  **进程通信**: 实现相互合作进程间信息交换 (如消息传递)。
    4.  **调度**:
        * **作业调度**: 从后备队列选作业调入内存，分配资源，建进程，插入就绪队列。
        * **进程调度 (低级调度)**: 从就绪队列选进程分配CPU执行。

### **1.4.2 存储器管理功能**

* 任务：为多道程序运行提供良好环境，提高利用率，方便用户，逻辑上扩充内存。
* 主要功能：
    1.  **内存分配与回收**:
        * 为每道程序分配内存空间（使其“各得其所”）。
        * 提高利用率，减少不可用空间（碎片）。
        * 允许程序申请附加内存（适应动态增长）。
        * 分配方式：静态分配（作业装入时确定，运行期间不变），动态分配（运行中可申请，可在内存中“移动”）。
    2.  **内存保护**:
        * 确保用户程序在各自内存区运行，互不干扰。
        * 禁止用户程序访问OS程序和数据，禁止转移到非共享区。
        * 通过设置界限寄存器等实现。
    3.  **地址映射**: 将程序地址空间中逻辑地址转换为内存空间中物理地址。需硬件支持。
    4.  **内存扩充**: 借助虚拟存储技术，逻辑上扩充内存。
        * **请求调入功能**: 允许程序部分装入即运行。运行中若需未装入部分，OS从磁盘调入。
        * **置换功能**: 内存不足时，OS将内存中暂不用部分调出到硬盘，腾出空间。

### **1.4.3 设备管理功能**

* 任务：完成用户I/O请求，分配I/O设备，完成指定操作，提高CPU和I/O设备利用率及I/O速度，方便用户。
* 主要功能：
    1.  **缓冲管理**: 缓和CPU与I/O设备速度不匹配。OS在内存设缓冲区。
        * 机制：单缓冲、双缓冲、公用缓冲池。
    2.  **设备分配**: 根据用户I/O请求、资源情况、分配策略分配设备。可能还需分配控制器、通道。
        * 数据结构：设备控制表、控制器控制表等，记录设备状态。
    3.  **设备处理 (设备驱动程序)**: 实现CPU与设备控制器通信。CPU发I/O命令，控制器响应中断。
        * 通道系统：驱动程序还需根据用户I/O请求自动构成通道程序。

### **1.4.4 文件管理功能**

* 任务：对用户和系统文件进行管理，方便使用，保证安全。
* 主要功能：
    1.  **文件存储空间的管理**: 为文件分配外存空间，提高外存利用率和存取速度。记录使用情况，进行分配回收。
    2.  **目录管理**: 为每个文件建目录项（文件名、属性、物理位置等），有效组织目录项，实现方便按名存取。支持文件共享（外存只需一份副本）。提供快速目录查询。
    3.  **文件的读/写管理和保护**:
        * **读/写管理**: 根据请求从外存读数据或将数据写入外存。通过文件名检索目录，获取位置，用读/写指针操作。
        * **文件保护**: 防止文件被非法窃取和破坏。
            * 存取控制：防止未经核准用户存取。
            * 防止冒名顶替存取。
            * 防止不正确方式使用。

### **1.4.5 操作系统与用户之间的接口**

为方便用户使用OS，提供用户接口和程序接口。

1.  **用户接口**: 用户直接或间接控制作业。
    * **联机用户接口**: 用户通过键盘输入命令，系统立即解释执行。如命令行。
    * **脱机用户接口**: 批处理作业用户。用作业控制语言(JCL)将命令写在作业说明书，与作业一起提交。
    * **图形用户接口 (GUI)**: 图形化界面，用图标表示功能/文件，用菜单/对话框+鼠标操作。
2.  **程序接口 (系统调用)**: 用户程序在执行中访问系统资源的唯一途径。
    * 由一组系统调用组成，每个系统调用是一个能完成特定功能的子程序。
    * 早期用汇编提供。高级语言通过库函数间接使用。
    * 现代OS (UNIX, OS/2) 系统调用本身用C语言编写，以函数形式提供。

### **1.4.6 现代操作系统的新功能**

在传统OS基础上，增加面向安全、网络、多媒体等功能。

1.  **系统安全**:
    * 确保计算机中存储和传输数据的保密性、完整性、可用性。
    * 技术手段：
        * **认证技术**: 确认被认证对象名副其实（如身份认证）。
        * **密码技术**: 数据加密，防窃取。
        * **访问控制技术**: 用户权限设置，文件属性设置（如只读）。
        * **反病毒技术**: 预防、检测、清除病毒。
2.  **网络的功能和服务**:
    * 支持用户联网获取网络服务（邮件、Web等）。
    * 功能：
        * **网络通信**: 源主机与目标主机间无差错数据传输（建拆链路、传输控制、差错控制、流量控制）。
        * **资源管理**: 对网络共享资源（软硬件）有效管理，协调使用，保证安全一致。
        * **应用互操作**: 不同网络互连构成的互连网中，实现信息互通（不同网络用户间通信）和互用（访问不同网络文件/数据库）。
3.  **支持多媒体**:
    * 处理音视频等多媒体信息。
    * 增加功能：
        * **接纳控制**: 保证运行多个实时进程截止时间，限制SRT任务数目、驻留内存任务数。
        * **实时调度**: SRT调度不仅考虑策略，还考虑接纳度。
        * **多媒体文件存储**: 要求能将硬盘数据快速传送至输出设备（改进离散存放和磁盘寻道）。

## **1.5 OS 结构设计**

* 早期OS规模小，手工编制。随着规模增大，需工程化开发方法（软件工程学）。
* 软件工程目标：开发高质量、合理费用的软件产品。
* 质量指标：功能性、有效性、可靠性、易用性、可维护性、易移植性。
* 开发方法：模块化、结构化、面向对象等。

### **1.5.1 传统操作系统结构**

包括早期无结构、模块化结构、分层式结构OS。

1.  **无结构操作系统 (整体系统结构)**
    * 早期设计者注重功能实现和效率，缺乏统一设计思想。
    * OS是众多过程集合，过程间可任意调用，内部复杂混乱。
    * 程序设计技巧在于如何紧凑编程以利用内存。
    * 系统扩大后，庞大杂乱，错误多，调试难，难阅读理解，维护负担重。
2.  **模块化结构OS (模块-接口法)**
    * 20世纪60年代出现，结构化程序设计技术。
    * 基于“分解”和“模块化”原则控制软件复杂度。
    * OS按功能划分为若干独立模块（进程管理、存储器管理、I/O设备管理等）。
    * 模块间规定接口，通过接口交互。模块可再细分子模块 (如图1-7)。
        * ![[image-375.png]]
    * **模块独立性**: 关键是模块划分和接口规定。
        * 划分太小：模块间联系过多，系统混乱。
        * 划分太大：模块内部复杂性增加。
        * 衡量标准：
            * **内聚性**: 模块内部各部分联系紧密程度。越高越好。
            * **耦合度**: 模块间相互联系和影响程度。越低越好。
    * **优缺点**:
        * **优点**: 提高OS设计正确性、可理解性、可维护性；增强OS可适应性；加速OS开发。
        * **缺点**: 模块间接口规定难满足后续实际需求；设计阶段决策“无序性”，各模块设计齐头并进，难保证每步决定可靠。被称为“无序模块法”。
3.  **分层式结构OS**
    * 目的：将模块-接口法中“决定顺序”的无序性变有序。
    * 设计任务：在目标系统An和裸机A0间，铺设若干层次软件A1, A2, ..., An-1。
    * 采用自底向上法铺设中间层。
    * 基本原则：每步设计建立在可靠基础上。每层仅使用其底层功能服务。
    * 例：调试A1时，基于确定A0。A1测试通过后，视为正确。调试A2时，基于A0, A1。
    * OS分若干层次，每层由若干模块组成，层间单向依赖（高层依赖紧邻低层）。
    * **优缺点**:
        * **优点**: 易保证系统正确性；易扩充和维护。
        * **缺点**: 系统效率降低（每执行功能需穿越多层，增加通信开销）。

### **1.5.2 客户/服务器模式 (Client/Server Model, C/S模式)**

* 20世纪90年代风靡，LAN、企业网、Internet服务广泛采用。
* **组成**:
    1.  **客户机 (Client)**: LAN中网络工作站，自主计算机，有处理能力。运行客户进程，处理本地业务，可发消息给服务器请求服务。
    2.  **服务器 (Server)**: 规模较大机器，驻留网络文件系统/数据库系统等，为所有用户提供服务。常处工作状态，被动等待请求。
    3.  **网络系统**: 连接客户机和服务器，实现通信和资源共享。
* **交互过程**:
    1.  客户发送请求消息。
    2.  服务器接收消息，处理。
    3.  服务器回送响应消息。
    4.  客户机接收响应消息，处理。
* **优点**:
    1.  数据分布处理和存储：客户机有处理/存储能力，摆脱数据全在主机造成的不可靠和瓶颈。
    2.  便于集中管理：全局重要信息、机密资料、重要设备、网络管理仍可集中。保障“可靠”和“安全”。
    3.  灵活性和可扩充性：客户机/服务器数量理论上不受限，可配置多类型。
    4.  易于改编应用软件：客户机程序修改比集中模式容易，允许客户修改。
* **不足**:
    * 不可靠性：单服务器故障导致网络瘫痪。
    * 瓶颈问题：服务器重负荷时响应慢。
    * (可通过配置多服务器和安全措施改善)

### **1.5.3 面向对象的程序设计 (Object-Oriented Programming, OOP) 技术**

* 20世纪80年代初提出并流行。基于“抽象”和“隐蔽”原则控制复杂度。
* **基本概念**:
    1.  **对象 (Object)**: 现实世界中具相同属性、服从相同规则的事物(物理实体、概念、软件模块等)的抽象。其具体事物称对象实例。
        * OS中实体如进程、线程、消息、文件等都可用对象概念。
        * 对象由被封装的数据结构(变量/属性)和一组对其操作的过程(方法/函数)表示 (如图1-8)。![[image-376.png]]
        * 对象变量对外隐蔽，只能通过对象方法访问 (如图1-9，文件对象的属性和方法)。
            * ![[image-377.png]]
        * 方法实现细节也隐蔽，保护对象变量不被未授权者不正确操作。
    2.  **对象类 (Object Class)**: 对一组相似对象的共同属性和行为的描述。类是对象抽象，对象是类实例。类中变量在实例中有具体值。
    3.  **继承 (Inheritance)**: 根据已有类(父类A)定义新类(子类B)。子类自动继承父类变量和方法，并可增新内容。可形成继承层次。允许多重继承 (如图1-10)。
        * ![[image-378.png]]
* **优点**:
    1.  通过“重用”提高产品质量和生产率：重用已测试对象/类，降成本，获更好质量。
    2.  使系统具更好易修改性和易扩展性：封装使修改不影响他处。继承减少开发时空开销。
    3.  更易于保证系统“正确性”和“可靠性”：对象是基本单元，可独立测试。封装防未授权访问和不正确使用。

### **1.5.4 微内核OS结构 (MicroKernel OS)**

* 20世纪80年代后期发展，如Carnegie Mellon大学Mach OS。当前流行多处理机OS多采用，如Windows 2000/XP。
* **基本概念**:
    1.  **足够小的内核**: 内核仅含OS最基本核心功能（与硬件紧密相关部分、一些较基本功能、客户与服务器通信）。为构建通用OS提供基础。
    2.  **基于客户/服务器模式**: 绝大部分OS功能放在微内核外一组服务器(进程)中实现（如进程(线程)服务器、虚存服务器、I/O设备服务器）。运行在用户态，通过微内核消息传递交互 (如图1-11)。![[image-379.png]]
    3.  **应用“机制与策略分离”原理**: 机制是实现某功能的具体执行机构。策略是在机制基础上借助参数/算法实现优化或不同目标。机制在基层，策略在高层。传统OS机制在内核较低层，策略在较高层。微内核OS机制在微内核，策略在服务器。
    4.  **采用面向对象技术**: 提高设计速度和系统特性。
* **微内核的基本功能**:
    1.  **进程(线程)管理**: 机制部分（如优先级队列、取出指定优先级进程并执行）。策略部分（如何分类、优先级确认）在内核外服务器。进程/线程间通信、切换、调度、多处理机同步等也放入微内核。
    2.  **低级存储器管理**: 依赖硬件的页表机制、地址变换机制放入微内核。虚拟存储管理策略（页面置换算法、内存分配回收策略）在内核外存储器服务器。
    3.  **中断和陷入处理**: 微内核捕获中断/陷入，前期处理（现场保护、识别类型），转换成消息发给相关服务器，由服务器后期处理。
* **优点**:
    1.  **提高系统可扩展性**: 功能由独立服务器实现，增/改/删功能只需增/改/删服务器。
    2.  **增强系统可靠性**: 微内核精心设计测试，保证正确。服务器在用户态，用消息通信，一服务器出错不影响内核和其他服务器。
    3.  **可移植性强**: 与特定CPU和I/O硬件相关代码均在内核及内核下硬件隐藏层。其他大部分（服务器）与硬件无关。移植工作量小。
    4.  **提供了对分布式系统的支持**: 客户/服务器间消息传递，只要赋予唯一标识符，配置系统映射表（标识符与机器对应），即可透明通信，无论目标在哪台机器。
    5.  **融入了面向对象技术**: “封装”、“继承”、“对象类”、“多态性”、消息传递，利于提高正确、可靠、易修改、易扩展性，减少开发开销。
* **存在的问题**:
    * **运行效率有所降低**: 一次客户对OS服务请求，需多次消息交互和用户/内核模式及上下文切换。
        * 早期OS：2次切换（用户态->系统调用->内核态，内核态->返回用户态）。
        * 微内核OS：至少4次切换（客户发请求给内核，内核发给服务器，服务器完成请求响应给内核，内核响应给客户）。若服务器需其他服务器帮助，切换更多 (如图1-12)。![[image-380.png]]
    * **改善方法**: 将常用操作系统基本功能由服务器移入微内核。代价是微内核容量增大，小型接口定义和适应性优点下降，设计代价提高。

---

## **本章习题要点提示 (部分)**

* **OS目标**: 方便性、有效性、可扩充性、开放性。
* **OS作用**: 用户接口、资源管理器、资源抽象。
* **推动多道批处理发展动力**: 提高资源利用率。
* **脱机I/O**: 输入输出通过外围机和磁带进行，不直接占用主机CPU。
* **推动分时系统发展动力**: 方便用户（人机交互）。
* **分时系统关键问题**: 及时接收（多路卡+缓冲），及时处理（作业驻留内存+时间片轮转）。
* **实时系统引入原因**: 满足特定应用对时间响应的严格要求。
* **硬实时/软实时**: HRT必须满足deadline，SRT偶尔可错过。
* **OS基本特征**: 并发、共享、虚拟、异步。并发是核心。
* **独占资源共享方式**: 互斥访问（如加锁）。
* **时分复用根本原因**: 利用设备空闲时间为其他用户服务，提高宏观利用率。
* **异步性原因**: 资源竞争、等待，导致进程走走停停。
* **处理机管理功能**: 进程控制、同步、通信、调度。
* **内存管理功能**: 分配回收、保护、地址映射、扩充。
* **设备管理功能**: 缓冲、分配、处理（驱动）。
* **文件管理功能**: 存储空间管理、目录管理、读写与保护。
* **推动传统OS->现代OS因素**: 安全需求、网络发展、多媒体应用、硬件发展。
* **微内核OS**: 内核极小，大部分功能由用户态服务器实现，通过消息通信。
* **微内核优点**: 可扩展性、可靠性、可移植性、支持分布式、面向对象。
* **微内核采用C/S模式原因**: 将功能模块化、服务化，降低内核复杂度，提高灵活性和可靠性。
* **微内核中新技术**: 面向对象、客户/服务器、机制与策略分离。
* **微内核提供功能**: 进程/线程管理（底层）、低级存储管理、中断/陷入处理、通信机制。
```