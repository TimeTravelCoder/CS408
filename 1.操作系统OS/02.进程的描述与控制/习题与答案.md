
## 第二章 进程的描述与控制 - 习题与解答思路

**一、 概念理解与简答题**

1.  **什么是前趋图？为什么要引入前趋图？**
    *   **解答思路：**
        *   **定义：** 前趋图是一个有向无循环图 (DAG)，用于描述一组任务（进程、程序段、语句）之间必须遵循的先后执行顺序。
        *   **组成：** 结点代表任务，有向边代表前趋关系。
        *   **引入原因：** 为了清晰、直观地描述程序或进程在顺序执行和并发执行时的制约关系，为分析程序的并发性和设计同步机制提供基础。
2.  **试画出下面四条语句的前趋图：**
    ```
    S1: a = x + y;
    S2: b = z + 1;
    S3: c = a - b;
    S4: w = c + 1;
    ```
    *   **解答思路：**
        *   分析数据依赖关系：
            *   S3 依赖 S1 (需要 `a`) 和 S2 (需要 `b`)。
            *   S4 依赖 S3 (需要 `c`)。
            *   S1 和 S2 之间没有依赖关系。
        *   **前趋图：**
            *   初始结点：S1, S2 (可以并发)
            *   S1 → S3
            *   S2 → S3
            *   S3 → S4
            *   终止结点：S4
![[image-16.png|390x363]]
3.  **为什么程序并发执行会产生间断性特征？**
    *   **解答思路：**
        *   **资源共享：** 多个并发程序需要共享有限的系统资源（CPU、I/O设备、内存等）。
        *   **相互合作：** 程序之间可能需要相互协作，等待对方提供数据或完成某个操作。
        *   **事件驱动：** 程序的执行可能会因为等待某个事件（如I/O完成、资源释放、信号到达）而暂停。
        *   **调度：** 操作系统调度程序会根据一定的策略剥夺正在运行的程序的CPU，分配给其他程序。
        *   这些因素导致程序在执行过程中呈现“执行-暂停-执行”的间断性。

4.  **程序并发执行时为什么会失去封闭性和可再现性？**
    *   **解答思路：**
        *   **失去封闭性：**
            *   并发执行时，多个程序共享系统资源，一个程序的运行环境会受到其他程序的影响（例如，其他程序修改了共享变量，占用了所需资源）。程序不再独占全机资源。
        *   **失去可再现性：**
            *   由于并发程序执行的相对速度不可预知（异步性），以及它们对共享资源的访问顺序可能因调度策略、中断等因素而改变，导致即使初始条件相同，每次运行的结果也可能不同。
5.  **在操作系统中为什么要引入进程的概念？它会产生什么样的影响？**
    *   **解答思路：**
        *   **引入原因：**
            *   传统的程序概念无法描述和控制并发执行带来的复杂性（如间断性、失去封闭性、不可再现性）。
            *   需要一个新的实体作为资源分配和独立调度的基本单位，以便更好地管理和控制并发。
        *   **产生的影响：**
            *   **积极影响：** 实现了程序的并发执行，提高了资源利用率和系统吞吐量；使得对并发程序的管理和控制成为可能；为实现复杂的操作系统功能（如多任务、分时）提供了基础。
            *   **带来的复杂性：** 引入了进程同步、进程通信、死锁等新的问题需要解决。
6.  **试从动态性、并发性和独立性上比较进程和程序。**
    *   **解答思路：**
        *   **动态性：**
            *   **进程：** 是程序的一次执行过程，有创建、执行、消亡的生命周期，是动态的。
            *   **程序：** 是静态的指令和数据集合，本身不活动。
        *   **并发性：**
            *   **进程：** 可以与其他进程并发执行，是并发执行的基本单位。
            *   **程序：** 本身不能并发执行，只有被加载并创建为进程后才能参与并发。
        *   **独立性：**
            *   **进程：** 是独立分配资源和独立接受调度的基本单位。
            *   **程序：** 不是独立单位，不直接参与资源分配和调度。
7.  **试说明 PCB 的作用具体表现在哪几个方面，为什么说 PCB 是进程存在的唯一标志？**
    *   **解答思路：**
        *   **PCB 的作用：**
            *   **独立运行基本单位的标志：** 拥有 PCB 的程序才能成为一个独立的、可并发执行的进程。
            *   **实现间断性运行方式：** 保存和恢复进程的 CPU 现场信息，使得进程可以被中断和恢复。
            *   **提供进程管理所需的信息：** 包含进程状态、优先级、资源清单、程序和数据地址等，用于 OS 对进程进行控制和管理。
            *   **提供进程调度所需的信息：** 提供进程状态、优先级、等待事件等，供调度程序使用。
            *   **实现与其他进程的同步与通信：** 包含同步信号量、通信队列指针等。
        *   **唯一标志：** 操作系统通过 PCB 来识别和管理进程。没有 PCB，进程在系统中就无法被感知、调度和管理。PCB 是操作系统与进程之间的桥梁和纽带。
8.  **PCB 提供了进程管理和进程调度所需要的哪些信息？**
    *   **解答思路：** (结合上一题，具体列举)
        *   **进程管理信息：** 进程标识符（内外）、父子进程关系、用户标识、程序和数据地址、资源清单（已分配和所需）、同步与通信机制（信号量、消息队列指针）。
        *   **进程调度信息：** 进程状态、进程优先级、CPU 寄存器值（上下文）、事件（阻塞原因）、已等待 CPU 时间、已执行时间。
9.  **进程控制块的组织方式有哪几种？**
    *   **解答思路：**
        *   **线性方式（数组）：** 将所有 PCB 组织在一个连续的表中。
        *   **链接方式（链表）：** 将具有相同状态的 PCB 通过指针链接成队列（如就绪队列、阻塞队列）。
        *   **索引方式：** 建立状态索引表，索引表项指向对应状态的 PCB 在 PCB 表中的位置。
10. **何谓操作系统内核？内核的主要功能是什么？**
    *   **解答思路：**
        *   **定义：** 操作系统中与硬件紧密相关、常驻内存、运行频率高、并为其他模块提供支撑的核心部分。通常在系统态（内核态）下运行，具有高特权。
        *   **主要功能：**
            *   **支撑功能：** 中断处理、时钟管理、原语操作。
            *   **资源管理功能：** 进程管理（核心部分如调度、创建、撤销）、存储器管理（核心部分如地址映射、分配回收）、设备管理（核心部分如驱动程序、缓冲管理）。
11. **试说明进程在三个基本状态之间转换的典型原因。**
    *   **解答思路：** (参考图2-5)
        *   **就绪 → 执行：** 进程被调度程序选中，分配到 CPU。
        *   **执行 → 就绪：** 时间片用完；出现更高优先级的进程（抢占式调度）。
        *   **执行 → 阻塞：** 请求并等待某个资源（如 I/O 操作、等待其他进程的信号、申请不到内存）。
        *   **阻塞 → 就绪：** 所等待的事件发生（如 I/O 操作完成、等待的资源被释放、所需信号到达）。
12. **为什么要引入挂起状态？该状态有哪些性质？**
    *   **解答思路：**
        *   **引入原因：**
            *   **终端用户需要：** 调试程序，暂停观察。
            *   **父进程请求：** 考查或修改子进程，协调子进程活动。
            *   **负荷调节需要：** 系统负载过高时，挂起不重要进程。
            *   **操作系统需要：** 检查资源使用，进行记账。
        *   **性质：**
            *   进程处于静止状态，不接受调度。
            *   通常被换出到外存，释放其占用的内存资源。
            *   可以从就绪态或阻塞态转换而来（活动就绪 → 静止就绪，活动阻塞 → 静止阻塞）。
            *   被激活后恢复到原来的状态（静止就绪 → 活动就绪，静止阻塞 → 活动阻塞，或直接进入就绪态）。
13. **在进行进程切换时，所要保存的处理机状态信息有哪些？**
    *   **解答思路：** (即CPU上下文)
        *   **通用寄存器**的值。
        *   **程序计数器 (PC)** 的值。
        *   **程序状态字 (PSW)** 的值。
        *   **用户栈指针 (USP)** 的值（有时还包括核心栈指针KSP）。
14. **试说明引起进程创建的主要事件。**
    *   **解答思路：**
        *   用户登录。
        *   作业调度（批处理系统中）。
        *   提供服务（如用户请求打印，系统创建打印进程）。
        *   应用请求（一个用户进程创建另一个用户进程以实现并发）。
15. **试说明引起进程被撤销的主要事件。**
    *   **解答思路：**
        *   正常结束（任务完成）。
        *   异常结束（如越界、非法指令、除零等）。
        *   外界干预（操作员干预、父进程请求终止子进程、父进程终止导致子进程终止）。
16. **在创建一个进程时所要完成的主要工作是什么？**
    *   **解答思路：**
        *   申请空白 PCB，并分配唯一标识符。
        *   为新进程分配所需资源（内存、文件、I/O设备等）。
        *   初始化 PCB（标识信息、处理机状态信息、处理机控制信息）。
        *   将新进程插入就绪队列。
17. **在撤销一个进程时所要完成的主要工作是什么？**
    *   **解答思路：**
        *   从 PCB 集合中找到被终止进程的 PCB，读取其状态。
        *   若正在执行，立即终止，并置调度标志。
        *   终止其所有子孙进程。
        *   回收该进程拥有的所有资源（归还父进程或系统）。
        *   将 PCB 从所在队列中移出。
18. **试说明引起进程阻塞或被唤醒的主要事件是什么？**
    *   **解答思路：**
        *   **阻塞事件：**
            *   请求共享资源失败（资源已被占用）。
            *   等待某种操作完成（如等待 I/O 结束）。
            *   新数据尚未到达（进程间合作，等待数据）。
            *   等待新任务的到达（服务进程完成当前任务后等待）。
        *   **唤醒事件：** （与阻塞事件对应）
            *   等待的资源被释放。
            *   等待的操作已完成。
            *   所需的新数据已到达。
            *   新的任务已到达。
19. **为什么要在 OS 中引入线程？**
    *   **解答思路：**
        *   **减少并发执行的开销：** 进程作为资源分配和调度的单位，其创建、撤销和切换开销较大。
        *   **提高并发性：** 线程作为调度的基本单位，切换开销小，可以更细粒度地实现并发。
        *   **更好地利用多核处理器：** 一个进程内的多个线程可以并行在多个CPU上执行。
        *   **简化某些应用的编程模型：** 例如，一个应用可以同时处理用户输入、后台计算和网络通信。
20. **试说明线程具有哪些属性？**
    *   **解答思路：** (与进程对比)
        *   **轻量级：** 拥有少量必不可少的资源（TCB、寄存器、栈）。
        *   **调度单位：** 是独立调度和分派的基本单位。
        *   **并发性：** 同一进程内的线程可以并发，不同进程的线程也可以并发。
        *   **共享进程资源：** 共享所属进程的地址空间和大部分资源。
        *   **独立性较低：** 同一进程内的线程间独立性低于进程间的独立性（因为共享资源）。
        *   **系统开销小：** 创建、撤销、切换的开销远小于进程。
21. **试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。**
    *   **解答思路：** (表格形式对比更佳)
        ![[image-14.png]]
22. **线程控制块 TCB 中包含了哪些内容？**
    *   **解答思路：**
        *   线程标识符。
        *   一组寄存器（PC、状态寄存器、通用寄存器）。
        *   线程运行状态。
        *   优先级。
        *   线程专有存储区（用于保存切换时的现场信息）。
        *   信号屏蔽。
        *   堆栈指针（用户栈指针、核心栈指针）。
23. **何谓用户级线程和内核支持线程？**
    *   **解答思路：**
        *   **用户级线程 (ULT)：** 线程的创建、撤销、调度和同步完全在用户空间实现，内核不知道其存在。管理由用户空间的线程库完成。
        *   **内核支持线程 (KST)：** 线程的创建、撤销、调度和同步由内核直接管理。内核知道每个线程的存在，并为其维护 TCB。
24. **试说明用户级线程的实现方法。**
    *   **解答思路：**
        *   **运行时系统 (Runtime System)：** 提供一组用户空间的函数库，用于线程的创建、撤销、调度、同步和通信。线程切换在用户态完成。
        *   **轻型进程 (LWP) 作为中间层 (组合方式的一部分)：** 用户级线程映射到 LWP 上，LWP 再与内核线程交互。LWP 池可以复用。
25. **试说明内核支持线程的实现方法。**
    *   **解答思路：**
        *   内核直接管理线程的 TCB。
        *   进程创建时，内核为其分配任务数据区 (PTDA)，包含 TCB 空间。
        *   线程的创建、撤销、调度、切换都由内核在核心态完成，类似于进程的管理。
26. **多线程模型有哪几种类型？多对一模型有何优缺点？**
    *   **解答思路：**
        *   **类型：**
            *   多对一模型 (Many-to-One)
            *   一对一模型 (One-to-One)
            *   多对多模型 (Many-to-Many)
        *   **多对一模型：**
            *   **优点：** 线程管理在用户空间完成，开销小，效率高。
            *   **缺点：** 如果一个用户线程发起阻塞的系统调用，整个进程（包括所有其他用户线程）都会被阻塞；无法真正利用多核处理器实现并行。
---
**二、 分析与应用题**

1.  **在一个单 CPU 系统中，若有 n 个进程并发执行，则处于就绪队列中的进程数最多可达多少？最少可为多少？**
    *   **解答思路：**
        *   **最多：** n-1 (一个进程在执行，其余 n-1 个都可能在就绪队列中等待)。
        *   **最少：** 0 (一个进程在执行，其他 n-1 个进程都可能处于阻塞状态)。
2.  **在生产者-消费者问题中，若颠倒 `wait(empty)` 和 `wait(mutex)` 的顺序，即改为 `wait(mutex)` 和 `wait(empty)`，会有什么问题？请分析。**
    *   **解答思路：**
        *   **问题：** 可能导致死锁。
        *   **分析：**
            *   假设生产者先执行 `wait(mutex)`，成功获取了互斥锁 `mutex`，进入临界区。
            *   然后生产者执行 `wait(empty)`。如果此时缓冲区已满 (`empty` 信号量为 0 或负数)，生产者会阻塞。
            *   由于生产者阻塞时仍持有 `mutex` 锁，消费者想要进入临界区消费产品（需要执行 `wait(mutex)`）时，会因为无法获取 `mutex` 锁而阻塞。
            *   此时，生产者等待消费者消费产品以释放 `empty` 信号量，而消费者等待生产者释放 `mutex` 锁。双方互相等待，形成死锁。
3.  **试用信号量机制解决“过独木桥”问题：同一方向的行人可以连续过桥，但当另一方向有行人要过桥时，则需等待已在桥上的所有行人通过后才能上桥。**
    *   **解答思路：**
        *   **信号量：**
            *   `mutex_direction`: 互斥信号量，用于控制桥上行人的方向，初值为1。
            *   `count_A`: 记录 A 方向在桥上的人数，初值为 0。
            *   `count_B`: 记录 B 方向在桥上的人数，初值为 0。
            *   `mutex_count_A`: 互斥访问 `count_A`，初值为 1。
            *   `mutex_count_B`: 互斥访问 `count_B`，初值为 1。
            *   `bridge_empty`: 信号量，表示桥是否为空，可用于方向切换的同步，初值为1。
        *   **行人 A 的逻辑：**
            ```
            wait(mutex_direction); // 尝试获取方向控制权
            wait(mutex_count_A);
            if (count_A == 0 && /* 检查是否有B方向等待 */) { // 如果是第一个A方向行人，且桥上无B或B等待
                // 可能需要一个额外的信号量来让B方向等待
            }
            count_A++;
            signal(mutex_count_A);
            // signal(mutex_direction); // 错误：不能在这里释放，否则B可以插队

            // 过桥...

            wait(mutex_count_A);
            count_A--;
            if (count_A == 0) {
                signal(mutex_direction); // 最后一个A方向行人离开，释放方向控制
            }
            signal(mutex_count_A);
            ```
        *   **行人 B 的逻辑：** (类似行人 A)
        *   **改进思路（使用更经典的读者-写者模型变种）：**
            *   将桥看作临界资源。
            *   `bridge`: 互斥信号量，控制对桥的访问，初值为1 (简单情况，只允许一人)。
            *   如果允许多个同向行人：
                *   `direction`: 0 (无方向), 1 (A->B), 2 (B->A)。
                *   `count`: 桥上人数。
                *   `mutex`: 互斥访问 `direction` 和 `count`。
                *   `A_can_cross`, `B_can_cross`: 条件变量或信号量，用于等待。
            *   **行人A想上桥：**
                ```
                wait(mutex);
                while (direction == 2 || (direction == 1 && /* 桥已满，或者有B在等待且B优先级高 */)) {
                    // wait on A_can_cross (or a condition variable)
                }
                direction = 1;
                count++;
                signal(mutex);

                // 过桥

                wait(mutex);
                count--;
                if (count == 0) {
                    direction = 0;
                    // signal B_can_cross (or broadcast on condition variable)
                }
                signal(mutex);
                ```
        *   这是一个相对复杂的问题，需要仔细考虑公平性和死锁。

4.  **在操作系统引入线程，会给并发程序的执行带来哪些好处？同时可能会有哪些问题？**
    *   **解答思路：**
        *   **好处：**
            *   **提高并发度：** 同一进程内多个线程可以并发执行。
            *   **减少系统开销：** 线程创建、撤销、切换的开销远小于进程。
            *   **更好地利用多核CPU：** 同一进程的多个线程可以并行在多核上。
            *   **简化通信：** 同一进程内的线程共享地址空间，通信方便。
            *   **改善程序响应性：** 例如，一个线程处理用户界面，另一个线程执行耗时操作，界面不会卡顿。
        *   **可能的问题：**
            *   **同步问题更复杂：** 由于共享内存，线程间的同步需要更精细的控制，容易出错。
            *   **一个线程的错误可能影响整个进程：** 例如，一个线程非法访问内存导致进程崩溃。
            *   **资源竞争：** 多个线程竞争进程的资源。
            *   **调试困难：** 并发执行的线程使得调试更加复杂。
            *   **用户级线程的局限性：** 如系统调用阻塞整个进程，无法利用多核。

