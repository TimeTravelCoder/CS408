
**引言**

线程已在许多系统中实现，但各系统的实现方式并不完全相同。在有的系统中，特别是一些数据库管理系统，如 Informix 所实现的是**用户级线程**；而另一些系统（如 Macintosh 和 OS/2 操作系统）所实现的是**内核支持线程**；还有一些系统如 Solaris 操作系统，则同时实现了这两种类型的线程。

### 2.8.1 线程的实现方式 (Ways to Implement Threads)

1.  **内核支持线程 KST (Kernel Supported Threads)**
    *   **运行环境：** 在 OS 中的所有进程，无论是系统进程还是用户进程，都是在操作系统内核的支持下运行的，是与内核紧密相关的。而内核支持线程 KST 同样也是在内核的支持下运行的，它们的创建、阻塞、撤销和切换等，也都是在内核空间实现的。
    *   **管理与控制：** 为了对内核线程进行控制和管理，在内核空间也为每一个内核线程设置了一个线程控制块，内核根据该控制块而感知某线程的存在，并对其加以控制。
    *   **优点：**
        *   **(1) 多处理器并行：** 在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行。
        *   **(2) 阻塞处理：** 如果进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程。
        *   **(3) 轻量级：** 内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小。
        *   **(4) 内核多线程：** 内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。
    *   **缺点：**
        *   **模式切换开销：** 对于用户的线程切换而言，其模式切换的开销较大。在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到核心态进行，这是因为用户进程的线程是在用户态运行，而线程调度和管理是在内核实现的，系统开销较大。
2.  **用户级线程 ULT (User Level Threads)**
    *   **运行环境：** 用户级线程是在用户空间中实现的。对线程的创建、撤销、同步与通信等功能，都无需内核的支持，即用户级线程是与内核无关的。
    *   **数量：** 在一个系统中的用户级线程的数目可以达到数百个至数千个。
    *   **管理：** 由于这些线程的任务控制块都是设置在用户空间，而线程所执行的操作也无需内核的帮助，因而内核完全不知道用户级线程的存在。
    *   **调度：** 对于设置了用户级线程的系统，其调度仍是以进程为单位进行的。在采用轮转调度算法时，各个进程轮流执行一个时间片，这对诸进程而言貌似是公平的。但假如在进程 A 中包含了一个用户级线程，而在另一个进程 B 中含有 100 个用户级线程，这样，进程 A 中线程的运行时间将是进程 B 中各线程运行时间的 100 倍；相应地，其速度要快上 100 倍，因此说实质上并不公平。
    *   **内核支持线程的调度：** 假如系统中设置的是内核支持线程，则调度便是以线程为单位进行的。在采用轮转法调度时，是各个线程轮流执行一个时间片。同样假定进程 A 中只有一个内核支持线程，而在进程 B 中有 100 个内核支持线程。此时进程 B 可以获得的 CPU 时间是进程 A 的 100 倍，且进程 B 可使 100 个系统调用并发工作。
    *   **优点：**
        *   **(1) 快速切换：** 线程切换不需要转换到内核空间。对一个进程而言，其所有线程的管理数据结构均在该进程的用户空间中，管理线程切换的线程库也在用户地址空间运行，因此进程不必切换到内核方式来做线程管理，从而节省了模式切换的开销。
        *   **(2) 调度算法进程专用：** 在不干扰 OS 调度的情况下，不同的进程可以根据自身需要选择不同的调度算法，对自己的线程进行管理和调度，而与 OS 的低级调度算法是无关的。
        *   **(3) OS平台无关性：** 用户级线程的实现与 OS 平台无关，因为对于线程管理的代码是属于用户程序的一部分，所有的应用程序都可以对之进行共享。因此，用户级线程甚至可以在不支持线程机制的操作系统平台上实现。
    *   **缺点：**
        *   **(1) 系统调用阻塞问题：** 在基于进程机制的 OS 中，大多数系统调用将使进程阻塞。因此，当线程执行一个系统调用时，不仅该线程被阻塞，而且，进程内的所有线程都会被阻塞（因为内核只知道进程，不知道线程）。而在内核支持线程方式中，则进程中的其它线程仍然可以运行。
        *   **(2) 无法利用多处理机：** 在单纯的用户级线程实现方式中，多线程应用不能利用多处理机进行多重处理的优点。内核每次分配给一个进程的仅有一个 CPU，因此，进程中仅有一个线程能执行，在该线程放弃 CPU 之前，其它线程只能等待。
3.  **组合方式 (Combined ULT/KST Approach)**
    *   有些 OS 把用户级线程和内核支持线程两种方式进行组合，提供了组合方式 ULT/KST 线程。
    *   **实现：** 在组合方式线程系统中，内核支持多个内核支持线程的建立、调度和管理，同时，也允许用户应用程序建立、调度和管理用户级线程。
    *   **映射关系：** 一些内核支持线程对应多个用户级线程，这是用户级线程通过**时分多路复用 (Time Division Multiplexing)** 内核支持线程来实现的。即将用户级线程对部分或全部内核支持线程进行多路复用。
    *   **灵活性：** 程序员可按应用需要和机器配置，对内核支持线程数目进行调整，以达到较好效果。
    *   **优点：** 同一个进程内的多个线程可以同时在多处理器上并行执行，而且在阻塞一个线程时并不需要将整个进程阻塞。所以，组合方式多线程机制能够结合 KST 和 ULT 两者的优点，并克服其各自的不足。
    *   **连接方式模型 (图2-18)：** 由于用户级线程和内核支持线程连接方式的不同，从而形成了三种不同的模型：
	    * ![[image-34.png]]
        *   **(a) 多对一模型 (Many-to-One Model)：**
            *   将多个用户级线程映射到一个内核级线程。
            *   这些用户级线程一般属于一个进程，运行在该进程的用户空间。
            *   对这些线程的调度和管理也是在该进程的用户空间中完成。
            *   仅当用户级线程需要访问内核时，才将其映射到一个内核级线程上，但每次只允许一个线程进行映射。
            *   **优点：** 线程管理的开销小，效率高。
            *   **缺点：** 如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞；此外，在任一时刻，只有一个线程能够访问内核，多个线程不能同时在多个处理机上运行。
        *   **(b) 一对一模型 (One-to-One Model)：**
            *   将每一个用户级线程映射到一个内核级线程。
            *   为每一个用户级线程都设置一个内核级线程与之连接。
            *   **优点：** 当一个线程阻塞时，允许调度另一个线程运行，所以它提供了比多对一模型更好的并发功能。此外，在多处理机系统中，它允许多个线程并行地运行在多处理机系统上。
            *   **缺点：** 每创建一个用户级线程，相应地就需要创建一个内核级线程，开销较大，因此需要限制整个系统的线程数。Windows 2000、Windows NT、OS/2 等系统上都实现了该模型。
        *   **(c) 多对多模型 (Many-to-Many Model)：**
            *   将许多用户级线程映射到同样数量或更少数量的内核级线程上。
            *   内核控制线程的数目可以根据应用进程和系统的不同而变化，可以比用户线程少，也可以与之相同。
            *   该模型结合上述两种模型的优点，它可以像一对一模型那样，使一个进程的多个线程并行地运行在多处理机系统上，也可像多对一模型那样，减少线程的管理开销和提高效率。Solaris、IRIX、HP-UX 等采用此模型。
### 2.8.2 线程的实现 (Detailed Implementation of Threads)

不论是进程还是线程，都必须直接或间接地取得内核的支持。由于内核支持线程可以直接利用系统调用为它服务，故线程的控制相当简单；而用户级线程必须借助于某种形式的中间系统的帮助方能取得内核的服务，故在对线程的控制上要稍复杂些。

1.  **内核支持线程的实现 (Implementation of Kernel Supported Threads)**
    *   在仅设置了内核支持线程的 OS 中，一种可能的线程控制方法是，系统在创建一个新进程时，便为它分配一个**任务数据区 PTDA (Per Task Data Area)**，其中包括若干个线程控制块 TCB 空间，如图2-19所示。
	    * ![[image-35.png]]
    *   在每一个 TCB 中可保存线程标识符、优先级、线程运行的 CPU 状态等信息。虽然这些信息与用户级线程 TCB 中的信息相同，但现在却是被保存在内核空间中。
    *   **线程创建与撤销：**
        *   每当进程要创建一个线程时，便为新线程分配一个 TCB，将有关信息填入该 TCB 中，并为之分配必要的资源，如为线程分配数百至数千个字节的栈空间和局部存储区，于是新创建的线程便有条件立即执行。
        *   当 PTDA 中的所有 TCB 空间已用完，而进程又要创建新的线程时，只要其所创建的线程数目未超过系统的允许值（通常为数十至数百个），系统可再为之分配新的 TCB 空间。
        *   在撤销一个线程时，也应回收该线程的所有资源和 TCB。
        *   可见，内核支持线程的创建、撤销均与进程的相类似。
    *   **开销优化：** 在有的系统中为了减少在创建和撤销一个线程时的开销，在撤销一个线程时并不立即回收该线程的资源和 TCB，这样，当以后再要创建一个新线程时，便可直接利用已被撤销但仍保持有资源的 TCB 作为新线程的 TCB。
    *   **调度与切换：** 内核支持线程的调度和切换与进程的调度和切换十分相似，也分抢占式方式和非抢占式方式两种。在线程的调度算法上，同样可采用时间片轮转法、优先权算法等。当线程调度选中一个线程后，便将处理机分配给它。当然，线程在调度和切换上所花费的开销要比进程的小得多。
2.  **用户级线程的实现 (Implementation of User Level Threads)**
    用户级线程是在用户空间实现的。所有的用户级线程都具有相同的结构，它们都运行在一个中间系统上。当前有两种方式实现中间系统，即**运行时系统 (Runtime System)** 和**内核控制线程 (Light Weight Process, LWP)**。
    *   **1) 运行时系统 (Runtime System)**
        *   所谓“运行时系统”，实质上是用于管理和控制线程的**函数（过程）的集合**，其中包括用于创建和撤销线程的函数、线程同步和通信的函数，以及实现线程调度的函数等。
        *   正因为有这些函数，才能使用户级线程与内核无关。运行时系统中的所有函数都驻留在用户空间，并作为用户级线程与内核之间的接口。
        *   **切换：** 在传统的 OS 中，进程在切换时必须先由用户态转为核心态，再由核心来执行切换任务；而用户级线程在切换时则不须转入核心态，而是由运行时系统中的线程切换过程（函数），来执行切换任务。该过程将线程的 CPU 状态保存在该线程的堆栈中，然后按照一定的算法，选择一个处于就绪状态的新线程运行，将新线程堆栈中的 CPU 状态装入到 CPU 相应的寄存器中，一旦将栈指针和程序计数器切换后，便开始了新线程的运行。由于用户级线程的切换无须进入内核，且切换操作简单，因而使用户级线程的切换速度非常快。
        *   **资源请求：** 不论在传统的 OS 中，还是在多线程 OS 中，系统资源都是由内核管理的。在传统的 OS 中，进程是利用 OS 提供的系统调用来请求系统资源的，系统调用通过软中断（如 trap）机制进入 OS 内核，由内核来完成相应资源的分配。用户级线程是不能利用系统调用的。当线程需要系统资源时，是将该要求传送给运行时系统，由后者通过相应的系统调用来获得系统资源。
    *   **2) 内核控制线程 (Light Weight Process, LWP)**
        *   这种线程又称为**轻型进程 LWP (Light Weight Process)**。每一个进程都可拥有多个 LWP。
        *   同用户级线程一样，每个 LWP 都有自己的数据结构（如 TCB），其中包括线程标识符、优先级、状态，另外还有栈和局部存储区等。LWP 也可以共享进程所拥有的资源。
        *   LWP 可通过系统调用来获得内核提供的服务。这样，当一个用户级线程运行时，只须将它连接到一个 LWP 上，此时它便具有了内核支持线程的所有属性。这种线程实现方式就是**组合方式**。
        *   在一个系统中的用户级线程数量可能很大，为了节省系统开销，不可能设置太多的 LWP，而是把这些 LWP 做成一个**缓冲池**，称为“**线程池**”。用户进程中的任一用户线程都可以连接到 LWP 池中的任何一个 LWP 上。
        *   **通信：** 为使每一用户级线程都能利用 LWP 与内核通信，可以使多个用户级线程多路复用一个 LWP，但只有当前连接到 LWP 上的线程才能与内核通信，其余进程或者阻塞，或者等待 LWP。而每一个 LWP 都要连接到一个内核级线程上。这样，通过 LWP 可把用户级线程与内核线程连接起来，用户级线程可通过 LWP 来访问内核，但内核所看到的总是多个 LWP 而看不到用户级线程。亦即，由 LWP 实现了内核与用户级线程之间的隔离，从而使用户级线程与内核无关。图2-20 示出了利用轻型进程作为中间系统时用户级线程的实现方法。![[image-381.png]]
        *   **阻塞处理：** 当内核级线程执行操作时，如果发生阻塞，则与之相连接的多个 LWP 也将随之阻塞，进而使连接到 LWP 上的用户级线程也被阻塞。如果进程中只包含了一个 LWP，此时进程也应阻塞。这种情况与前述的传统 OS 一样，在进程执行系统调用时，该进程实际上是阻塞的。但如果在一个进程中含有多个 LWP，则当一个 LWP 阻塞时，进程中的另一个 LWP 可继续执行；即使进程中的所有 LWP 全部阻塞，进程中的线程也仍然能继续执行，只是不能再去访问内核。
### 2.8.3 线程的创建和终止 (Thread Creation and Termination)

如同进程一样，线程也是具有生命期的，它由创建而产生，由调度而执行，由终止而消亡。相应的，在 OS 中也就有用于创建线程的函数（或系统调用）和用于终止线程的函数（或系统调用）。

1.  **线程的创建 (Thread Creation)**
    *   应用程序在启动时，通常仅有一个线程在执行，人们把该线程称为“**初始化线程**”。
    *   它的主要功能是用于创建新线程。在创建新线程时，需要利用一个**线程创建函数（或系统调用）**，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。
    *   在线程的创建函数执行完后，将返回一个线程标识符供以后使用。
2.  **线程的终止 (Thread Termination)**
    *   当一个线程完成了自己的任务（工作）后，或是线程在运行中出现异常情况而须被强行终止时，由终止线程通过调用相应的函数（或系统调用）对它执行终止操作。
    *   但有些线程（主要是系统线程），它们一旦被建立起来之后，便一直运行下去而不被终止。
    *   在大多数的 OS 中，线程被中止后并不立即释放它所占有的资源，只有当进程中的其它线程执行了分离函数后，被终止的线程才与资源分离，此时的资源才能被其它线程利用。
    *   虽已被终止但尚未释放资源的线程仍可以被需要它的线程所调用，以使被终止线程重新恢复运行。为此，调用线程须调用一条被称为“**等待线程终止**”的连接命令来与该线程进行连接。如果在一个调用者线程调用“等待线程终止”的连接命令，试图与指定线程相连接时，若指定线程尚未被终止，则调用连接命令的线程将会阻塞，直至指定线程被终止后，才能实现它与调用者线程的连接并继续执行；若指定线程已被终止，则调用者线程不会被阻塞而是继续执行。
* 小结:线程的实现方式直接影响到其性能、并发能力以及与操作系统的交互方式。内核支持线程提供了更好的并行性和对阻塞的处理，但开销较大；用户级线程开销小、灵活，但受限于系统调用阻塞和无法利用多核；组合方式则试图结合两者的优点。理解这些实现机制及其背后的权衡，对于选择合适的线程模型和进行高效的并发编程至关重要。