
**引言**
*   **并发执行的挑战：** 在多道程序环境下，程序的执行属于并发执行。此时，程序会失去其封闭性，具有间断性，并且其运行结果具有不可再现性。
*   **进程的引入：** 为了使程序能并发执行，并且可以对并发执行的程序加以描述和控制，操作系统引入了“**进程 (Process)**”的概念。
### 2.2.1 进程的定义和特征
1.  **进程的定义 (Process Definition)**
    *   **核心思想：** 为了使参与并发执行的每个程序（含数据）都能独立地运行。
    *   **实现机制：** 操作系统为每个这样的程序配置一个专门的数据结构，称为**进程控制块 (Process Control Block, PCB)**。
    *   **进程实体 (Process Entity) / 进程映像 (Process Image)：** 由程序段、相关的数据段和 PCB 三部分构成。
    *   **通俗理解：** 一般情况下，我们把进程实体就简称为进程。
        *   所谓创建进程，实质上是创建进程实体中的 PCB。
        *   所谓撤销进程，实质上是撤销进程的 PCB。
    *   **不同角度的典型定义：**
        *   **(1) 进程是程序的一次执行。** (强调动态性)
        *   **(2) 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。** (强调活动和顺序性)
        *   **(3) 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。** (强调功能、数据、过程以及作为资源分配和调度单位)
    *   **引入进程实体概念后的 OS 中进程定义：** “进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。”
2.  **进程的特征 (Characteristics of a Process)**
    进程和程序是两个截然不同的概念。除了进程具有程序所没有的 PCB 结构外，还具有以下特征：
    *   **(1) 动态性 (Dynamic)：**
        *   **核心特征：** 进程的实质是进程实体的**执行过程**。
        *   **生命周期：** 进程“由创建而产生，由调度而执行，由撤销而消亡”。
        *   **对比程序：** 程序是一组有序指令的集合，存放于某种介质上，本身不具有活动的含义，是静态的。
    *   **(2) 并发性 (Concurrency)：**
        *   指多个进程实体同存于内存中，且能在一段时间内同时运行。
        *   **引入目的：** 引入进程的目的正是为了使其进程实体能和其它进程实体并发执行。
        *   **OS 的重要特征：** 并发性是进程的重要特征，也是操作系统的重要特征。
        *   **对比程序：** 没有建立 PCB 的程序不能参与并发执行。
    *   **(3) 独立性 (Independence)：**
        *   在传统的 OS 中，独立性指进程实体是一个能**独立运行**、**独立获得资源**和**独立接受调度**的基本单位。
        *   **对比程序：** 凡未建立 PCB 的程序都不能作为一个独立的单位参与运行。
    *   **(4) 异步性 (Asynchrony)：**
        *   指进程是按**异步方式**运行的，即按各自独立的、不可预知的速度向前推进。
        *   **与不可再现性的关系：** 正是由于异步性，才导致了传统意义上的程序若参与并发执行，会产生其结果的不可再现性。
        *   **OS 的作用：** 为使进程在并发执行时虽具有异步性，但仍能保证进程并发执行的结果是可再现的，OS 中引进了进程的概念，并配置了相应的进程同步机制。
### 2.2.2 进程的基本状态及转换
由于多个进程在并发执行时共享系统资源，致使它们在运行过程中呈现间断性的运行规律，因此进程在其生命周期内可能具有多种状态。

1.  **进程的三种基本状态 (Three Basic States of a Process)**
    一般而言，每一个进程至少应处于以下三种基本状态之一：
    *   **(1) 就绪状态 (Ready State)：**
        *   指进程已处于**准备好运行**的状态。
        *   即进程已分配到除 CPU 以外的所有必要资源，只要再获得 CPU，便可立即执行。
        *   **就绪队列 (Ready Queue)：** 如果系统中有许多处于就绪状态的进程，通常将它们按一定的策略（如优先级策略）排成一个队列。
    *   **(2) 执行状态 (Running State)：**
        *   指进程**已获得 CPU**，其程序正在执行的状态。
        *   **单处理机系统：** 任何时刻只有一个进程处于执行状态。
        *   **多处理机系统：** 则有多个进程处于执行状态。
    *   **(3) 阻塞状态 (Blocked State / Wait State / Block State)：**
        *   指正在执行的进程由于发生某事件（如 I/O 请求、申请缓冲区失败等）暂时无法继续执行时的状态，即进程的执行受到阻塞。
        *   **进程调度：** 此时引起进程调度，OS 把处理机分配给另一个就绪进程，而让受阻进程处于暂停状态。
        *   **阻塞队列 (Blocked Queue)：** 通常系统将处于阻塞状态的进程也排成一个队列。在较大的系统中，为了减少队列操作的开销，提高系统效率，根据阻塞原因的不同，会设置多个阻塞队列。
2.  **三种基本状态的转换 (Transitions between Three Basic States)** (参考图2-5)
      ![[image-21.png]]
    进程在运行过程中会经常发生状态的转换：
    *   **就绪 → 执行：**
        *   处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变为执行状态。
    *   **执行 → 就绪：**
        *   处于执行状态的进程（当前进程），在其执行过程中，如果因分配给它的**时间片已完**而被剥夺处理机暂停执行时，该进程便由执行状态转变为就绪状态。
    *   **执行 → 阻塞：**
        *   正在执行的进程，如果因发生某事件，如访问临界资源而该资源正被其它进程访问，导致当前进程的执行受阻，使之无法继续执行，则该进程将由执行状态转变为阻塞状态。
    *   **阻塞 → 就绪：**
        *   处于阻塞状态的进程，若其所期待的事件已经发生（例如，它所启动的 I/O 操作已完成，或其所等待的资源已有空闲），则由有关的系统功能（如中断处理程序）将其从阻塞状态转换为就绪状态。
3.  **创建状态和终止状态 (Create State and Terminate State)**
    为了满足进程控制块对数据及操作的完整性要求以及增强管理的灵活性，通常在系统中又为进程引入了两种常见的状态：
    *   **(1) 创建状态 (New/Create State)：**
        *   进程由创建而产生。创建一个进程是一个很复杂的过程，一般要通过多个步骤才能完成：
            1.  进程申请一个空白 PCB，并向 PCB 中填写用于控制和管理进程的信息。
            2.  为该进程分配运行时所必须的资源。
            3.  把该进程转入就绪状态并插入就绪队列之中。
        *   如果进程所需的资源尚不能得到满足（例如系统尚无足够的内存使进程无法装入其中），此时创建工作尚未完成，进程不能被调度运行，于是把此时进程所处的状态称为**创建状态**。
        *   **引入目的：**
            *   保证进程的调度必须在创建工作完成后进行，以确保对进程控制块操作的完整性。
            *   增加管理的灵活性，OS 可以根据系统性能或主存容量的限制推迟新进程的提交（使其处于创建状态）。
        *   **转换：** 对于处于创建状态的进程，当其获得了所需的资源以及对其 PCB 的初始化工作完成后，便可由创建状态转入就绪状态。
    *   **(2) 终止状态 (Terminated State)：**
        *   进程的终止也要通过两个步骤：
            1.  等待操作系统进行善后处理（如提取状态码、收集统计数据等）。
            2.  将其 PCB 清零，并将 PCB 空间返还系统。
        *   当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入**终止状态**。
        *   进入终止状态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其它进程收集。
        *   一旦其它进程完成了对其信息的提取之后，操作系统将删除该进程（即将其 PCB 清零），并将该空白 PCB 返还系统。
	*   **图2-6 展示了增加了创建状态和终止状态后进程的五种状态及转换关系图。**
         ![[image-22.png]]
### 2.2.3 挂起操作和进程状态的转换

在许多系统中，进程除了就绪、执行和阻塞三种最基本的状态外，为了系统和用户观察和分析进程的需要，还引入了一个对进程的重要操作——**挂起操作 (Suspend Operation)**。
1.  **挂起操作的引入 (Introduction of Suspend Operation)**

    *   当挂起操作作用于某个进程时，该进程将被挂起，意味着此时该进程处于**静止状态**。
    *   如果进程正在执行，它将暂停执行。
    *   若原本处于就绪状态，则该进程此时暂不接受调度。
    *   与挂起操作对应的操作是**激活操作 (Activate Operation)**。
    *   **引入挂起操作的原因 (基于系统和用户的需要)：**
        *   **(1) 终端用户的需要：** 当终端用户在自己的程序运行期间发现有可疑问题，希望暂停自己程序的运行，使之停止下来，以便用户研究其执行情况或对程序进行修改。
        *   **(2) 父进程请求：** 有时父进程希望挂起自己的某个子进程，以便考查和修改该子进程，或者协调各子进程间的活动。
        *   **(3) 负荷调节的需要：** 当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。
        *   **(4) 操作系统的需要：** 操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。
2.  **引入挂起原语操作后三个进程状态的转换** (Suspend 和 Active 原语)
    在引入挂起原语 Suspend 和激活原语 Active 后，在它们的作用下，进程将可能发生以下几种状态的转换：
    *   **(1) 活动就绪 → 静止就绪 (Ready_Active → Ready_Suspend)：**
        *   当进程处于未被挂起的就绪状态时，称此为**活动就绪状态** (Readya)，此时进程可以接受调度。
        *   当用挂起原语 Suspend 将该进程挂起后，该进程便转变为**静止就绪状态** (Readys)，处于 Readys 状态的进程不再被调度执行。
    *   **(2) 活动阻塞 → 静止阻塞 (Blocked_Active → Blocked_Suspend)：**
        *   当进程处于未被挂起的阻塞状态时，称它是处于**活动阻塞状态** (Blockeda)。
        *   当用 Suspend 原语将它挂起后，进程便转变为**静止阻塞状态** (Blockeds)。
        *   处于该状态的进程在其所期待的事件出现后，它将从静止阻塞变为静止就绪 Readys 状态。
    *   **(3) 静止就绪 → 活动就绪 (Ready_Suspend → Ready_Active)：**
        *   处于 Readys 状态的进程若用激活原语 Active 激活后，该进程将转变为 Readya 状态。
    *   **(4) 静止阻塞 → 活动阻塞 (Blocked_Suspend → Blocked_Active)：**
        *   处于 Blockeds 状态的进程若用激活原语 Active 激活后，进程将转变为 Blockeda 状态。
	*   **图2-7 示出了具有挂起状态的进程状态图。**
      ![[image-23.png]]
3.  **引入挂起操作后五个进程状态的转换** (增加了创建和终止状态)
    *   如图2-8所示，引进了创建和终止状态后，在进程状态转换时，与图2-7所示的进程五状态转换相比较，要增加考虑下面的几种情况：
        *   **(1) NULL → 创建：** 一个新进程产生时，该进程处于创建状态。
        *   **(2) 创建 → 活动就绪：** 在当前系统的性能和内存的容量均允许的情况下，完成对进程创建的必要操作后，相应的系统进程将进程的状态转换为活动就绪状态。
        *   **(3) 创建 → 静止就绪：** 考虑到系统当前资源状况和性能的要求，不分配给新建进程所需资源（主要是主存），相应的系统将进程状态转为静止就绪状态，被安置在外存，不参与调度，此时进程创建工作尚未完成。
        *   **(4) 执行 → 终止：** 当一个进程已完成任务时，或是出现了无法克服的错误，或是被 OS 或其他进程所终结，此时将进程的状态转换为终止状态。
	*   **图2-8 展示了具有创建、终止和挂起状态的进程状态图。**
      ![[image-24.png]]
### 2.2.4 进程管理中的数据结构
操作系统为了管理和控制进程，需要使用各种数据结构来记录和组织进程信息。

1.  **操作系统中用于管理控制的数据结构**
    *   计算机系统中，对于每个资源和每个进程都设置了一个数据结构，用于表征其实体，称之为**资源信息表**或**进程信息表**。
    *   其中包含了资源或进程的标识、描述、状态等信息以及一批指针。
    *   通过这些指针，可以将同类资源或进程的信息表，或者同一进程所占用的资源信息表分类链接成不同的队列，便于操作系统进行查找。
    *   **OS 管理的数据结构一般分为四类 (图2-9)：**
	    * ![[image-25.png]]
        *   **内存表 (Memory Table)：** 描述内存分配情况。
        *   **设备表 (Device Table)：** 描述系统中设备的状况及分配情况。
        *   **文件表 (File Table)：** 描述文件系统中的文件信息。
        *   **进程表 (Process Table) / 进程控制块 (PCB)：** 用于进程管理的进程表，**本节着重介绍 PCB**。
2.  **进程控制块 PCB 的作用 (Role of PCB)**
    *   为了便于系统描述和管理进程的运行，OS 的核心为每个进程专门定义了一个数据结构——**进程控制块 PCB (Process Control Block)**。
    *   PCB 作为进程实体的一部分，记录了操作系统所需的、用于描述进程的当前情况以及管理进程运行的全部信息，是操作系统中**最重要的记录型数据结构**。
    *   **PCB 的具体作用：**
        *   **(1) 作为独立运行基本单位的标志：**
            *   当一个程序（含数据）配置了 PCB 后，就表示它已是一个能在多道程序环境下独立运行的、合法的基本单位。
            *   它具有取得 OS 服务的权利（如打开文件、请求 I/O 设备、与其他进程通信等）。
            *   系统创建新进程时，就为它建立一个 PCB；进程结束时又回收其 PCB。
            *   **系统是通过 PCB 感知进程的存在的。PCB 已成为进程存在于系统中的唯一标志。**
        *   **(2) 能实现间断性运行方式：**
            *   在多道程序环境下，程序是采用停停走走间断性的运行方式运行的。
            *   当进程因阻塞而暂停运行时，它必须保留自己运行时的 CPU 现场信息，再次被调度运行时，还需要恢复其 CPU 现场信息。
            *   有了 PCB 后，系统就可将 CPU 现场信息保存在被中断进程的 PCB 中，供该进程再次被调度执行时恢复 CPU 现场时使用。
            *   **强调：** 传统意义上的静态程序，因其不具有保护或保存自己运行现场的手段，无法保证其运行结果的可再现性，从而失去运行的意义。
        *   **(3) 提供进程管理所需要的信息：**
            *   当调度程序调度到某进程运行时，只能根据该进程 PCB 中记录的程序和数据在内存或外存中的始址指针，找到相应的程序和数据。
            *   在进程运行过程中，当需要访问文件系统中的文件或 I/O 设备时，也都需要借助于 PCB 中的信息。
            *   还可根据 PCB 中的资源清单了解到该进程所需的全部资源等。
            *   在进程的整个生命期中，操作系统总是根据 PCB 实施对进程的控制和管理。
        *   **(4) 提供进程调度所需要的信息：**
            *   只有处于就绪状态的进程才能被调度执行，而在 PCB 中就提供了进程处于何种状态的信息。
            *   如果进程处于就绪状态，系统便将它插入到进程就绪队列中，等待着调度程序的调度。
            *   进行调度时往往还需要了解进程的其他信息，如在优先级调度算法中，就需要知道进程的优先级。在某些较为公平的调度算法中，还需要知道进程的等待时间和已执行的时间等。
        *   **(5) 实现与其它进程的同步与通信：**
            *   进程同步机制是用于实现诸进程的协调运行的。
            *   在采用信号量机制时，它要求在每个进程中都设置有相应的用于同步的信号量。
            *   在 PCB 中还具有用于实现进程通信的区域或通信队列指针等。
3.  **进程控制块中的信息 (Information in PCB)**
    在进程控制块中，主要包括以下四个方面的信息：
    *   **1) 进程标识符 (Process Identifier)**
        *   用于唯一地标识一个进程。一个进程通常有两种标识符：
            *   **(a) 外部标识符 (External ID)：**
                *   为了方便用户（进程）对进程的访问，须为每一个进程设置一个外部标识符。
                *   它是由创建者提供的，通常由字母、数字组成。
                *   为了描述进程的家族关系，还应设置父进程标识及子进程标识。
                *   此外，还可设置用户标识，以指示拥有该进程的用户。
            *   **(b) 内部标识符 (Internal ID)：**
                *   为了方便系统对进程的使用，在 OS 中又为进程设置了内部标识符。
                *   即赋予每一个进程一个唯一的数字标识符，它通常是一个进程的序号。
    *   **2) 处理机状态 (Processor State / Context)**
        *   处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。这些寄存器包括：
            *   **(a) 通用寄存器 (General-Purpose Registers)：** 又称为用户可视寄存器，它们是用户程序可以访问的，用于暂存信息。在大多数处理机中，有 8~32 个通用寄存器，在 RISC 结构的计算机中可超过 100 个。
            *   **(b) 指令计数器 (Instruction Pointer / Program Counter)：** 其中存放了要访问的下一条指令的地址。
            *   **(c) 程序状态字 PSW (Program Status Word)：** 其中含有状态信息，如条件码、执行方式、中断屏蔽标志等。
            *   **(d) 用户栈指针 (User Stack Pointer)：** 指每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶。
            *   当进程被切换时，处理机状态信息都必须保存在相应的 PCB 中，以便在该进程重新执行时能再从断点继续执行。
    *   **3) 进程调度信息 (Process Scheduling Information)**
        *   在 OS 进行调度时，必须了解进程的状态及有关进程调度的信息，这些信息包括：
            *   **(a) 进程状态 (Process State)：** 指明进程的当前状态，它是作为进程调度和对换时的依据。
            *   **(b) 进程优先级 (Process Priority)：** 是用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机。
            *   **(c) 进程调度所需的其它信息：** 它们与所采用的进程调度算法有关，比如，进程已等待 CPU 的时间总和、进程已执行的时间总和等。
            *   **(d) 事件 (Event)：** 是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。
    *   **4) 进程控制信息 (Process Control Information)**
        *   是指用于进程控制所必须的信息，它包括：
            *   **(a) 程序和数据的地址：** 进程实体中的程序和数据的内存或外存地(首)址，以便再调度到该进程执行时，能从 PCB 中找到其程序和数据。
            *   **(b) 进程同步和通信机制：** 这是实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等，它们可能全部或部分地放在 PCB 中。
            *   **(c) 资源清单 (Resource List)：** 在该清单中列出了进程在运行期间所需的全部资源(除 CPU 以外)，另外还有一张已分配到该进程的资源的清单。
            *   **(d) 链接指针 (Link Pointer)：** 它给出了本进程(PCB)所在队列中的下一个进程的 PCB 的首地址。
4.  **进程控制块的组织方式 (Organization of PCBs)**
    在一个系统中，通常可拥有数十个、数百个乃至数千个 PCB。为了能对它们加以有效的管理，应该用适当的方式将这些 PCB 组织起来。目前常用的组织方式有以下三种：
    *   **(1) 线性方式 (Linear List / Array)：** (图2-10)
	    * ![[image-26.png]]
        *   将系统中所有的 PCB 都组织在一张线性表中，将该表的首址存放在内存的一个专用区域中。
        *   **优点：** 实现简单、开销小。
        *   **缺点：** 每次查找时都需要扫描整张表，因此适合进程数目不多的系统。
    *   **(2) 链接方式 (Linked List)：** (图2-11)
	    * ![[image-27.png]]
        *   把具有相同状态进程的 PCB 分别通过 PCB 中的链接字链接成一个队列。
        *   这样，可以形成就绪队列、若干个阻塞队列和空白队列等。
        *   **就绪队列：** 往往按进程的优先级将 PCB 从高到低进行排列，将优先级高的进程 PCB 排在队列的前面。
        *   **阻塞队列：** 也可把处于阻塞状态进程的 PCB 根据其阻塞原因的不同，排成多个阻塞队列，如等待 I/O 操作完成的队列和等待分配内存的队列等。
    *   **(3) 索引方式 (Indexed List)：** (图2-12)
	    * ![[image-28.png]]
        *   系统根据所有进程状态的不同，建立几张索引表，例如，就绪索引表、阻塞索引表等。
        *   并把各索引表在内存的首地址记录在内存的一些专用单元中。
        *   在每个索引表的表目中，记录具有相应状态的某个 PCB 在 PCB 表中的地址。

**小结：** 进程是操作系统中并发执行的核心概念，它通过 PCB 这一关键数据结构来描述和管理。理解进程的特征、状态转换以及 PCB 的作用和组织方式，是深入学习操作系统后续内容（如进程调度、同步、通信等）的基础。