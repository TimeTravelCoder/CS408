
**引言**
*   **传统操作系统的问题：** 早期未配置操作系统或单道批处理系统中，程序顺序执行。即内存中仅装入一道用户程序，独占所有资源，执行完毕后才允许装入并执行下一道。
    *   **缺点：** 资源浪费、系统运行效率低。
*   **多道程序技术的引入：** 为了提高资源利用率和系统吞吐量，引入多道程序技术。多个程序同时装入内存并并发运行。
    *   **改变：** 传统意义上的程序不再能独立运行，需要新的基本单位——**进程**。
*   **本节目的：** 阐述程序的顺序执行和并发执行方式，为后续理解进程概念打下基础。
### 2.1.1 前趋图 (Precedence Graph)
为了更好地描述程序的顺序和并发执行情况，引入前趋图。
1.  **定义：**
    *   前趋图是一个**有向无循环图 (Directed Acyclic Graph, DAG)**。
    *   用于描述一组进程（或程序段、语句）之间执行的先后顺序。
2.  **组成元素：**
    *   **结点 (Node)：**
        *   代表一个进程、一个程序段，甚至一条语句。
        *   通常具有一个**重量 (Weight)**，表示该结点所含有的程序量或程序的执行时间。
    *   **有向边 (Directed Edge)：**
        *   连接两个结点，表示它们之间存在的**偏序 (Partial Order)** 或 **前趋关系 (Precedence Relation)**。
        *   若存在从 Pᵢ 到 Pⱼ 的有向边，表示 Pᵢ 必须在 Pⱼ 开始执行之前完成。
3.  **前趋关系的表示：**
    *   可用符号 “→” 表示。
    *   若进程 Pᵢ 和 Pⱼ 存在前趋关系，可表示为 (Pᵢ, Pⱼ) ∈ →，或 Pᵢ → Pⱼ。
    *   含义：Pᵢ 必须在 Pⱼ 开始执行之前完成。
    *   **术语：**
        *   Pᵢ 称为 Pⱼ 的**直接前趋 (Direct Predecessor)**。
        *   Pⱼ 称为 Pᵢ 的**直接后继 (Direct Successor)**。
4.  **特殊结点：**
    *   **初始结点 (Initial Node)：** 没有前趋的结点。
    *   **终止结点 (Final Node)：** 没有后继的结点。
5.  **示例 (图2-1(a) 所示)：**
     ![[image-17.png]]
	*   设有一组进程 P = {P₁, P₂, P₃, P₄, P₅, P₆, P₇, P₈, P₉}。
    *   其前趋关系可表示为：
        *   P₁→P₂, P₁→P₃, P₁→P₄
        *   P₂→P₅, P₃→P₅
        *   P₄→P₆, P₄→P₇
        *   P₅→P₈, P₆→P₈
        *   P₇→P₉, P₈→P₉
    *   也可以用序偶集合表示：{(P₁,P₂), (P₁,P₃), (P₁,P₄), (P₂,P₅), (P₃,P₅), (P₄,P₆), (P₄,P₇), (P₅,P₈), (P₆,P₈), (P₇,P₉), (P₈,P₉)}

6.  **重要约束：不允许有循环 (No Cycles)**
    *   若前趋图中存在循环，则必然会产生不可能实现的前趋关系。
    *   **示例 (图2-1(b) 所示)：**
        *   S₂ → S₃ (S₃ 执行前，S₂ 必须完成)
        *   S₃ → S₂ (S₂ 执行前，S₃ 必须完成)
        *   这种循环关系导致逻辑上无法执行。
### 2.1.2 程序顺序执行
1.  **程序的顺序执行概念：**
    *   一个应用程序通常由若干程序段组成，每个程序段完成特定功能。
    *   执行时，这些程序段需要按照某种先后次序顺序执行，即当前一程序段执行完毕后，才运行后一程序段。
     ![[image-18.png]]
    *   **示例1 (作业流程，图2-2(a))：**
        *   I (输入程序)：输入用户程序和数据。
        *   C (计算程序)：对输入数据进行计算。
        *   P (打印程序)：打印计算结果。
        *   前趋关系：I → C → P。
    *   **示例2 (语句间依赖，图2-2(b))：**
        *   S₁: `a := x + y;`
        *   S₂: `b := a - 5;` (依赖 S₁ 对 a 的赋值)
        *   S₃: `c := b + 1;` (依赖 S₂ 对 b 的赋值)
        *   前趋关系：S₁ → S₂ → S₃。
2.  **程序顺序执行时的特征：**
    *   **① 顺序性 (Sequentiality)：**
        *   处理机严格按照程序所规定的顺序执行。
        *   每一操作必须在下一个操作开始之前结束。
    *   **② 封闭性 (Closed Environment)：**
        *   程序在封闭的环境下运行，即程序运行时独占全机资源。
        *   资源的状态（除初始状态外）只有本程序才能改变它。
        *   程序一旦开始执行，其执行结果不受外界因素影响。
    *   **③ 可再现性 (Reproducibility)：**
        *   只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都可获得相同的结果。
        *   这种特性为程序员检测和校正程序的错误带来了很大方便。

### 2.1.3 程序并发执行

1.  **引入原因：**
    *   程序顺序执行虽然方便程序员，但系统资源利用率低。
    *   为提高资源利用率，系统中引入多道程序技术，使程序或程序段间能并发执行。

2.  **并发执行的条件：**
    *   并非所有程序都能并发执行。
    *   只有在**不存在前趋关系**的程序之间才有可能并发执行，否则无法并发执行。

3.  **程序的并发执行示例：**
    *   **示例1 (一批作业的处理，图2-3)：**
          ![[image-19.png]]
        *   考虑多个作业的$输入(I)、计算(C)、打印(P)$过程。
        *   当第 i 个作业的计算程序 (Cᵢ) 对其数据进行计算时，第 $i+1$ 个作业的输入程序 $(Iᵢ₊₁)$ 可以同时进行数据输入。
        *   同时，第 i-1 个作业的打印程序 (Pᵢ₋₁) 可能正在打印其计算结果。
        *   **存在的前趋关系：** $Iᵢ→Cᵢ, Cᵢ→Pᵢ，以及 Iᵢ→Iᵢ₊₁, Cᵢ→Cᵢ₊₁, Pᵢ→Pᵢ₊₁$（表示同类操作在不同作业间的顺序）。
        *   **并发性：** $Iᵢ₊₁, Cᵢ, 和 Pᵢ₋₁$ 之间不存在直接的前趋关系，因此它们可以并发执行（时间上重叠）。
    *   **示例2 (语句间并发，图2-4)：**
          ![[image-20.png]]
        *   S₁: `a := x + 2`
        *   S₂: `b := y + 4`
        *   S₃: `c := a + b`
        *   S₄: `d := c + b`
        *   **分析：**
            *   S₃ 必须在 a 和 b 被赋值后（即 S₁ 和 S₂ 完成后）才能执行。
            *   S₄ 必须在 S₃ 之后执行。
            *   S₁ 和 S₂ 彼此互不依赖，因此可以并发执行。
4.  **程序并发执行时的特征：**
    *   **① 间断性 (Intermittency)：**
        *   程序在并发执行时，由于它们共享系统资源以及为完成同一任务而相互合作，形成了相互制约的关系。
        *   导致并发程序具有“执行——暂停——执行”这种间断性的活动规律。
        *   例如，图2-3中的计算程序 Cᵢ，如果输入程序 Iᵢ 尚未完成数据的输入，则 Cᵢ 必须暂停等待。
    *   **② 失去封闭性 (Loss of Closed Environment)：**
        *   当系统中存在多个可以并发执行的程序时，系统中的各种资源将为它们所共享，这些资源的状态也由这些程序来改变。
        *   任一程序在运行时，其环境都必然会受到其它程序的影响。例如，当处理机被分配给某个进程时，其它程序必须等待。
    *   **③ 不可再现性 (Non-Reproducibility)：**
        *   程序在并发执行时，由于失去了封闭性，其计算结果也将与并发程序的执行速度有关，从而使程序的执行失去了可再现性。
        *   **示例：** 两个循环程序 A 和 B 共享变量 N。
            *   A: 每次执行 `N = N + 1`
            *   B: 每次执行 `Print(N)`，然后 `N = 0`
            *   若 A 和 B 以不同速度运行，假定某时刻 N=n，可能出现的情况：
                1.  `N=N+1` (A) 在 `Print(N)` (B) 和 `N=0` (B) 之前：N 值为 n+1, n+1, 0。
                2.  `N=N+1` (A) 在 `Print(N)` (B) 和 `N=0` (B) 之后：N 值为 n, 0, 1。
                3.  `N=N+1` (A) 在 `Print(N)` (B) 之后，但在 `N=0` (B) 之前：N 值为 n, n+1, 0。
        *   **结论：** 程序经过多次执行后，虽然它们执行时的环境和初始条件相同，但得到的结果却各不相同。
        *   **重要性：** 这种不可再现性意味着通常的程序不能直接参与并发执行，否则其运行就失去了意义。为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，人们引入了“**进程 (Process)**”的概念。

