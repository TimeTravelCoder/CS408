

一般而言，大部分的 I/O 软件都放在操作系统内部，但仍有一小部分在用户层，其中包括与用户程序链接在一起的库函数，以及完全运行于内核之外的假脱机系统等。

**6.6.1 系统调用与库函数**

1.  **系统调用 (System Call)**
    *   **目的/原因**：
        *   一方面，为使诸进程能有条不紊地使用 I/O 设备，且能保护设备的安全性，不允许运行在用户态的应用进程去直接调用运行在核心态(系统态)的 OS 过程。
        *   但另一方面，应用进程在运行时，又必须取得 OS 所提供的服务，否则，应用程序几乎无法运行。
    *   **解决方案**：为了解决此矛盾，OS 在用户层中引入了一个中介过程——系统调用，应用程序可以通过它间接调用 OS 中的 I/O 过程，对 I/O 设备进行操作。
    *   **执行过程**：
        *   系统中会有许多系统调用，它们的实现方法是基本相同的。
        *   当应用程序需要执行某种 I/O 操作时，在应用程序中必须使用相应的系统调用。
        *   当 OS 捕获到应用程序中的该系统调用后，便将 CPU 的状态从用户态转换到核心态，然后转向操作系统中相应过程，由该过程完成所需的 I/O 操作。
        *   执行完成后，系统又将 CPU 状态从核心态转换到用户态，返回到应用程序继续执行。
        * ![[Pasted image 20250531142551.png]]
        *   *(图 6-20 系统调用的执行过程示意图：用户态的用户程序发出系统调用命令 -> 切换到内核态 -> 执行内核中的系统调用处理程序 -> 处理完成后返回 -> 切换回用户态 -> 用户程序继续执行。)*
    *   **本质**：事实上，由 OS 向用户提供的所有功能，用户进程都必须通过系统调用来获取，或者说，系统调用是应用程序取得 OS 所有服务的唯一途径。
    *   **早期形式**：在早期的操作中，系统调用是以汇编语言形式提供的，所以只有在用汇编语言编写的程序中，才能直接使用系统调用，这对用户是非常不方便的。
    *   **后来发展**：后来在 C 语言中，首先提供了与系统调用相对应的库函数。

2.  **库函数 (Library Function)**
    *   在 C 语言以及 UNIX 系统中，系统调用 (如 `read`) 与各系统调用所使用的库函数 (如 `read`) 之间几乎是一一对应的。
    *   而微软定义了一套过程，称为 Win32 API 的应用程序接口 (Application Program Interface)，程序员利用它们取得 OS 服务，该接口与实际的系统调用并不一一对应。
    *   用户程序通过调用对应的库函数使用系统调用，这些库函数与调用程序链接在一起，被嵌入在运行时装入内存的二进制程序中。
    *   在 C 语言中提供了多种类型的库函数，对于 I/O 方面，主要是对文件和设备进行读/写的库函数，以及控制/检查设备状态的库函数。显然这些库函数的集合也应是 I/O 系统的组成部分。
    *   而且我们可以这样来看待内核和库函数之间的关系：内核提供了 OS 的基本功能，而库函数扩展了 OS 内核，使用户能方便取得操作系统的服务。
    *   在许多现代 OS 中，系统调用本身已经采用 C 语言编写，并以函数形式提供，所以在使用 C 语言编写的用户程序中，可以直接使用这些系统调用。
    *   另外，操作系统在用户层中还提供了一些非常有用的程序，如下面将要介绍的假脱机系统，以及在网络传输文件时常使用的守护进程等，它们是运行在内核之外的程序，但它们仍属于 I/O 系统。

**6.6.2 假脱机 (Spooling) 系统**

*   **类比**：如果说，通过多道程序技术可将一台物理 CPU 虚拟为多台逻辑 CPU，从而允许多个用户共享一台主机；那么，通过假脱机技术，则可将一台物理 I/O 设备虚拟为多台逻辑 I/O 设备，这样也就允许多个用户共享一台物理 I/O 设备。

1.  **假脱机技术**
    *   在 20 世纪 50 年代，为了缓和 CPU 的高速性与 I/O 设备低速性间的矛盾，而引入了脱机输入、脱机输出技术。该技术是利用专门的外围控制机，先将低速 I/O 设备上的数据传送到高速磁盘上，或者相反。这样当处理机需要输入数据时，便可以直接从磁盘中读取数据，极大地提高了输入速度。反之，在处理机需要输出数据时，也可以很快的速度把数据先输出到磁盘上，处理机便可去做自己的事情。
    *   事实上，当系统中引入了多道程序技术后，完全可以利用其中的一道程序，来模拟脱机输入时的外围控制机功能，把低速 I/O 设备上的数据传送到高速磁盘上。再用另一道程序模拟脱机输出时外围控制机的功能，把数据从磁盘传送到低速输出设备上。这样，便可在主机的直接控制下，实现以前的脱机输入、输出功能。此时的外围操作与 CPU 对数据的处理同时进行，我们把这种在联机情况下实现的同时外围操作的技术称为 SPOOLing (Simultaneous Peripheral Operating OnLine) 技术，或称为假脱机技术。

2.  **SPOOLing 的组成**
    *   如前所述，SPOOLing 技术是对脱机输入/输出系统的模拟，相应地，如图 6-21(a) 所示，SPOOLing 系统建立在通道技术和多道程序技术的基础上，以高速随机外存(通常为磁盘)为后援存储器。SPOOLing 的工作原理如图 6-21(b) 所示。
    * ![[Pasted image 20250531142631.png]]
    *   *(图 6-21(a) SPOOLing 系统的组成示意图：输入设备 -> 输入井 -> 输入进程 -> 主机 -> 输出进程 -> 输出井 -> 输出设备，其中井位于磁盘上，通过通道与主机交互。)*
    * ![[Pasted image 20250531142810.png]]
    *   
    * *(图 6-21(b) SPOOLing 的工作原理示意图：输入设备的数据进入输入缓冲区1，然后由输入进程写入磁盘上的作业输入井；主机处理后，输出数据由输出进程从磁盘上的作业输出井读入输出缓冲区2，再送到输出设备。井管理程序负责协调作业与井之间的数据交换。)*
    *   SPOOLing 系统主要由以下四部分构成：
        *   **(1) 输入井和输出井。** 这是在磁盘上开辟出来的两个存储区域。输入井模拟脱机输入时的磁盘，用于收容 I/O 设备输入的数据。输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据。输入/输出井中的数据一般以文件的形式组织管理，我们把这些文件称为井文件。一个文件仅存放某一个进程的输入(或者输出)数据，所有进程的数据输入(或输出)文件链接成为一个输入(或输出)队列。
        *   **(2) 输入缓冲区和输出缓冲区。** 这是在内存中开辟的两个缓冲区，用于缓和 CPU 和磁盘之间速度不匹配的矛盾。输入缓冲区用于暂存由输入设备传送的数据，之后再传送到输入井。输出缓冲区用于暂存从输出井传送的数据，之后再传送到输出设备。
        *   **(3) 输入进程和输出进程。**
            *   **输入进程**也称为预输入进程，用于模拟脱机输入时的外围控制机，将用户要求的数据从输入设备传送到输入缓冲区，再存放到输入井。当 CPU 需要输入设备时，直接从输入井读入内存。
            *   **输出进程**也称为缓输出进程，用于模拟脱机输出时的外围控制机，把用户要求输入的数据从内存传送并存放到输出井，待输出设备空闲时，再将输出井中的数据经过输出缓冲区输出至输出设备上。
        *   **(4) 井管理程序。** 用于控制作业与磁盘井之间信息的交换。当作业执行过程中向某台设备发出启动输入或输出操作请求时，由操作系统调用井管理程序，由其控制从输入井读取信息或将信息输出至输出井。

3.  **SPOOLing 系统的特点**
    *   **(1) 提高了 I/O 的速度。** 这里，对数据所执行的 I/O 操作，已从对低速 I/O 设备执行的 I/O 操作演变为对磁盘缓冲区中数据的存取，如同脱机输入输出一样，提高了 I/O 速度，缓和了 CPU 与低速 I/O 设备之间速度不匹配的矛盾。
    *   **(2) 将独占设备改造为共享设备。** 因为在假脱机打印机系统中，实际上并没为任何进程分配设备，而只是在磁盘缓冲区中为进程分配一个空闲盘块和建立一张 I/O 请求表。这样，便把独占设备改造为共享设备。
    *   **(3) 实现了虚拟设备功能。** 宏观上，虽然是多个进程在同时使用一台独占设备，而对于每一个进程而言，它们都会认为自己是独占了一个设备。当然，该设备只是逻辑上的设备。假脱机打印机系统实现了将独占设备变换为若干台对应的逻辑设备的功能。

4.  **假脱机打印机系统**
    *   打印机是经常用到的输出设备，属于独占设备。利用假脱机技术可将它改造为一台可供多个用户共享的打印设备，从而提高设备的利用率，也方便了用户。共享打印机技术已被广泛地用于多用户系统和局域网络中。假脱机打印系统主要有以下三部分：
        *   **(1) 磁盘缓冲区。** 它是在磁盘上开辟的一个存储空间，用于暂存用户程序的输出数据，在该缓冲区中可以设置几个盘块队列，如空盘块队列、满盘块队列等。
        *   **(2) 打印缓冲区。** 用于缓和 CPU 和磁盘之间速度不匹配的矛盾，设置在内存中，暂存从磁盘缓冲区送来的数据，以后再传送给打印设备进行打印。
        *   **(3) 假脱机管理进程和假脱机打印进程。** 由假脱机管理进程为每个要求打印的用户数据建立一个假脱机文件，并把它放入假脱机文件队列中，由假脱机打印进程依次对队列中的文件进行打印。
	* ![[Pasted image 20250531142945.png]]
    *   *(图 6-21(c) 假脱机打印机系统的组成示意图：多个用户程序通过共享打印机（逻辑设备）将打印任务提交给假脱机管理进程，数据暂存在磁盘上的假脱机文件队列和打印缓冲区中，最终由假脱机打印进程控制物理打印机输出。包含空盘块队列和满盘块队列管理磁盘空间。)*

5.  **守护进程 (daemon)**
    *   前面是利用假脱机系统来实现打印机共享的一种方案，人们对该方案进行了某些修改，如取消该方案中的假脱机管理进程，为打印机建立一个守护进程，由它执行一部分原来由假脱机管理进程实现的功能，如为用户在磁盘缓冲区中申请一个空闲盘块，并将要打印的数据送入其中，将该盘块的首址返回给请求进程。
    *   另一部分由请求进程自己完成，每个要求打印的进程首先生成一份要求打印的文件，其中包含对打印的要求和指向装有打印输出数据盘块的指针等信息，然后将用户请求打印文件放入假脱机文件队列(目录)中。
    *   守护进程是允许使用打印机的唯一进程。所有需要使用打印机进行打印的进程都需将一份要求打印的文件放在假脱机文件队列(目录)中。如果守护进程正在睡眠，便将它唤醒，由它按照目录中第一个文件中的说明进行打印，打印完成后，再按照目录中第二个文件中的说明进行打印，如此逐份文件地进行打印，直到目录中的全部文件打印完毕，守护进程无事可做，又去睡眠。等待用户进程再次发来打印请求。
    *   除了打印机守护进程之外，还可能有许多其它的守护进程，如服务器守护进程和网络守护进程等。事实上，凡是需要将独占设备改造为可供多个进程共享的设备时，都要为该设备配置一个守护进程和一个假脱机文件队列(目录)。同样，守护进程是允许使用该独占设备的唯一进程，所有其它进程都不能直接使用该设备，只能将对该设备的使用要求写入一份文件中，放在假脱机目录中。由守护进程按照目录中的文件依次来完成诸进程对该设备的请求，这样就把一台独占设备改造为可为多个进程共享的设备。

---