

在现代操作系统中，几乎所有的 I/O 设备在与处理机交换数据时都用了缓冲区。缓冲区是一个存储区域，它可以由专门的硬件寄存器组成，但由于硬件的成本较高，容量也较小，一般仅用在对速度要求非常高的场合，如存储器管理中所用的联想存储器；设备控制器中用的数据缓冲区等。在一般情况下，更多的是利用内存作为缓冲区。本节所要介绍的也正是由内存组成的缓冲区。缓冲区管理的主要功能是组织好这些缓冲区，并提供获得和释放缓冲区的手段。

**6.7.1 缓冲的引入**

引入缓冲区的原因有很多，可归结为以下几点：

1.  **缓和 CPU 与 I/O 设备间速度不匹配的矛盾。**
    *   事实上，凡在数据到达速率与其离去速率不同的地方，都可设置缓冲区，以缓和它们之间速率不匹配的矛盾。
    *   众所周知，CPU 的运算速率远远高于 I/O 设备的速率，如果没有缓冲区，在输出数据时，必然会由于打印机的速度跟不上，而使 CPU 停下来等待；然而在计算阶段，打印机又空闲无事。
    *   如果在打印机或控制器中设置一缓冲区，用于快速暂存程序的输出数据，以后由打印机“慢慢地”从中取出数据打印，这样，就可提高 CPU 的工作效率。
    *   类似地，在输入设备与 CPU 之间设置缓冲区，也可使 CPU 的工作效率得以提高。

2.  **减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制。**
    *   在远程通信系统中，如果从远地终端发来的数据仅用一位缓冲来接收，如图 6-22(a) 所示，则必须在每收到一位数据时便中断一次 CPU。这样，对于速率为 9.6 kb/s 的数据通信来说，就意味着其中断 CPU 的频率也为 9.6 kb/s，即每 100 µs 就要中断 CPU 一次，而且 CPU 必须在 100 µs 内予以响应，否则缓冲区内的数据将被冲掉。
    *   倘若设置一个具有 8 位的缓冲(移位)寄存器，如图 6-22(b) 所示，则可使 CPU 被中断的频率降低为原来的 1/8；若再设置一个 8 位寄存器，如图 6-22(c) 所示，则又可把 CPU 对中断的响应时间从 100 µs 放宽到 800 µs。
    *   类似地，在磁盘控制器和磁带控制器中，都需要配置缓冲寄存器，以减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制。随着传输速率的提高，需要配置位数更多的寄存器进行缓冲。
    * ![[Pasted image 20250531143037.png]]
	    *   *(图 6-22 利用缓冲寄存器实现缓冲示意图：(a) 1 位缓冲；(b) 8 位缓冲寄存器，数据满后送内存；(c) 两个 8 位缓冲寄存器，一个接收数据，一个向内存传送数据，交替工作。)*

3.  **解决数据粒度不匹配的问题。**
    *   缓冲区可用于解决在生产者和消费者之间交换的数据粒度(数据单元大小)不匹配的问题。
    *   例如，生产者所生产的数据粒度比消费者消费的数据粒度小时，生产者进程可以一连生产好几个数据单元的数据，当其总和已达到消费者进程所要求的数据单元大小时，消费者便可从缓冲区中取出消费。
    *   反之，如果生产者所生产的数据粒度比消费者消费的数据粒度大时，生产者每次生产的数据消费者可以分几次从缓冲区中取出消费。

4.  **提高 CPU 和 I/O 设备之间的并行性。**
    *   缓冲区的引入可显著地提高 CPU 和 I/O 设备间的并行操作程度，提高系统的吞吐量和设备的利用率。
    *   例如，在 CPU (生产者)和打印机(消费者)之间设置了缓冲区后，生产者在生产了一批数据并将它放入缓冲区后，便可立即去进行下一次的生产。与此同时，消费者可以从缓冲区中取出数据消费，这样便可使 CPU 与打印机处于并行工作状态。

**6.7.2 单缓冲区和双缓冲区**

如果在生产者与消费者之间未设置任何缓冲，生产者与消费者之间在时间上会相互限制。例如，生产者已经完成了数据的生产，但消费者尚未准备好接收，生产者无法把所生产的数据交付给消费者，此时生产者必须暂停等待，直到消费者就绪。如果在生产者与消费者之间设置了一个缓冲区，则生产者无需等待消费者就绪，便可把数据输出到缓冲区。

1.  **单缓冲区 (Single Buffer)**
    *   在单缓冲情况下，每当用户进程发出一 I/O 请求时，操作系统便在主存中为之分配一缓冲区，如图 6-23 所示。
    
	* ![[Pasted image 20250531143110.png]]
		* *   *(图 6-23 单缓冲工作示意图：(a) 逻辑框图：用户进程的处理(C)和工作区，与缓冲区的传送(M)，以及I/O设备的输入(T)到缓冲区的关系；(b) 时序图：展示了多块数据处理时，T、M、C 的时间关系，下一块的 T 可以与上一块的 C 部分重叠。)*
    *   在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为 T，OS 将该缓冲区中的数据传送到用户区的时间为 M，而 CPU 对这一块数据处理(计算)的时间为 C。
    *   由于 T 和 C 是可以并行的 (见图 6-23)，当 T > C 时，系统对每一块数据的处理时间为 M+T；反之则为 M+C，故可把系统对每一块数据的处理时间表示为 Max(C, T) + M。
    
    *   在字符设备输入时，缓冲区用于暂存用户输入的一行数据，在输入期间，用户进程被挂起以等待数据输入完毕；在输出时，用户进程将一行数据输入到缓冲区后继续进行处理。当用户进程已有第二行数据输出时，如果第一行数据尚未被提取完毕，则此时用户进程应阻塞。

2.  **双缓冲区 (Double Buffer)**
    *   由于缓冲区是共享资源，生产者与消费者在使用缓冲区时必须互斥。如果消费者尚未取走缓冲区中的数据，即使生产者又生产出新的数据，也无法将它送入缓冲区，生产者等待。如果为生产者与消费者设置了两个缓冲区，便能解决这一问题。
    *   为了加快输入和输出速度，提高设备利用率，人们又引入了双缓冲区机制，也称为缓冲对换 (Buffer Swapping)。
    *   在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。此时操作系统可以从第一缓冲区中移出数据，并送入用户进程 (见图 6-24)。接着由 CPU 对数据进行计算。
    *   在双缓冲时，系统处理一块数据的时间可以粗略地认为是 Max(C, T)。如果 C < T，可使块设备连续输入；如果 C > T，则可使 CPU 不必等待设备输入。
    *   对于字符设备，若采用行输入方式，则采用双缓冲通常能消除用户的等待时间，即用户在输入完第一行后，在 CPU 执行第一行中的命令时，用户可继续向第二缓冲区输入下一行数据。
    * ![[Pasted image 20250531143239.png]]
	    *   *(图 6-24 双缓冲工作示意图：(a) 逻辑框图：用户进程工作区，与两个缓冲区（缓冲区1，缓冲区2）以及I/O设备之间的关系，缓冲区交替工作；(b) 时序图：展示了多块数据处理时，T、M、C 的时间关系，可以实现更优的并行度，例如一块数据在缓冲区1进行T操作时，另一块数据可以在缓冲区2进行M操作，同时CPU进行C操作。)*
    *   如果在实现两台机器之间的通信时仅为它们配置了单缓冲，如图 6-25(a) 所示，那么，它们之间在任一时刻都只能实现单方向的数据传输。例如，只允许把数据从 A 传送到 B，或者从 B 传送到 A，而绝不允许双方同时向对方发送数据。为了实现双向数据传输，必须在两台机器中都设置两个缓冲区，一个用作发送缓冲区，另一个用作接收缓冲区，如图 6-25(b) 所示。
    * ![[Pasted image 20250531143250.png]]
	    *   *(图 6-25 双机通信时缓冲区的设置示意图：(a) 单缓冲：A机和B机各有一个缓冲区，只能单向通信；(b) 双缓冲：A机和B机各有发送缓冲区和接收缓冲区，可以实现双向通信。)*

**6.7.3 环形缓冲区**

*   当输入与输出的速度基本相匹配时，采用双缓冲能获得较好的效果，可使生产者和消费者基本上能并行操作。但若两者的速度相差甚远，双缓冲的效果则不够理想，不过可以随着缓冲区数量的增加，使情况有所改善。因此，又引入了多缓冲机制，可将多个缓冲区组织成环形缓冲区形式。

1.  **环形缓冲区的组成**
    *   **(1) 多个缓冲区。** 在环形缓冲中包括多个缓冲区，其每个缓冲区的大小相同。作为输入的多缓冲区可分为三种类型：用于装输入数据的空缓冲区 R、已装满数据的缓冲区 G 以及计算进程正在使用的现行工作缓冲区 C，如图 6-26 所示。
    *   **(2) 多个指针。** 作为输入的缓冲区可设置三个指针：用于指示计算进程下一个可用缓冲区 G 的指针 Nextg、指示输入进程下次可用的空缓冲区 R 的指针 Nexti，以及用于指示计算进程正在使用的缓冲区 C 的指针 Current。
    * ![[Pasted image 20250531143307.png]]
	    *   *(图 6-26 环形缓冲区示意图：展示了多个缓冲区（R表示空闲，G表示已满，C表示当前使用）以及 Nexti, Nextg, Current 三个指针在环形结构中的移动。)*

2.  **环形缓冲区的使用**
    计算进程和输入进程可利用下述两个过程来使用环形缓冲区。
    *   **(1) Getbuf 过程。** 当计算进程要使用缓冲区中的数据时，可调用 Getbuf 过程。该过程将由指针 Nextg 所指示的缓冲区提供给进程使用，相应地，须把它改为现行工作缓冲区，并令 Current 指针指向该缓冲区的第一个单元，同时将 Nextg 移向下一个 G 缓冲区。类似地，每当输入进程要使用空缓冲区来装入数据时，也调用 Getbuf 过程，由该过程将指针 Nexti 所指示的缓冲区提供给输入进程使用，同时将 Nexti 指针移向下一个 R 缓冲区。
    *   **(2) Releasebuf 过程。** 当计算进程把 C 缓冲区中的数据提取完毕时，便调用 Releasebuf 过程，将缓冲区 C 释放。此时，把该缓冲区由当前(现行)工作缓冲区 C 改为空缓冲区 R。类似地，当输入进程把缓冲区装满时，也应调用 Releasebuf 过程，将该缓冲区释放，并改为 G 缓冲区。

3.  **进程之间的同步问题**
    使用输入循环缓冲，可使输入进程和计算进程并行执行。相应地，指针 Nexti 和指针 Nextg 将不断地沿着顺时针方向移动，这样就可能出现下述两种情况：
    *   **(1) Nexti 指针追赶上 Nextg 指针。** 这意味着输入进程输入数据的速度大于计算进程处理数据的速度，已把全部可用的空缓冲区装满，再无缓冲区可用。此时，输入进程应阻塞，直到计算进程把某个缓冲区中的数据全部提取完，使之成为空缓冲区 R，并调用 Releasebuf 过程将它释放时，才将输入进程唤醒。这种情况被称为系统受计算限制。
    *   **(2) Nextg 指针追赶上 Nexti 指针。** 这意味着输入数据的速度低于计算进程处理数据的速度，使全部装有输入数据的缓冲区都被抽空，再无装有数据的缓冲区供计算进程提取数据。这时，计算进程只能阻塞，直至输入进程又装满某个缓冲区，并调用 Releasebuf 过程将它释放时，才去唤醒计算进程。这种情况被称为系统受 I/O 限制。

**6.7.4 缓冲池 (Buffer Pool)**

*   上述的缓冲区是专门为特定的生产者和消费者设置的，它们属于专用缓冲。当系统较大时，应该有许多这样的循环缓冲，这不仅要消耗大量的内存空间，而且其利用率不高。
*   为了提高缓冲区的利用率，目前广泛流行既可用于输入又可用于输出的公用缓冲池，在池中设置了多个可供若干个进程共享的缓冲区。
*   缓冲池与缓冲区的区别在于：缓冲区仅仅是一组内存块的链表，而缓冲池则是包含了一个管理的数据结构及一组操作函数的管理机制，用于管理多个缓冲区。

1.  **缓冲池的组成**
    缓冲池管理着多个缓冲区，每个缓冲区由用于标识和管理的缓冲首部以及用于存放数据的缓冲体两部分组成。缓冲首部一般包括缓冲区号、设备号、设备上的数据块号、同步信号量以及队列链接指针等。为了管理上的方便，一般将缓冲池中具有相同类型的缓冲区链接成一个队列，于是可形成以下三个队列：
    *   **(1) 空白缓冲队列 emq (empty queue)。** 这是由空缓冲区所链成的队列。其队首指针 F(emq) 和队尾指针 L(emq) 分别指向该队列的首缓冲区和尾缓冲区。
    *   **(2) 输入队列 inq (input queue)。** 这是由装满输入数据的缓冲区所链成的队列。其队首指针 F(inq) 和队尾指针 L(inq) 分别指向输入队列的队首和队尾缓冲区。
    *   **(3) 输出队列 outq (output queue)。** 这是由装满输出数据的缓冲区所链成的队列。其队首指针 F(outq) 和队尾指针 L(outq) 分别指向该队列的首、尾缓冲区。
    除了上述三个队列外，还应具有四种工作缓冲区：用于收容输入数据的工作缓冲区 hin、用于提取输入数据的工作缓冲区 sin、用于收容输出数据的工作缓冲区 hout，以及用于提取输出数据的工作缓冲区 sout。

2.  **Getbuf 过程和 Putbuf 过程**
    在数据结构课程中，曾介绍过队列和对队列进行操作的两个过程，第一个是 `Addbuf(type, number)` 过程。该过程用于将由参数 `number` 所指示的缓冲区 B 挂在 `type` 队列上。第二个是 `Takebuf(type)` 过程。它用于从 `type` 所指示的队列的队首摘下一个缓冲区。
    这两个过程能否用于对缓冲池中的队列进行操作呢？答案是否定的。因为缓冲池中的队列本身是临界资源，多个进程在访问一个队列时，既应互斥，又须同步。为此，需要对这两个过程加以改造，以形成可用于对缓冲池中的队列进行操作的 Getbuf 和 Putbuf 过程。
    为使诸进程能互斥地访问缓冲池队列，可为每一队列设置一个互斥信号量 MS(type)。此外，为了保证诸进程同步地使用缓冲区，又为每个缓冲队列设置了一个资源信号量 RS(type)。既可实现互斥又可保证同步的 Getbuf 过程和 Putbuf 过程描述如下：
    ```
    void Getbuf(unsigned type)
    {
        Wait(RS(type));  // 请求一个type类型的缓冲区资源
        Wait(MS(type));  // 请求进入临界区
        B(number) = Takebuf(type); // 从队列中取出一个缓冲区
        Signal(MS(type)); // 退出临界区
    }

    void Putbuf(unsigned type, unsigned number) // number 指示要放入的缓冲区
    {
        Wait(MS(type));  // 请求进入临界区
        Addbuf(type, number); // 将缓冲区number加入到type队列
        Signal(MS(type)); // 退出临界区
        Signal(RS(type)); // 释放一个type类型的缓冲区资源
    }
    ```
    *注意：上述 Putbuf 过程的参数 `number` 应该表示要放入缓冲池队列的那个缓冲区的标识。 `B(number)` 在 Getbuf 中应理解为获取到的缓冲区的标识。*

3.  **缓冲区的工作方式**
    缓冲区可以工作在如下四种工作方式，如图 6-27 所示。
    ![[Pasted image 20250531143339.png]]
	    *(图 6-27 缓冲区的工作方式示意图：展示了缓冲池、收容输入工作区(hin)、提取输入工作区(sin)、收容输出工作区(hout)、提取输出工作区(sout)以及用户程序之间的交互关系。)*
    *   **(1) 收容输入。** 输入进程可调用 `Getbuf(emq)` 过程，从空缓冲队列 emq 的队首摘下一空缓冲区，把它作为收容输入工作缓冲区 hin。然后，把数据输入其中，装满后再调用 `Putbuf(inq, hin)` 过程，将它挂在输入队列 inq 队列上。
    *   **(2) 提取输入。** 计算进程可调用 `Getbuf(inq)` 过程，从输入队列 inq 的队首取得一缓冲区，作为提取输入工作缓冲区(sin)，计算进程从中提取数据。计算进程用完该数据后，再调用 `Putbuf(emq, sin)` 过程，将它挂到空缓冲队列 emq 上。
    *   **(3) 收容输出。** 计算进程可调用 `Getbuf(emq)`，从空缓冲队列 emq 的队首取得一空缓冲，作为收容输出工作缓冲区 hout。当其中装满输出数据后，又调用 `Putbuf(outq, hout)` 过程，将它挂在 outq 末尾。
    *   **(4) 提取输出。** 输出进程可调用 `Getbuf(outq)` 过程，从输出队列的队首取得一装满输出数据的缓冲区，作为提取输出工作缓冲区 sout。在数据提取完后，再调用 `Putbuf(emq, sout)` 过程，将它挂在空缓冲队列末尾。

---