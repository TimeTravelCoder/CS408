

为了方便用户和提高 OS 的可适应性与可扩展性，在现代 OS 的 I/O 系统中，都无一例外地增加了与设备无关的 I/O 软件，以实现设备独立性，也称为设备无关性。其基本含义是：应用程序中所用的设备，不局限于使用某个具体的物理设备。为每个设备所配置的设备驱动程序是与硬件紧密相关的软件。为了实现设备独立性，必须再在设备驱动程序之上设置一层软件，称为与设备无关的 I/O 软件，或设备独立性软件。
**6.5.1 与设备无关 (Device Independence) 软件的基本概念**
1.  **以物理设备名使用设备**
    *   在早期 OS 中，应用程序在使用 I/O 设备时，都使用设备的物理名称，这使应用程序与系统中的物理设备直接相关。
    *   当应用进程运行时，如果所请求的物理设备(独占设备类型)已分配给其它进程，而此时尽管还有几台其它的相同设备空闲可用，但系统只能根据设备的物理名来分配，无法将另外相同的设备(但具有不同的物理设备名)分配给它，致使该应用进程请求 I/O 失败而被阻塞。
    *   特别是，当应用程序所需要的设备在系统中已经被更新时，该应用程序将再也无法在该系统上运行。
    *   可见，应用程序直接与物理设备相关是非常不灵活的，给用户带来了很大的不便，且对提高 I/O 设备的利用率也很不利。
2.  **引入了逻辑设备名**
    *   为了实现与设备的无关性而引入了逻辑设备和物理设备两个概念。逻辑设备是抽象的设备名。如 `/dev/printer`，该设备名只是说明用户需要使用打印机来打印输出，但并没有指定具体是哪一台打印机。
    *   这样，如果在应用程序中，使用逻辑设备名称请求使用某类设备，系统在对它进行设备分配时，先查找该类设备中的第一台，如它已被分配，系统可立即去查找该类设备中第二台，若又被分配，系统接着去找第三台，若它尚未分配，便可将这台设备分配给进程。
    *   事实上，只要系统中有一台该类设备未被分配，进程就不会被阻塞。仅当所请求的此类设备已全部分配完毕时，进程才会因请求失败而阻塞。所以，应用进程就不会由于某台指定设备退役而无法在本系统上运行。
    *   与设备的无关软件还可实现 I/O 重定向。所谓 I/O 重定向，是指用于 I/O 操作的设备可以更换(即重定向)，而不必改变应用程序。例如，我们在调试一个应用程序时，可将程序的所有输出送往屏幕显示。而在程序调试完后，若须正式将程序的运行结果打印出来，此时便须将 I/O 重定向的数据结构——逻辑设备表中的显示终端改为打印机即可，而不必修改应用程序。I/O 重定向功能具有很大的实用价值，现已被广泛地引入到各类 OS 中。
3.  **逻辑设备名称到物理设备名称的转换**
    *   在应用程序中，用逻辑设备名称使用设备虽然方便了用户，但系统却只识别物理设备名称，因此在实际执行时，还必须使用物理名称。
    *   为此，在系统中，必须具有将逻辑设备名称转换为某物理设备名称的功能。
    *   关于逻辑设备名称和物理设备名称的概念，与存储器管理中所介绍的逻辑地址和物理地址的概念非常类似，在应用程序中所使用的是逻辑地址，而系统在分配和使用内存时，必须使用物理地址。在程序执行时，必须先将逻辑地址转换为物理地址。
    *   类似地，为实现从逻辑设备名称和物理设备名称，在系统中需要配置一张逻辑设备表。转换的详细情况将在后面介绍。
---
**6.5.2 与设备无关的软件**

与设备无关的软件是 I/O 系统的最高层软件，在它下面的是设备驱动程序，其间的界限，因操作系统和设备的不同而有所差异。比如，对于一些本应由设备独立性软件实现的功能，却放在设备驱动程序中实现。这样的差异主要是出于对操作系统、设备独立性和设备驱动程序运行效率等多方面因素的权衡和考虑。总的来说，在与设备无关的软件中，包括了执行所有设备公有操作的软件，具体有如下几项。

1.  **设备驱动程序的统一接口**
    *   为了使所有的设备驱动程序有着统一的接口，一方面，要求每个设备驱动程序与 OS 之间都有着相同的接口，或者相近的接口，这样会使添加一个新的设备驱动程序变得很容易，同时在很大程度上方便了开发人员对设备驱动程序的编制。
    *   另一方面，要将抽象的设备名映射到适当的驱动程序上，或者说，将抽象的设备名转换为具体的物理设备名，并进一步可以找到相应物理设备的驱动程序入口。
    *   此外，还应对设备进行保护，禁止用户直接访问设备，以防止无权访问的用户使用。
2.  **缓冲管理**
    *   无论是字符设备还是块设备，它们的运行速度都远低于 CPU 的速度。为了缓和 CPU 和 I/O 设备之间的矛盾、提高 CPU 的利用率，在现代 OS 中都无一例外地分别为字符设备和块设备配置了相应的缓冲区。
    *   缓冲区有着多种形式，如单缓冲区、双缓冲区、循环缓冲区、公用缓冲池等，以满足不同情况的需要。由于这部分的内容较多，故我们将它作为独立的一节，在 6.7 节中对它进行详细介绍。
3.  **差错控制**
    *   由于设备中有着许多的机械和电气部分，因此，它们比主机更容易出现故障，这就导致 I/O 操作中的绝大多数错误都与设备有关。错误可分为如下两类：
        *   **(1) 暂时性错误。** 暂时性错误是因发生暂时性事件引起的，如电源的波动。它可以通过重试操作来纠正。例如，在网络传输中，由于传输路途较远、缓冲区数量暂时不足等因素，会经常发生在网络中传输的数据包丢失或延误性的暂时性错误。当网络传输软件检测到这种情况后，可以通过重新传送来纠正错误。又如，当磁盘传送发生错误后，开始驱动程序并不立即认为传送出错，而是令磁盘重传，只有连续多次(如 10 次)出错，才认为磁盘出错，并向上层报告。一般地，设备出现故障后，主要由设备驱动程序处理，而设备独立性软件只处理那些设备驱动程序无法处理的错误。
        *   **(2) 持久性错误。** 持久性错误是由持久性故障引起的，如电源掉电、磁盘上有一条划痕或者在计算中发生除以零的情况等。持久性错误容易发现，有些错误是只要重复执行相同的程序就会再现的错误。要排除持久性错误，通常需要查清发生错误的原因。但也有某些持久性硬件错误可由操作系统进行有效的处理，而不用涉及高层软件。如磁盘上的少数盘块遭到破坏而失效，此时无需更换磁盘，而只需将它们作为坏的盘块记录下来，并放入一张坏盘块表中，以后不再使用这些坏块即可。
4.  **对独立设备的分配与回收**
    *   在系统中有两类设备：独占设备和共享设备。
    *   对于独占设备，为了避免诸进程对独占设备的争夺，必须由系统来统一分配，不允许进程自行使用。
    *   每当进程需要使用某(独占)设备时，必须先提出申请。OS 接到对设备的请求后，先对进程所请求的独占设备进行检查，看该设备是否空闲。若空闲，才把该设备分配给请求进程。否则，进程将被阻塞，放入该设备的请求队列中等待。等到其它进程释放该设备时，再将队列中的第一个进程唤醒，该进程得到设备后继续运行。
5.  **独立于设备的逻辑数据块**
    *   不同类型的设备，其数据交换单位是不同的，读取和传输速率也各不相同，如字符型设备以单个字符(字)为单位，块设备是以一个数据块为单位。
    *   即使同一类型的设备，其数据交换单位的大小也是有差异的，如不同磁盘由于扇区大小的不同，可能造成数据块大小的不一致。
    *   设备独立性软件应能够隐藏这些差异而被逻辑设备使用，并向高层软件提供大小统一的逻辑数据块。
    * ![[Pasted image 20250531142110.png]]
    *   *(图 6-16 与设备无关软件的功能层次示意图：展示了从上到下依次为：设备驱动程序的统一接口、缓冲、错误报告、分配与释放专用设备、提供与设备无关的块大小。)*
---
**6.5.3 设备分配**

系统为实现对独占设备的分配，必须在系统中配置相应的数据结构。

1.  **设备分配中的数据结构**
    在用于设备分配的数据结构中，记录了对设备或控制器进行控制所需的信息。在进行设备分配时需要如下的数据结构。

    1)  **设备控制表 DCT (Device Control Table)**
        系统为每一个设备都配置了一张设备控制表，用于记录设备的情况，如图 6-17 所示。
	        ![[Pasted image 20250531142153.png]]
        *(图 6-17 设备控制表示意图：包含字段：设备类型 (type)，设备标识符 (deviceid)，设备状态 (等待/不等待，忙/闲)，指向控制器表的指针，重复执行次数或时间，设备队列的队首指针。)*
        设备控制表中，除了有用于指示设备类型的字段 `type` 和设备标识字段 `deviceid` 外，还应含有下列字段：
        *   (1) **设备队列队首指针**：凡因请求本设备而未得到满足的进程，应将其 PCB 按照一定的策略排成一个设备请求队列，其队首指针指向队首 PCB。
        *   (2) **忙/闲标志**：用于表示当前设备的状态是忙或闲。
        *   (3) **与设备连接的控制器表指针**：该指针指向该设备所连接的控制器的控制表。
        *   (4) **重复执行次数**：由于外部设备在传送数据时较易发生数据传送错误，因而在许多系统中规定了设备在工作中发生错误时应重复执行的次数，在重复执行时，若能恢复正常传送，则仍认为传送成功，仅当重复执行次数达到规定值仍不成功时，才认为传送失败。
    2)  **控制器控制表、通道控制表和系统设备表**
        *   **(1) 控制器控制表 COCT (Controller Control Table)。** 系统为每一个控制器都设置了用于记录控制器情况的控制表，如图 6-18(a) 所示。
        * ![[Pasted image 20250531142302.png]]
            *(图 6-18(a) 控制器控制表示意图：包含字段：控制器标识符 (controllerid)，控制器状态 (忙/闲)，与控制器连接的通道表指针，控制器队列的队首指针，控制器队列的队尾指针。)*
        *   **(2) 通道控制表 CHCT (Channel Control Table)。** 每个通道都有一张通道控制表，如图 6-18(b) 所示。
        * 
            *(图 6-18(b) 通道控制表示意图：包含字段：通道标识符 (channelid)，通道状态 (忙/闲)，与通道连接的控制器表首址，通道队列的队首指针，通道队列的队尾指针。)*
        *   **(3) 系统设备表 SDT (System Device Table)。** 这是系统范围的数据结构，记录了系统中全部设备的情况，每个设备占一个表目，其中包括有设备类型、设备标识符、设备控制表及设备驱动程序的入口等项，如图 6-18(c) 所示。
        * ![[Pasted image 20250531142316.png]]
            *(图 6-18(c) 系统设备表示意图：包含多个表目，每个表目包含：设备类，设备标识符，DCT 指针，驱动程序入口。)*

2.  **设备分配时应考虑的因素**
    系统在分配设备时，应考虑如下几个因素：

    1)  **设备的固有属性**
        设备的固有属性可分成三种，对它们应采取不同的分配策略：
        *   **(1) 独占设备的分配策略。** 将一个设备分配给某进程后，便由该进程独占，直至该进程完成或释放该设备。
        *   **(2) 共享设备的分配策略。** 对于共享设备，可同时分配给多个进程使用，此时须注意对这些进程访问该设备的先后次序进行合理的调度。
        *   **(3) 虚拟设备的分配策略。** 虚拟设备属于可共享的设备，可以将它同时分配给多个进程使用。

    2)  **设备分配算法**
        对设备分配的算法，通常只采用以下两种分配算法：
        *   **(1) 先来先服务。** 该算法是根据诸进程对某设备提出请求的先后次序，将这些进程排成一个设备请求队列，设备分配程序总是把设备首先分配给队首进程。
        *   **(2) 优先级高者优先。** 在利用该算法形成设备队列时，将优先级高的进程排在设备队列前面，而对于优先级相同的 I/O 请求，则按先来先服务原则排队。

    3)  **设备分配中的安全性**
        从进程运行的安全性上考虑，设备分配有以下两种方式：
        *   **(1) 安全分配方式。** 每当进程发出 I/O 请求后，便进入阻塞状态，直到其 I/O 操作完成时才被唤醒。在采用该策略时，一旦进程已经获得某种设备后便阻塞，不能再请求任何资源，而在它阻塞时又不保持任何资源。因此，摒弃了造成死锁的四个必要条件之一的“请求和保持”条件，故设备分配是安全的。其缺点是 CPU 与 I/O 设备是顺序工作的。
        *   **(2) 不安全分配方式。** 在这种分配方式中，进程在发出 I/O 请求后仍继续运行，需要时又发出第二个 I/O 请求、第三个 I/O 请求等。仅当进程所请求的设备已被另一进程占用时，才进入阻塞状态。该策略的优点是，一个进程可同时操作多个设备，使进程推进迅速。其缺点是分配不安全，因为它可能具备“请求和保持”条件，从而可能造成死锁。因此，在设备分配程序中，应对本次的设备分配是否会发生死锁进行安全性计算，仅当计算结果说明分配是安全的情况下，才进行设备分配。

3.  **独占设备的分配程序**
    1)  **基本的设备分配程序**
        我们通过一个例子来介绍设备分配过程。当某进程提出 I/O 请求后，系统的设备分配程序可按下述步骤进行设备分配：
        *   **(1) 分配设备。** 首先根据 I/O 请求中的物理设备名查找系统设备表 SDT，从中找出该设备的 DCT，再根据 DCT 中的设备状态字段，可知该设备是否正忙。若忙，便将请求 I/O 的进程的 PCB 挂在设备队列上；否则，便按照一定的算法，计算本次设备分配的安全性。如果不会导致系统进入不安全状态，便将设备分配给请求进程；否则，仍将其 PCB 插入设备等待队列。
        *   **(2) 分配控制器。** 在系统把设备分配给请求 I/O 的进程后，再到其 DCT 中找出与该设备连接的控制器的 COCT，从 COCT 的状态字段中可知该控制器是否忙碌。若忙，便将请求 I/O 进程的 PCB，挂在该控制器的等待队列上。否则，便将该控制器分配给进程。
        *   **(3) 分配通道。** 在该 COCT 中又可找到与该控制器连接的通道的 CHCT，再根据 CHCT 内的状态信息可知该通道是否忙碌。若忙，便将请求 I/O 的进程挂在该通道的等待队列上；否则，将该通道分配给进程。只有在设备、控制器和通道三者都分配成功时，这次的设备分配才算成功。然后，便可启动该 I/O 设备进行数据传送。

    2)  **设备分配程序的改进**
        在上面的例子中，进程是以物理设备名提出 I/O 请求的。如果所指定的设备已分配给其它进程，则分配失败。或者说上面的设备分配程序不具有与设备无关性。为获得设备的独立性，进程应使用逻辑设备名请求 I/O。这样，系统首先从 SDT 中找出第一个该类设备的 DCT。若该设备忙，又查找第二个该类设备的 DCT，仅当所有该类设备都忙时，才把进程挂在该类设备的等待队列上。而只要有一个该类设备可用，系统便进一步计算分配该设备的安全性。如安全，便可把设备分配给它。
---
**6.5.4 逻辑设备名到物理设备名映射的实现**

为了实现与设备的无关性，当应用程序请求使用 I/O 设备时，应当用逻辑设备名。但系统只识别物理设备名，因此在系统中需要配置一张逻辑设备表，用于将逻辑设备名映射为物理设备名。

1.  **逻辑设备表 LUT (Logical Unit Table)**
    在逻辑设备表的每个表目中包含了三项：逻辑设备名、物理设备名和设备驱动程序的入口地址，如图 6-19(a) 所示。当进程用逻辑设备名请求分配 I/O 设备时，系统根据当时的具体情况，为它分配一台相应的物理设备。与此同时，在逻辑设备表上建立一个表目，填上应用程序中使用的逻辑设备名和系统分配的物理设备名，以及该设备驱动程序的入口地址。当以后进程再利用该逻辑设备名请求 I/O 操作时，系统通过查找 LUT，便可找到该逻辑设备所对应的物理设备和该设备的驱动程序。
	    ![[Pasted image 20250531142354.png]]
    *(图 6-19(a) 逻辑设备表 (表一) 示例：包含列：逻辑设备名 (如 /dev/tty, /dev/printer)，物理设备名 (如 3, 5)，驱动程序入口地址 (如 1024, 2046)。)*

2.  **逻辑设备表的设置问题**
    在系统中可采取两种方式设置逻辑设备表：
    *   **第一种方式，是在整个系统中只设置一张 LUT。** 由于系统中所有进程的设备分配情况都记录在同一张 LUT 中，因而不允许在 LUT 中具有相同的逻辑设备名，这就要求所有用户都不使用相同的逻辑设备名。在多用户环境下这通常是难以做到的，因而这种方式主要用于单用户系统中。
    *   **第二种方式，是为每个用户设置一张 LUT。** 每当用户登录时，系统便为该用户建立一个进程，同时也为之建立一张 LUT，并将该表放入进程的 PCB 中。由于通常在多用户系统中都配置了系统设备表，故此时的逻辑设备表可以采用图 6-19(b) 中的格式。
    * ![[Pasted image 20250531142403.png]]
        *(图 6-19(b) 逻辑设备表 (表二) 示例：包含列：逻辑设备名 (如 /dev/tty, /dev/printer)，系统设备表指针 (如 3, 5)，指向 SDT 中对应物理设备的表项。)*

---