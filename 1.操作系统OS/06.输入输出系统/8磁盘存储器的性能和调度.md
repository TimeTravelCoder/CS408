

磁盘存储器是计算机系统中的最重要的存储设备，在其中存放了大量的文件。对文件的读、写操作都将涉及到对磁盘的访问。磁盘 I/O 速度的高低和磁盘系统的可靠性，将直接影响到系统的性能。可以通过多种途径来改善磁盘系统的性能。首先可通过选择好的磁盘调度算法，以减少磁盘的寻道时间；其次是提高磁盘 I/O 速度，以提高对文件的访问速度；第三采取冗余技术，提高磁盘系统的可靠性，建立高度可靠的文件系统。第二和第三点我们将它放在磁盘存储器管理一章中介绍。

**6.8.1 磁盘性能简述**

磁盘设备是一种相当复杂的机电设备，在此仅对磁盘的某些性能，如数据的组织、磁盘的类型和访问时间等方面做扼要的阐述。

1.  **数据的组织和格式**
    *   磁盘设备可包括一个或多个物理盘片，每个磁盘片分一个或两个存储面 (Surface) (见图 6-28(a))，每个盘面上有若干个磁道 (Track)，磁道之间留有必要的间隙 (Gap)。
    *   为使处理简单起见，在每条磁道上可存储相同数目的二进制位。这样，磁盘密度即每英寸中所存储的位数，显然是内层磁道的密度较外层磁道的密度高。
    *   每条磁道又被从逻辑上划分成若干个扇区 (Sectors)，软盘大约为 8 至 32 个扇区，硬盘则可多达数百个。图 6-28(b) 显示了一个磁道分成 8 个扇区的布局情况。一个扇区称为一个盘块 (或数据块)，各扇区之间保留一定的间隙 (Gap)。
    * ![[Pasted image 20250531143436.png]]
	    *   (图 6-28(a) 磁盘驱动器的结构示意图：展示了多个盘面、每个盘面上的磁道、以及共用的读写磁头和主杆。)
	    *   (图 6-28(b) 磁盘的数据布局示意图：展示了一个磁道被划分为多个扇区，扇区之间有间隙，磁道之间也有间隙。)
    *   一个物理记录存储在一个扇区上，磁盘上能存储的物理记录块数目是由扇区数、磁道数以及磁盘面数所决定的。例如，一个 10GB 容量的磁盘，有 8 个双面可存储盘片，共 16 个存储面(盘面)，每面有 16383 个磁道(也称柱面)，63 个扇区。
    *   为了提高磁盘的存储容量，充分利用磁盘外面磁道的存储能力，现代磁盘不再把内外磁道划分为相同数目的扇区，而是利用外层磁道容量较内层磁道大的特点，将盘面划分成若干条环带，同一环带内的所有磁道具有相同的扇区数。显然外层环带的磁道拥有较内层环带的磁道更多的扇区。为了减少这种磁道和扇区在盘面分布的几何形式变化对驱动程序的影响，大多数现代磁盘都隐藏了这些细节，仅向操作系统提供虚拟几何的磁盘规格，而不是实际的物理几何规格。
    *   为了在磁盘上存储数据，必须先将磁盘低级格式化。图 6-29 示出了一种温盘(温切斯特盘)中一条磁道格式化的情况。其中每条磁道(Track)含有 30 个固定大小的扇区(Sectors)，每个扇区容量为 600 个字节，其中 512 个字节存放数据，其余的用于存放控制信息。每个扇区包括两个字段：
        *   ① 标识符字段 (ID Field)：其中一个字节的 SYNCH 具有特定的位图像，作为该字段的定界符，利用磁道号(Track #)、磁头号(Head #)及扇区号(Sectors #)三者来标识一个扇区；CRC 字段用于段校验。
        *   ② 数据字段 (Data Field)：存放 512 个字节的数据。
    *   值得强调的是，在磁盘一个盘面的不同磁道(Track)、每个磁道的不同扇区(Sector)，以及每个扇区的不同字段(Field)之间，为了简化和方便磁头的辨识，都设置了一个到若干个字节不同长度的间距(Gap，也称间隙)。
    * ![[Pasted image 20250531143514.png]]
	    *   (图 6-29 磁盘的格式化示意图：展示了一条磁道上多个扇区的结构，每个扇区包含 ID 字段 (含同步字节、磁道号、磁头号、扇区号、CRC) 和 Data 字段 (含同步字节、数据、CRC)，扇区之间和字段之间有间隙。)
    *   在磁盘格式化完成后，一般要对磁盘进行分区。在逻辑上，每个分区就是一个独立的逻辑磁盘。每个分区的起始扇区和大小都记录在磁盘 0 扇区的主引导记录分区表所包含的分区表中。在这个分区表中必须有一个分区被标记成活动的(即引导块)，以保证能够从硬盘引导系统。
    *   但是，在真正可以使用磁盘前，还需要对磁盘进行一次高级格式化，即设置一个引导块、空闲存储管理、根目录和一个空文件系统，同时在分区表中标记该分区所使用的文件系统。

2.  **磁盘的类型**
    对于磁盘，可以从不同的角度进行分类。最常见的有：将磁盘分成硬盘和软盘、单片盘和多片盘、固定头磁盘和活动头(移动头)磁盘等。下面仅对固定头磁盘和移动头磁盘做些介绍。
    *   **(1) 固定头磁盘。** 这种磁盘在每条磁道上都有一读/写磁头，所有的磁头都被装在一刚性磁臂中。通过这些磁头可访问所有各磁道，并进行并行读/写，有效地提高了磁盘的 I/O 速度。这种结构主要用于大容量磁盘上。
    *   **(2) 移动头磁盘。** 每一个盘面仅配有一个磁头，也被装入磁臂中。为能访问该盘面上的所有磁道，该磁头必须能移动以进行寻道。可见，移动磁头仅能以串行方式读/写，致使其 I/O 速度较慢；但由于其结构简单，故仍广泛应用于中小型磁盘设备中。在微型机上配置的温盘和软盘，都采用移动磁头结构，故本节主要针对这类磁盘的 I/O 进行讨论。

3.  **磁盘访问时间**
    磁盘设备在工作时以恒定速率旋转。为了读或写，磁头必须能移动到所指定的磁道上，并等待所指定的扇区的开始位置旋转到磁头下，然后再开始读或写数据。故可把对磁盘的访问时间分成以下三部分。
    *   **(1) 寻道时间 Tₛ (Seek Time)。** 这是指把磁臂(磁头)移动到指定磁道上所经历的时间。该时间是启动磁臂的时间 s 与磁头移动 n 条磁道所花费的时间之和，即：
        $Tₛ = m × n + s$
        其中，$m$ 是一常数，与磁盘驱动器的速度有关，对一般磁盘，m=0.2；对高速磁盘，m≤0.1。磁臂的启动时间约为 2ms。这样，对一般的温盘，其寻道时间将随寻道距离的增大而增加，大体上是 5～30ms。
    *   **(2) 旋转延迟时间 Tᵣ (Rotational Latency Time)。** 这是指定扇区移动到磁头下面所经历的时间。不同的磁盘类型中，旋转速度至少相差一个数量级，如软盘为 300r/min，硬盘一般为 7200r/min 到 15000r/min 甚至更高。对于磁盘旋转延迟时间而言，如硬盘，旋转速度为 15000r/min，每转需时 4ms，平均旋转延迟时间 Tᵣ 为 2ms；而对于软盘，其旋转速度为 300r/min 或 600r/min，这样，平均 Tᵣ 为 50～100ms。
    *   **(3) 传输时间 Tₜ (Transfer Time)。** 这是指把数据从磁盘读出或向磁盘写入数据所经历的时间。Tₜ 的大小与每次所读/写的字节数 b 和旋转速度有关：
        $Tₜ = b / (r × N)$
        其中，r 为磁盘每秒钟的转数；N 为一条磁道上的字节数。当一次读/写的字节数相当于半条磁道上的字节数时，Tₜ 与 Tᵣ 相同。因此，可将访问时间 Tₐ 表示为：
        $Tₐ = Tₛ + 1/(2r) + b/(rN)$
    *   由上式可以看出，在访问时间中，寻道时间和旋转延迟时间基本上都与所读/写数据的多少无关，而且它通常占据了访问时间中的大头。例如，我们假定寻道时间和旋转延迟时间平均为 20ms，而磁盘的传输速率为 10MB/s，如果要传输 10KB，此时总的访问时间为 21ms，可见传输时间所占比例是非常小的。当传输 100KB 数据时，其访问时间也只是 30ms，即当传输的数据量增大 10 倍时，访问时间只增加约 50%。目前磁盘的传输速率已达 80MB/s 以上，数据传输时间所占的比例更低。可见，适当地集中数据(不要太零散)传输，将有利于提高传输效率。

**6.8.2 早期的磁盘调度算法**

为了减少对文件的访问时间，应采用一种最佳的磁盘调度算法，以使各进程对磁盘的平均访问时间最小。由于在访问磁盘的时间中主要是寻道时间，因此，磁盘调度的目标是使磁盘的平均寻道时间最少。目前常用的磁盘调度算法有先来先服务、最短寻道时间优先及扫描等算法。下面逐一介绍。

1.  **先来先服务 (FCFS - First Come First Served)**
    *   这是最简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。
    *   此算法的优点是公平、简单，且每个进程的请求都能依次地得到处理，不会出现某一进程的请求长期得不到满足的情况。
    *   但此算法由于未对寻道进行优化，致使平均寻道时间可能较长。
    *   图 6-30 示出了有 9 个进程先后提出磁盘 I/O 请求时，按 FCFS 算法进行调度的情况。这里，将进程号(请求者)按他们发出请求的先后次序排队。这样，平均寻道距离为 55.3 条磁道，与后面即将讲到的几种调度算法相比，其平均寻道距离较大，故 FCFS 算法仅适用于请求磁盘 I/O 的进程数目较少的场合。
    * ![[Pasted image 20250531143725.png]]
	    *   *(图 6-30 FCFS 调度算法示例：假设当前磁头在 100 号磁道，请求序列为 $55, 58, 39, 18, 90, 160, 150, 38, 184$。移动距离分别为 $|100-55|=45, |55-58|=3,$ $|58-39|=19, |39-18|=21, |18-90|=72,$ $|90-160|=70, |160-150|=10, |150-38|=112,$ $|38-184|=146$。总移动距离 = $45+3+19+21+72+70+10+112+146 = 498$。平均寻道长度 = $498/9 = 55.3$。)*

2.  **最短寻道时间优先 (SSTF - Shortest Seek Time First)**
    *   该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，但这种算法不能保证平均寻道时间最短。
    *   图 6-31 示出按 SSTF 算法进行调度时，各进程被调度的次序、每次磁头移动的距离，以及 9 次磁头平均移动的距离。
    * ![[Pasted image 20250531143745.png]]
    *   比较图 6-30 和图 6-31 可以看出，SSTF 算法平均每次磁头移动的距离明显低于 FCFS 算法的距离，因而 SSTF 较之 FCFS 有更好的寻道性能，故过去曾一度被广泛采用。
	    *   *(图 6-31 SSTF 调度算法示例：假设当前磁头在 100 号磁道，请求序列同上。调度顺序为：100 -> 90 (移10) -> 58 (移32) -> 55 (移3) -> 39 (移16) -> 38 (移1) -> 18 (移20) -> 150 (移132) -> 160 (移10) -> 184 (移24)。$总移动距离 = 10+32+3+16+1+20+132+10+24 = 248。$平均寻道长度 = 248/9 = 27.5。)

**6.8.3 基于扫描的磁盘调度算法**

SSTF 算法的实质是基于优先级的调度算法，因此就可能导致优先级低的进程发生“饥饿”(Starvation)现象。因为只要不断有新进程的请求到达，且其所要访问的磁道与磁头当前所在磁道的距离较近，这种新进程的 I/O 请求必然优先满足。在对 SSTF 算法略加修改后，则可防止低优先级进程出现“饥饿”现象。

1.  **扫描 (SCAN) 算法**
    *   SCAN 算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁头当前的移动方向。
    *   例如，当磁头正在自里向外移动时，SCAN 算法所考虑的下一个访问对象应是其欲访问的磁道既在当前磁道之外，又是距离最近的。这样自里向外地访问，直至再无更外的磁道需要访问时，才将磁臂换向为自外向里移动。这时，同样也是每次选择这样的进程来调度：即要访问的磁道在当前位置内为距离最近者。这样，磁头又逐步地从外向里移动，直至再无更里面的磁道要访问，从而避免了出现“饥饿”现象。
    *   由于在这种算法中磁头移动的规律颇似电梯的运行，因而又常称之为电梯调度算法。
    *   图 6-32 示出了按 SCAN 算法对 9 个进程进行调度及磁头移动的情况。
    * ![[Pasted image 20250531143918.png]]
	    *   *(图 6-32 SCAN 调度算法示例：假设当前磁头在 100 号磁道，向磁道号增加方向移动。请求序列同上。调度顺序为：100 -> 150 (移50) -> 160 (移10) -> 184 (移24)。到达最外侧后改变方向 -> 90 (移94) -> 58 (移32) -> 55 (移3) -> 39 (移16) -> 38 (移1) -> 18 (移20)。总移动距离 = 50+10+24+94+32+3+16+1+20 = 250。平均寻道长度 = 250/9 = 27.8。)*

2.  **循环扫描 (CSCAN) 算法**
    *   SCAN 算法既能获得较好的寻道性能，又能防止“饥饿”现象，故被广泛用于大、中、小型机器和网络中的磁盘调度。
    *   但也存在这样的问题：当磁头刚从里向外移动而越过了某一磁道时，恰好又有一进程请求访问此磁道，这时，该进程必须等待，待磁头继续从里向外，然后再从外向里扫描完处于外面的所有要访问的磁道后，才处理该进程的请求，致使该进程的请求被大大地推迟。
    *   为了减少这种延迟，CSCAN 算法规定磁头单向移动。例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描。
    *   采用循环扫描方式后，上述请求进程的请求延迟将从原来的 2T 减为 T + Sₘₐₓ，其中 T 为由里向外或由外向里单向扫描完要访问的磁道所需的寻道时间，而 Sₘₐₓ 是将磁头从最外面被访问的磁道直接移到最里面欲访问的磁道的寻道时间(或相反)。
    *   图 6-33 示出了 CSCAN 算法对 9 个进程调度的次序及每次磁头移动的距离。
    * ![[Pasted image 20250531143948.png]]
    *   *(图 6-33 CSCAN 调度算法示例：假设当前磁头在 100 号磁道，向磁道号增加方向移动。请求序列同上。调度顺序为：100 -> 150 (移50) -> 160 (移10) -> 184 (移24)。到达最外侧后，磁头返回到最内侧请求 18 (移166，假设磁道从0开始，184->18) -> 38 (移20) -> 39 (移1) -> 55 (移16) -> 58 (移3) -> 90 (移32)。总移动距离 = 50+10+24+166+20+1+16+3+32 = 322。平均寻道长度 = 322/9 = 35.8。)*

3.  **NStepSCAN 和 FSCAN 调度算法**
    1)  **NStepSCAN 算法**
        *   在 SSTF、SCAN 及 CSCAN 几种调度算法中，都可能出现磁臂停留在某处不动的情况（磁臂粘着 Armstickiness），例如，有一个或几个进程对某一磁道有较高的访问频率，即这个(些)进程反复请求对某一磁道的 I/O 操作，从而垄断了整个磁盘设备。在高密度磁盘上容易出现此情况。
        *   N 步 SCAN 算法是将磁盘请求队列分成若干个长度为 N 的子队列，磁盘调度将按 FCFS 算法依次处理这些子队列。而每处理一个队列时又是按 SCAN 算法，对一个队列处理完后，再处理其他队列。
        *   当正在处理某子队列时，如果又出现新的磁盘 I/O 请求，便将新请求进程放入其他队列，这样就可避免出现粘着现象。
        *   当 N 值取得很大时，会使 N 步扫描法的性能接近于 SCAN 算法的性能；当 N=1 时，N 步 SCAN 算法便蜕化为 FCFS 算法。
    2)  **FSCAN 算法**
        *   FSCAN 算法实质上是 N 步 SCAN 算法的简化，即 FSCAN 只将磁盘请求队列分成两个子队列。一个是由当前所有请求磁盘 I/O 的进程形成的队列，由磁盘调度按 SCAN 算法进行处理。另一个是在扫描期间，将新出现的所有请求磁盘 I/O 的进程放入等待处理的请求队列。这样，所有的新请求都将被推迟到下一次扫描时处理。

---