
---

**6.4 设备驱动程序**

设备处理程序通常又称为设备驱动程序，它是 I/O 系统的高层与设备控制器之间的通信程序。其主要任务是接收上层软件发来的抽象 I/O 要求，如 `read` 或 `write` 命令，再把它转换为具体要求后，发送给设备控制器，启动设备去执行；反之，它也将由设备控制器发来的信号传送给上层软件。由于驱动程序与硬件密切相关，故通常应为每一类设备配置一种驱动程序。例如，打印机和显示器需要不同的驱动程序。

**6.4.1 设备驱动程序概述**

1.  **设备驱动程序的功能**
    为了实现 I/O 系统的高层与设备控制器之间的通信，设备驱动程序应具有以下功能：
    *   **(1) 接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设备相关的低层操作序列。**
    *   **(2) 检查用户 I/O 请求的合法性，了解 I/O 设备的工作状态，传递与 I/O 设备操作有关的参数，设置设备的工作方式。**
    *   **(3) 发出 I/O 命令，如果设备空闲，便立即启动 I/O 设备，完成指定的 I/O 操作；如果设备忙碌，则将请求者的请求块挂在设备队列上等待。**
    *   **(4) 及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理。**

2.  **设备驱动程序的特点**
    设备驱动程序属于低级的系统例程，它与一般的应用程序及系统程序之间有下述明显差异：
    *   **(1) 驱动程序是实现在与设备无关的软件和设备控制器之间通信和转换的程序。** 具体说，它将抽象的 I/O 请求转换成具体的 I/O 操作后传送给控制器。又把控制器中所记录的设备状态和 I/O 操作完成情况，及时地反映给请求 I/O 的进程。
    *   **(2) 驱动程序与设备控制器以及 I/O 设备的硬件特性紧密相关。** 对于不同类型的设备，应配置不同的驱动程序。但可以为相同的多个终端设置一个终端驱动程序。
    *   **(3) 驱动程序与 I/O 设备所采用的 I/O 控制方式紧密相关。** 常用的 I/O 控制方式是中断驱动和 DMA 方式。
    *   **(4) 由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言书写。** 目前有很多驱动程序的基本部分已经固化在 ROM 中。
    *   **(5) 驱动程序应允许可重入。** 一个正在运行的驱动程序常会在一次调用完成前被再次调用。

3.  **设备处理方式**
    在不同的操作系统中，所采用的设备处理方式并不完全相同。根据在设备处理时是否设置进程，以及设置什么样的进程，而把设备处理方式分成以下三类：
    *   **(1) 为每一类设备设置一个进程，专门用于执行这类设备的 I/O 操作。** 比如，为所有的交互式终端设置一个交互式终端进程；又如，为同一类型的打印机设置一个打印进程。这种方式比较适合于较大的系统。
    *   **(2) 在整个系统中设置一个 I/O 进程，专门用于执行系统中所有各类设备的 I/O 操作。** 也可以设置一个输入进程和一个输出进程，分别处理系统中的输入或输出操作。
    *   **(3) 不设置专门的设备处理进程，而只为各类设备设置相应的设备驱动程序，供用户或系统进程调用。** 这种方式目前用得较多。

**6.4.2 设备驱动程序的处理过程**

设备驱动程序的主要任务是启动指定设备，完成上层指定的 I/O 工作。但在启动之前，应先完成必要的准备工作，如检测设备状态是否为“忙”等。在完成所有的准备工作后，才向设备控制器发送一条启动命令。以下是设备驱动程序的处理过程：

1.  **将抽象要求转换为具体要求**
    *   通常在每个设备控制器中都含有若干个寄存器，分别用于暂存命令、参数和数据等。由于用户及上层软件对设备控制器的具体情况毫无了解，因而只能发出命令(抽象的要求)，这些命令是无法传送给设备控制器的。
    *   因此，就需要将这些抽象要求转换为具体要求。例如，将抽象要求中的盘块号转换为磁盘的盘面、磁道号及扇区。
    *   而这一转换工作只能由驱动程序来完成，因为在 OS 中只有驱动程序才同时了解抽象要求和设备控制器中的寄存器情况，也只有它才知道命令、数据和参数应分别送往哪个寄存器。

2.  **对服务请求进行校验**
    *   驱动程序在启动 I/O 设备之前，必须先检查该用户的 I/O 请求是不是该设备能够执行的。
    *   一个非法请求的典型例子是，用户试图请求从一台打印机读入数据。如果驱动程序能检查出这类错误，便认为这次 I/O 请求非法，它将向 I/O 系统报告 I/O 请求出错。I/O 系统可以根据具体情况做出不同的决定。如可以停止请求进程的运行，或者仅通知请求进程它的 I/O 请求有错，但仍然让它继续运行。
    *   此外，还有些设备如磁盘和终端，它们虽然都是既可读、又可写的，但若在打开这些设备时规定的是读，则用户的写请求必然被拒绝。

3.  **检查设备的状态**
    *   启动某个设备进行 I/O 操作，其前提条件应是该设备正处于就绪状态。为此，在每个设备控制器中，都配置有一个状态寄存器。
    *   驱动程序在启动设备之前，要先把状态寄存器中的内容读入到 CPU 的某个寄存器中，通过测试寄存器中的不同位，来了解设备的状态，如图 6-12 所示。例如，为了向某设备写入数据，此前应先检查状态寄存器中接收就绪的状态位，看它是否处于接收就绪状态。仅当它处于接收就绪状态时，才能启动其设备控制器，否则只能等待。
    * ![[Pasted image 20250531141320.png]]
    *   *(图 6-12 状态寄存器中的格式示意图：展示了 DSR, SYN DET, Tx EMP, Rx RDY, Tx RDY, FE, OE, PE 等状态位的含义，如发送就绪、接收就绪、发送器空、奇偶校验错、溢出错、组帧错、检出的 SYNC 特征、DSR 引脚状态等。)*

4.  **传送必要的参数**
    *   在确定设备处于接收(发送)就绪状态后，便可向控制器的相应寄存器传送数据及与控制本次数据传输有关的参数。
    *   例如，在某种设备控制器中配置了两个控制寄存器，其中一个是命令寄存器，用于存放处理机发来的各种控制命令，以决定本次 I/O 操作是接收数据还是发送数据等。另一个是方式寄存器，它用于控制本次传送数据的速率、发送的字符长度等。
    *   如果是利用 RS232C 接口进行异步通信，在启动该接口之前，应先按通信规程设定下述参数：波特率、奇偶校验方式、停止位数目及数据字节长度等。
    *   对于较为复杂的块设备，除必须向其控制器发出启动命令外，还需传送更多的参数。

5.  **启动 I/O 设备**
    *   在完成上述各项准备工作后，驱动程序便可以向控制器中的命令寄存器传送相应的控制命令。
    *   对于字符设备，若发出的是写命令，驱动程序便把一个字符(或字)，传送给控制器；若发出的是读命令，则驱动程序等待接收数据，并通过读入控制器的状态寄存器中状态字的方法来确定数据是否到达。

在多道程序系统中，驱动程序一旦发出 I/O 命令，启动了一个 I/O 操作后，驱动程序便把控制返回给 I/O 系统，把自己阻塞起来，直到中断到来时再被唤醒。具体的 I/O 操作是在设备控制器的控制下进行的，因此，在设备忙于传送数据时，处理机又可以去干其它的事情，实现了处理机与 I/O 设备的并行操作。

**6.4.3 对 I/O 设备的控制方式**

对设备的控制，早期是使用轮询的可编程 I/O 方式，后来发展为使用中断的可编程 I/O 方式。随着 DMA 控制器的出现，从以字节为单位，改为以数据块为单位进行转输，大大地改善了块设备的 I/O 性能。I/O 通道的出现，又使对 I/O 操作的组织和数据的传送都能独立进行，而无需 CPU 的干预。应当指出，在 I/O 控制方式的整个发展过程中，始终贯穿着这样一条宗旨，即尽量减少主机对 I/O 控制的干预，把主机从繁杂的 I/O 控制事务中解脱出来，以便更多地去完成数据处理任务。

1.  **使用轮询的可编程 I/O 方式**
    *   **方式**：处理机对 I/O 设备的控制采取轮询的可编程 I/O 方式，即在处理机向控制器发出一条 I/O 指令，启动输入设备输入数据时，要同时把状态寄存器中的忙/闲标志 `busy` 置为 1，然后便不断地循环测试 `busy` (称为轮询)。
    *   **过程**：当 `busy=1` 时，表示输入机尚未输完一个字(符)，处理机应继续对该标志进行测试，直至 `busy=0`，表明输入机已将输入数据送入控制器的数据寄存器中。于是处理机将数据寄存器中的数据取出，送入内存指定单元中，这样便完成了一个字(符)的 I/O。接着再去启动读下一个数据，并置 `busy=1`。
    * ![[Pasted image 20250531141416.png]]
    *   *(图 6-13(a) 示出了程序 I/O 方式的流程：CPU 向 I/O 控制器发读命令 (CPU-I/O) -> CPU 读 I/O 控制器的状态 (I/O-CPU)，检查状态，若未就绪则循环检查，若出错则处理，若就绪则从 I/O 控制器中读入字 (I/O-CPU) -> CPU 向存储器中写字 (CPU->内存) -> 判断传送是否完成，未完成则继续，完成后执行下一条指令。)*
    *   **缺点**：在程序 I/O 方式中，CPU 的绝大部分时间都处于等待 I/O 设备完成数据 I/O 的循环测试中，造成对 CPU 的极大浪费。在该方式中，CPU 之所以要不断地测试 I/O 设备的状态，就是因为在 CPU 中无中断机构，使 I/O 设备无法向 CPU 报告它已完成了一个字符的输入操作。

2.  **使用中断的可编程 I/O 方式**
    *   **方式**：当前，对 I/O 设备的控制，广泛采用中断的可编程 I/O 方式，即当某进程要启动某个 I/O 设备工作时，便由 CPU 向相应的设备控制器发出一条 I/O 命令，然后立即返回继续执行原来的任务。设备控制器于是按照该命令的要求去控制指定 I/O 设备。
    *   **过程**：此时，CPU 与 I/O 设备并行操作。例如，在输入时，当设备控制器收到 CPU 发来的读命令后，便去控制相应的输入设备读数据。一旦数据进入数据寄存器，控制器便通过控制线向 CPU 发送一中断信号，由 CPU 检查输入过程中是否出错，若无错，便向控制器发送取走数据的信号，然后再通过控制器及数据线，将数据写入内存指定单元中。
    * ![[Pasted image 20250531141449.png]]
    *   *(图 6-13(b) 示出了中断驱动 I/O 方式的流程：CPU 向 I/O 控制器发读命令 (CPU-I/O)，然后 CPU 做其它事 -> I/O 控制器准备好数据后产生中断 -> CPU 读 I/O 控制器的状态 (I/O-CPU)，检查状态，若出错则处理，若就绪则从 I/O 控制器中读入字 (I/O-CPU) -> CPU 向存储器中写字 (CPU->内存) -> 判断传送是否完成，未完成则继续，完成后执行下一条指令。)*
    *   **优点**：在 I/O 设备输入每个数据的过程中，可使 CPU 与 I/O 设备并行工作。仅当输完一个数据时，才需 CPU 花费极短的时间去做些中断处理。这样可使 CPU 和 I/O 设备都处于忙碌状态，从而提高了整个系统的资源利用率及吞吐量。例如，从终端输入一个字符的时间约为 100ms，而将字符送入终端缓冲区的时间小于 0.1ms。若采用程序 I/O 方式，CPU 约有 99.9ms 的时间处于忙—等待中。但采用中断驱动方式后，CPU 可利用这 99.9ms 的时间去做其它的事情，而仅用 0.1ms 的时间来处理由控制器发来的中断请求。可见，中断驱动方式可以成百倍地提高 CPU 的利用率。

3.  **直接存储器访问 (DMA) 方式**
    1)  **直接存储器访问方式的引入**
        *   虽然中断驱动 I/O 比程序 I/O 方式更有效，但它仍是以字(节)为单位进行 I/O 的。每当完成一个字(节)的 I/O 时，控制器便要向 CPU 请求一次中断。换而言之，采用中断驱动 I/O 方式时的 CPU，是以字(节)为单位进行干预的。如果将这种方式用于块设备的 I/O，显然是极其低效的。例如，为了从磁盘中读出 1KB 的数据块，需要中断 CPU 1K 次。
        *   为了进一步减少 CPU 对 I/O 的干预，而引入了直接存储器访问方式，见图 6-13(c) 所示。
        *   **该方式的特点是**：
            *   (1) 数据传输的基本单位是数据块，即在 CPU 与 I/O 设备之间，每次传送至少一个数据块。
            *   (2) 所传送的数据是从设备直接送入内存的，或者相反。
            *   (3) 仅在传送一个或多个数据块的开始和结束时，才需 CPU 干预，整块数据的传送是在控制器的控制下完成的。
        *   可见，DMA 方式较之中断驱动方式又进一步提高了 CPU 与 I/O 设备的并行操作程度。
        *  ![[Pasted image 20250531141536.png]]
        * *(图 6-13(c) 示出了 DMA 方式的流程：CPU 向 I/O 控制器发布读块命令 (CPU-DMA)，然后 CPU 做其它事 -> DMA 控制器完成数据块传送后产生中断 -> CPU 读 DMA 控制器的状态 (DMA-CPU)，完成后执行下一条指令。)*

    2)  **DMA 控制器的组成**
        DMA 控制器由三部分组成：主机与 DMA 控制器的接口；DMA 控制器与块设备的接口；I/O 控制逻辑。图 6-14 示出了 DMA 控制器的组成。这里主要介绍主机与控制器之间的接口。
	        ![[Pasted image 20250531141631.png]]
        *(图 6-14 DMA 控制器的组成示意图：包含 CPU、内存、系统总线、DMA 控制器。DMA 控制器内部有与主机的接口（连接系统总线）、与块设备的接口，以及内部寄存器如 DR, MAR, DC, CR。)*
        为了实现在主机与控制器之间成块数据的直接交换，必须在 DMA 控制器中，设置如下四类寄存器：
        *   (1) **命令/状态寄存器 CR (Command/Status Register)**：用于接收从 CPU 发来的 I/O 命令，或有关控制信息，或设备的状态。
        *   (2) **内存地址寄存器 MAR (Memory Address Register)**：在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。
        *   (3) **数据寄存器 DR (Data Register)**：用于暂存从设备到内存，或从内存到设备的数据。
        *   (4) **数据计数器 DC (Data Counter)**：存放本次 CPU 要读或写的字(节)数。

    3)  **DMA 工作过程**
        * ![[Pasted image 20250531141704.png]]
        * 当 CPU 要从磁盘读入一数据块时，便向磁盘控制器发送一条读命令。该命令被送入命令寄存器 CR 中。同时，需要将本次要读入数据在内存的起始目标地址送入内存地址寄存器 MAR 中。将要读数据的字(节)数送入数据计数器 DC 中。还须将磁盘中的源地址直接送至 DMA 控制器的 I/O 控制逻辑上。
        *   然后，启动 DMA 控制器进行数据传送。以后，CPU 便可去处理其它任务，整个数据传送过程由 DMA 控制器进行控制。
        *   当 DMA 控制器已从磁盘中读入一个字(节)的数据，并送入数据寄存器 DR 后，再挪用一个存储器周期，将该字(节)传送到 MAR 所指示的内存单元中。
        *   然后便对 MAR 内容加 1，将 DC 内容减 1。若减 1 后 DC 内容不为 0，表示传送未完，便继续传送下一个字(节)；否则，由 DMA 控制器发出中断请求。
        *   *(图 6-15 DMA 方式的工作流程图：设置 MAR 和 DC 初值 -> 启动 DMA 传送命令 -> 挪用存储器周期传送数据字 -> 存储器地址增 1，数据计数寄存器减 1 -> 判断 DC=0? 若否，则在继续执行用户程序的同时，准备又一次传送；若是，则请求中断。)*

4.  **I/O 通道控制方式**
    1)  **I/O 通道控制方式的引入**
        *   虽然 DMA 方式比起中断方式来已经显著地减少了 CPU 的干预，即已由以字(节)为单位的干预减少到以数据块为单位的干预，但 CPU 每发出一条 I/O 指令，也只能去读(或写)一个连续的数据块。
        *   而当我们需要一次去读多个数据块且将它们分别传送到不同的内存区域，或者相反时，则须由 CPU 分别发出多条 I/O 指令及进行多次中断处理才能完成。
        *   I/O 通道方式是 DMA 方式的发展，它可进一步减少 CPU 的干预，即把对一个数据块的读(或写)为单位的干预，减少为对一组数据块的读(或写)及有关的控制和管理为单位的干预。
        *   同时，又可实现 CPU、通道和 I/O 设备三者的并行操作，从而更有效地提高整个系统的资源利用率。例如，当 CPU 要完成一组相关的读(或写)操作及有关控制时，只需向 I/O 通道发送一条 I/O 指令，以给出其所要执行的通道程序的首址和要访问的 I/O 设备，通道接到该指令后，通过执行通道程序便可完成 CPU 指定的 I/O 任务。

    2)  **通道程序**
        *   通道是通过执行通道程序并与设备控制器共同实现对 I/O 设备的控制的。
        *   通道程序是由一系列通道指令(或称为通道命令)所构成的。
        *   通道指令与一般的机器指令不同，在它的每条指令中都包含下列诸信息：
            *   (1) **操作码**：它规定了指令所执行的操作，如读、写、控制等操作。
            *   (2) **内存地址**：标明字符送入内存(读操作)和从内存取出(写操作)时的内存首址。
            *   (3) **计数**：表示本条指令所要读(或写)数据的字节数。
            *   (4) **通道程序结束位 P**：用于表示通道程序是否结束。P=1 表示本条指令是通道程序的最后一条指令。
            *   (5) **记录结束标志 R**：R=0 表示本通道指令与下一条指令所处理的数据是同属于一个记录；R=1 表示这是处理某记录的最后一条指令。
        *   *下面示出了一个由六条通道指令所构成的简单的通道程序。该程序的功能是将内存中不同地址的数据写成多个记录。其中，前三条指令是分别将 813~892 单元中的 80 个字符和 1034~1173 单元中的 140 个字符及 5830~5889 单元中的 60 个字符写成一个记录；第 4 条指令是单独写一个具有 300 个字符的记录；第 5、6 条指令共写含 300 个字符的记录。*
            ![[Pasted image 20250531141856.png]]

---